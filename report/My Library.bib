@online{359929WhenClicking,
  title = {359929 – {{When}} Clicking on a Hyperlink to Another {{PDF}} File, {{Okular}} Should Open a New Window},
  url = {https://bugs.kde.org/show_bug.cgi?id=359929},
  urldate = {2023-11-05},
  file = {/home/areo/Zotero/storage/ZWJUPDDM/show_bug.html}
}

@software{ActionsStarterworkflows2022,
  title = {Actions/Starter-Workflows},
  date = {2022-04-11},
  url = {https://github.com/actions/starter-workflows/blob/70f16d3552b2b728227019eb69710ed1b44cf811/ci/python-package.yml},
  urldate = {2022-04-11},
  abstract = {Accelerating new GitHub Actions workflows},
  organization = {GitHub Actions}
}

@online{aneuryzmWhatDoesDouble2021,
  type = {Forum post},
  title = {What Does a Double Slash in the {{URL}} Path Mean?},
  author = {{aneuryzm}},
  date = {2021-09-16},
  url = {https://webmasters.stackexchange.com/q/8354},
  urldate = {2023-11-05},
  organization = {Webmasters Stack Exchange},
  file = {/home/areo/Zotero/storage/FNL8UXXM/what-does-a-double-slash-in-the-url-path-mean.html}
}

@online{ANormalizationWhyHow,
  title = {A-{{Normalization}}: {{Why}} and {{How}} (with Code)},
  url = {https://matt.might.net/articles/a-normalization/},
  urldate = {2022-07-23}
}

@online{ANSIGrammarLex,
  title = {{{ANSI C}} Grammar ({{Lex}})},
  url = {https://www.lysator.liu.se/c/ANSI-C-grammar-l.html},
  urldate = {2022-07-29},
  file = {/home/areo/Zotero/storage/HFF3AUH2/ANSI-C-grammar-l.html;/home/areo/Zotero/storage/XD7B4BJU/ANSI-C-grammar-l.html}
}

@online{ANSIGrammarLexa,
  title = {{{ANSI C}} Grammar ({{Lex}})},
  url = {https://www.quut.com/c/ANSI-C-grammar-l-2011.html},
  urldate = {2022-08-15},
  file = {/home/areo/Zotero/storage/P2E3RLFC/ANSI-C-grammar-l-2011.html}
}

@online{ANSIGrammarLexb,
  title = {{{ANSI C}} Grammar ({{Lex}}) Old},
  url = {https://www.lysator.liu.se/c/ANSI-C-grammar-l.html},
  urldate = {2022-08-15},
  file = {/home/areo/Zotero/storage/6TJ9I9BL/ANSI-C-grammar-l.html}
}

@online{ANSIGrammarYacc,
  title = {{{ANSI C}} Grammar ({{Yacc}})},
  url = {http://www.quut.com/c/ANSI-C-grammar-y.html},
  urldate = {2022-07-29},
  file = {/home/areo/Zotero/storage/BZFHXQ5R/ANSI-C-grammar-y.html;/home/areo/Zotero/storage/XXT4QLK3/ANSI-C-grammar-y.html}
}

@online{ANSIGrammarYacca,
  title = {{{ANSI C}} Grammar ({{Yacc}})},
  url = {https://www.quut.com/c/ANSI-C-grammar-y.html},
  urldate = {2022-08-15},
  file = {/home/areo/Zotero/storage/YC8WB87R/ANSI-C-grammar-y.html}
}

@online{ANSIGrammarYaccb,
  title = {{{ANSI C}} Grammar ({{Yacc}}) Old},
  url = {https://www.lysator.liu.se/c/ANSI-C-grammar-y.html},
  urldate = {2022-08-15},
  file = {/home/areo/Zotero/storage/3DFAJJG7/ANSI-C-grammar-y.html}
}

@online{AnswerWhatDifference2018,
  title = {Answer to "{{What}} Is the Difference between Tree Search and Graph Search?"},
  shorttitle = {Answer to "{{What}} Is the Difference between Tree Search and Graph Search?},
  date = {2018-12-16},
  url = {https://ai.stackexchange.com/a/9554},
  urldate = {2023-06-04},
  organization = {Artificial Intelligence Stack Exchange},
  file = {/home/areo/Zotero/storage/YJLYFXFC/what-is-the-difference-between-tree-search-and-graph-search.html}
}

@online{ANTLR,
  title = {{{ANTLR}}},
  url = {https://www.antlr.org/},
  urldate = {2022-07-31},
  file = {/home/areo/Zotero/storage/FE43SMM9/www.antlr.org.html}
}

@inreference{AnweisungProgrammierung2022,
  title = {Anweisung (Programmierung)},
  booktitle = {Wikipedia},
  date = {2022-05-17T16:43:25Z},
  url = {https://de.wikipedia.org/w/index.php?title=Anweisung_(Programmierung)&oldid=222957636},
  urldate = {2022-09-13},
  abstract = {Als Anweisung oder Statement (aus englisch statement entlehnt) wird in der Informatik im Bereich der Programmierung ein zentrales Element vieler imperativer Programmiersprachen bezeichnet. Die Programme derartiger Sprachen setzen sich hauptsächlich aus einer oder mehreren Anweisungen zusammen. Eine Anweisung stellt eine in der Syntax einer Programmiersprache formulierte einzelne Vorschrift dar, die im Rahmen der Abarbeitung des Programms auszuführen ist. Wie eine Anweisung syntaktisch auszusehen hat, wird durch die jeweilige Programmiersprache oder deren Spezifikation festgelegt und ist innerhalb eines Programms (üblicherweise) nicht änderbar. In der maschinennahen Programmierung werden Anweisungen häufig auch als Befehl, Instruktion (aus englisch instruction) oder Kommando (aus englisch command) bezeichnet. Anweisungen sind üblicherweise Zuweisungen, Kontrollanweisungen (wie Sprünge, Schleifen und bedingte Anweisungen) und Prozeduraufrufe. Abhängig von der Programmiersprache sind teilweise auch Zusicherungen, Deklarationen, Klassen- und Funktionsdefinitionen Anweisungen. Im Gegensatz zu Ausdrücken haben Anweisungen nicht immer einen Wert. Einige Anweisungen können jedoch auch Ausdrücke sein, so z. B. Zuweisungen, Inkrementoperatoren oder Funktionsaufrufe. Umgekehrt sind viele Ausdruckstypen wie etwa Vergleiche oder arithmetische Ausdrücke keine syntaktisch vollständigen Anweisungen. Sequenzen von Anweisungen werden häufig in Blöcken zusammengefasst.},
  langid = {ngerman},
  annotation = {Page Version ID: 222957636},
  file = {/home/areo/Zotero/storage/TH8RYP3L/Anweisung_(Programmierung).html}
}

@artwork{aorimnEnglishSchemaXEX2016,
  title = {English:  {{Schema}} of an {{XEX}} Encryption},
  shorttitle = {English},
  author = {{Aorimn}},
  date = {2016-02-04},
  url = {https://commons.wikimedia.org/wiki/File:XEX_mode_encryption.svg},
  urldate = {2024-07-04},
  file = {/home/areo/Zotero/storage/943CGYAI/FileXEX_mode_encryption.html}
}

@online{ArchLinuxArchWiki,
  title = {Arch {{Linux}} - {{ArchWiki}}},
  url = {https://wiki.archlinux.org/title/Arch_Linux},
  urldate = {2023-11-05},
  file = {/home/areo/Zotero/storage/G3HZHFZ7/Arch_Linux.html}
}

@online{ArchLinuxDesktopfileutils,
  title = {Arch {{Linux}} - Desktop-File-Utils 0.27-1 (X86\_64)},
  url = {https://archlinux.org/packages/extra/x86_64/desktop-file-utils/},
  urldate = {2023-11-05},
  file = {/home/areo/Zotero/storage/DNICJ4A4/desktop-file-utils.html}
}

@inreference{Assembler2021,
  title = {Assembler},
  booktitle = {Wikipedia},
  date = {2021-05-23T07:48:36Z},
  url = {https://de.wikipedia.org/w/index.php?title=Assembler&oldid=212253092},
  urldate = {2022-09-13},
  abstract = {Assembler steht für: Assembler (Informatik), ein Computerprogramm, das eine Assemblersprache in Maschinensprache übersetzt Assemblersprache, eine Klasse von Programmiersprachen für Computer Assembler (Bioinformatik), ein Computerprogramm, das eine Genomassemblierung durchführt Assembler (Nanotechnologie), ein Roboter, der Atome und Moleküle manipuliertSiehe auch:},
  langid = {ngerman},
  annotation = {Page Version ID: 212253092},
  file = {/home/areo/Zotero/storage/5KSPVT46/Assembler.html}
}

@inreference{Assemblersprache2022,
  title = {Assemblersprache},
  booktitle = {Wikipedia},
  date = {2022-08-19T03:32:55Z},
  url = {https://de.wikipedia.org/w/index.php?title=Assemblersprache&oldid=225449545},
  urldate = {2022-09-13},
  abstract = {Eine Assemblersprache, kurz auch Assembler genannt (von englisch to assemble  ‚zusammenfügen‘), ist eine Programmiersprache, die auf den Befehlsvorrat eines bestimmten Computertyps (d. h. dessen Prozessorarchitektur) ausgerichtet ist. Assemblersprachen bezeichnet man deshalb als maschinenorientierte Programmiersprachen und – als Nachfolger der direkten Programmierung mit Zahlencodes – als Programmiersprachen der zweiten Generation: Anstelle eines Binärcodes der Maschinensprache können Befehle und deren Operanden durch leichter verständliche mnemonische Symbole in Textform (z. B. „MOVE“), Operanden z. T. als symbolische Adresse (z. B. „PLZ“), notiert und dargestellt werden.Der Quelltext eines Assemblerprogramms wird mit Hilfe einer Übersetzungssoftware (Assembler oder Assemblierer) in Maschinencode übersetzt. Dagegen übersetzt in höheren Programmiersprachen (Hochsprachen, dritte Generation) ein sogenannter Compiler abstraktere (komplexere, nicht auf den Prozessor-Befehlssatz begrenzte) Befehle in den Maschinencode der gegebenen Zielarchitektur – oder in eine Zwischensprache.Umgangssprachlich werden die Ausdrücke „Maschinensprache“ und „Assembler(sprache)“ häufig synonym verwendet.},
  langid = {ngerman},
  annotation = {Page Version ID: 225449545},
  file = {/home/areo/Zotero/storage/WVSP3VC8/Assemblersprache.html}
}

@software{astaninPythontabulate2022,
  title = {Python-Tabulate},
  author = {Astanin, Sergey},
  date = {2022-01-26},
  url = {https://github.com/astanin/python-tabulate},
  urldate = {2022-01-28},
  abstract = {Pretty-print tabular data in Python, a library and a command-line utility. Repository migrated from bitbucket.org/astanin/python-tabulate.}
}

@inreference{Aufrufstapel2021,
  title = {Aufrufstapel},
  booktitle = {Wikipedia},
  date = {2021-03-20T18:12:21Z},
  url = {https://de.wikipedia.org/w/index.php?title=Aufrufstapel&oldid=210008829},
  urldate = {2022-09-13},
  abstract = {Unter einem Aufrufstapel (englisch call stack, procedure stack) versteht man in der Softwaretechnik und Informatik einen besonders genutzten Stapelspeicher, der zur Laufzeit eines Programms den Zustand der gerade aufgerufenen Unterprogramme enthält. Er ist vorgesehener Bestandteil der meisten Prozessorarchitekturen und seine Benutzung wird daher von speziellen Instruktionen und Registern unterstützt oder sogar erfordert. Als Stack Machine (engl. für Stapelmaschine, nicht zu verwechseln mit Kellerautomat) wird eine Klasse von Prozessorarchitekturen bezeichnet, die gänzlich um einen Aufrufstapel herum konstruiert sind, demgegenüber verwenden Registermaschinen zwar üblicherweise einen Aufrufstapel, sind jedoch nicht ausschließlich auf seine Nutzung angewiesen. Die Verwaltung des Aufrufstapels wird in Hochsprachen üblicherweise abstrahiert und stattdessen von Compiler und Betriebssystem übernommen. Anders als beim paradigmatischen Stapelspeicher sind die Zugriffsmöglichkeiten auf den Aufrufstapel in vielen Architekturen jedoch nicht auf das oberste Element beschränkt und die Klassifizierung als Stapel ergibt sich aus der Verwendung als Stapelspeicher für Rücksprungadressen von Unterprogrammen. Zudem ist der Inhalt des Speichers sehr inhomogen und verknüpft Nutzdaten mit Verwaltungsdaten.},
  langid = {ngerman},
  annotation = {Page Version ID: 210008829},
  file = {/home/areo/Zotero/storage/A43ICZ6T/Aufrufstapel.html}
}

@inreference{AusdruckProgrammierung2021,
  title = {Ausdruck (Programmierung)},
  booktitle = {Wikipedia},
  date = {2021-06-14T19:25:24Z},
  url = {https://de.wikipedia.org/w/index.php?title=Ausdruck_(Programmierung)&oldid=212957642},
  urldate = {2022-09-13},
  abstract = {Ein Ausdruck ist in vielen Programmiersprachen ein Konstrukt, das gemäß einer gegebenen Semantik in Bezug auf einen Kontext ausgewertet werden kann, also einen Wert liefert. In vielen formalen Sprachen sind Ausdrücke eines der wichtigsten Konstrukte, wenn nicht gar das einzige. Einige Beispiele: Arithmetische Ausdrücke 2*3; 2(x − a); x2 = 2x; y= sin(x); usw. Aussagenlogische Ausdrücke a und b; wenn b dann a; a oder nicht b; usw. Prädikatenlogische Ausdrücke wenn verheiratet(A, B) dann verheiratet(B, A); wenn Mensch(A) dann (Mann(A) oder Frau(A)); usw.Ausdrücke in Programmiersprachen Literale (Konstanten): 2, 3.14, … (Aber auch Zeichenketten (Strings) und Zeichen: "Hallo Welt", 'c', …) Variablen: x, betragInEuro, wochentagsNummer, … Funktionen: sin(phi), random(), aktMonatsNummer(), … Operationen: 2*3, 2(x - a), x\textasciicircum 3, cos(2*x + 3.14), … Kombinierte Ausdrücke, zum Teil auch mit Zuweisungen oder Ausdrucksanweisungen: x++, --y, y = x = 2*z, y = sin(x), …Neben den Ausdrücken sind in vielen formalen Sprachen Deklarationen wichtig, die den Kontext für die Ausdrücke definieren. Diese werden manchmal (vor allem in funktionalen Programmiersprachen und Skriptsprachen) selbst ebenfalls als Ausdrücke betrachtet.},
  langid = {ngerman},
  annotation = {Page Version ID: 212957642},
  file = {/home/areo/Zotero/storage/DM6IUCA4/Ausdruck_(Programmierung).html}
}

@online{AverageCharacterLength,
  title = {U.{{S}}. Average Character Length of a Password 2021},
  url = {https://www.statista.com/statistics/1305713/average-character-length-of-a-password-us/},
  urldate = {2024-06-13},
  abstract = {Approximately six out of ten Americans had passwords between eight and 11 characters long in 2021.},
  langid = {english},
  organization = {Statista},
  file = {/home/areo/Zotero/storage/4IGK5932/average-character-length-of-a-password-us.html}
}

@online{awesoonAnswerWhyConst2013,
  title = {Answer to "why Const Char *pt2=\{'1', '2', '3', '\textbackslash textbackslash0'\}; Can't Compile?"},
  shorttitle = {Answer to "why Const Char *pt2=\{'1', '2', '3', '\textbackslash textbackslash0'\}; Can't Compile?},
  author = {{awesoon}},
  date = {2013-05-29},
  url = {https://stackoverflow.com/a/16808070},
  urldate = {2022-05-07},
  file = {/home/areo/Zotero/storage/H828L878/why-const-char-pt2-1-2-3-0-cant-compile.html}
}

@online{awesoonAnswerWhyConst2013a,
  title = {Answer to "why Const Char *pt2=\{'1', '2', '3', '\textbackslash textbackslashtextbackslash0'\}; Can't Compile?"},
  shorttitle = {Answer to "why Const Char *pt2=\{'1', '2', '3', '\textbackslash textbackslashtextbackslash0'\}; Can't Compile?},
  author = {{awesoon}},
  date = {2013-05-29},
  url = {https://stackoverflow.com/a/16808070},
  urldate = {2022-05-07},
  file = {/home/areo/Zotero/storage/H2IUY5EF/why-const-char-pt2-1-2-3-0-cant-compile.html}
}

@online{ayushAnswerWhatDifference2011,
  title = {Answer to "{{What}} Is the Difference between {{URI}}, {{URL}} and {{URN}}?"},
  shorttitle = {Answer to "{{What}} Is the Difference between {{URI}}, {{URL}} and {{URN}}?},
  author = {{ayush}},
  date = {2011-02-06},
  url = {https://stackoverflow.com/a/4913371},
  urldate = {2023-11-05},
  organization = {Stack Overflow},
  file = {/home/areo/Zotero/storage/TGWYD2UG/what-is-the-difference-between-uri-url-and-urn.html}
}

@inreference{BackusNaurForm2022,
  title = {Backus–{{Naur}} Form},
  booktitle = {Wikipedia},
  date = {2022-06-15T13:31:34Z},
  url = {https://en.wikipedia.org/w/index.php?title=Backus%E2%80%93Naur_form&oldid=1093258638},
  urldate = {2022-07-31},
  abstract = {In computer science, Backus–Naur form () or Backus normal form (BNF) is a metasyntax notation for context-free grammars, often used to describe the syntax of languages used in computing, such as computer programming languages, document formats, instruction sets and communication protocols. They are applied wherever exact descriptions of languages are needed: for instance, in official language specifications, in manuals, and in textbooks on programming language theory. Many extensions and variants of the original Backus–Naur notation are used; some are exactly defined, including extended Backus–Naur form (EBNF) and augmented Backus–Naur form (ABNF).},
  langid = {english},
  annotation = {Page Version ID: 1093258638},
  file = {/home/areo/Zotero/storage/R4JLVZ75/Backus–Naur_form.html}
}

@inreference{BackusNaurForm2022a,
  title = {Backus-Naur-Form},
  booktitle = {Wikipedia},
  date = {2022-06-16T13:55:21Z},
  url = {https://de.wikipedia.org/w/index.php?title=Backus-Naur-Form&oldid=223748201},
  urldate = {2022-09-13},
  abstract = {Die Backus-Naur-Form oder Backus-Normalform (kurz BNF) ist eine kompakte formale Metasprache zur Darstellung kontextfreier Grammatiken (Typ-2-Grammatiken in der Chomsky-Hierarchie). Hierzu zählt die Syntax gängiger höherer Programmiersprachen. Sie wird auch für die Notation von Befehlssätzen und Kommunikationsprotokollen verwendet. Ursprünglich war sie nach John W. Backus benannt, später wurde sie (auf Anregung von Donald E. Knuth) auch nach Peter Naur benannt. Beide waren Pioniere der Informatik, die sich mit der Erstellung der Algol-60-Regeln und insbesondere mit der Kunst des Compilerbaus beschäftigten. Durch die Backus-Naur-Form im Algol 60 Report wurde es erstmals möglich, die Syntax einer Programmiersprache formal exakt, also ohne die Ungenauigkeiten natürlicher Sprachen, darzustellen. Es gibt viele Varianten der Backus-Naur-Form. Die erweiterte Backus-Naur-Form (EBNF) ist eine gebräuchliche Variante, die unter anderem eine kompakte Notation von sich wiederholenden Elementen erlaubt. Für Syntaxdefinitionen in Internetnormen wird überwiegend die angereicherte Backus-Naur-Form (ABNF) verwendet.},
  langid = {ngerman},
  annotation = {Page Version ID: 223748201},
  file = {/home/areo/Zotero/storage/GFXI68XJ/Backus-Naur-Form.html}
}

@online{Baeume,
  title = {Bäume},
  url = {https://www.stefan-marr.de/pages/informatik-abivorbereitung/baume/},
  urldate = {2022-07-17},
  langid = {ngerman}
}

@book{baierPrinciplesModelChecking2008,
  title = {Principles of {{Model Checking}}},
  author = {Baier, Christel and Katoen, Joost-Pieter},
  date = {2008-04-25},
  eprint = {5dvxCwAAQBAJ},
  eprinttype = {googlebooks},
  publisher = {MIT Press},
  abstract = {A comprehensive introduction to the foundations of model checking, a fully automated technique for finding flaws in hardware and software; with extensive examples and both practical and theoretical exercises.Our growing dependence on increasingly complex computer and software systems necessitates the development of formalisms, techniques, and tools for assessing functional properties of these systems. One such technique that has emerged in the last twenty years is model checking, which systematically (and automatically) checks whether a model of a given system satisfies a desired property such as deadlock freedom, invariants, and request-response properties. This automated technique for verification and debugging has developed into a mature and widely used approach with many applications. Principles of Model Checking offers a comprehensive introduction to model checking that is not only a text suitable for classroom use but also a valuable reference for researchers and practitioners in the field.The book begins with the basic principles for modeling concurrent and communicating systems, introduces different classes of properties (including safety and liveness), presents the notion of fairness, and provides automata-based algorithms for these properties. It introduces the temporal logics LTL and CTL, compares them, and covers algorithms for verifying these logics, discussing real-time systems as well as systems subject to random phenomena. Separate chapters treat such efficiency-improving techniques as abstraction and symbolic manipulation. The book includes an extensive set of examples (most of which run through several chapters) and a complete set of basic results accompanied by detailed proofs. Each chapter concludes with a summary, bibliographic notes, and an extensive list of exercises of both practical and theoretical nature.},
  isbn = {978-0-262-30403-0},
  langid = {english},
  pagetotal = {994},
  keywords = {Computers / Operating Systems / General,Computers / Programming / Algorithms}
}

@unpublished{bastProgrammieren2020,
  type = {Vorlesung},
  title = {Programmieren in C},
  author = {Bast, Hannah},
  date = {2020},
  url = {https://ad-wiki.informatik.uni-freiburg.de/teaching/ProgrammierenCplusplusSS2020},
  urldate = {2022-07-09},
  langid = {ngerman},
  venue = {Universität Freiburg}
}

@inreference{Bezeichner2020,
  title = {Bezeichner},
  booktitle = {Wikipedia},
  date = {2020-06-18T17:53:22Z},
  url = {https://de.wikipedia.org/w/index.php?title=Bezeichner&oldid=201100315},
  urldate = {2022-09-13},
  abstract = {Ein Bezeichner (selten auch Identifikator, englisch identifier) ist in der Informatik ein Identifikator, mit dem ein Programmierer in einem Programm ein Objekt, z. B. einen Datentyp, eine Variable oder eine Funktion, eindeutig benennt. Daher muss ein Bezeichner innerhalb eines Namensraums eindeutig sein, es sei denn, die Programmiersprache erlaubt das Überladen. In der Regel werden für Bezeichner Literale (aus Buchstaben) verwendet. Auch Numerale (aus Ziffern) sind üblich, erlauben aber keine gute Mnemonik, diese wird mit einer Kombination einer Zeichenfolge aus Buchstaben und Nummern erreicht. Zur Typenkennzeichnung werden häufig Präfixe oder Suffixe benutzt. Programmiersprachen verwenden verschiedene Konventionen für Bezeichner, z. B. welche (Sonder-)Zeichen darin vorkommen dürfen, ob Groß- und Kleinschreibung unterschieden wird und wie lang der Bezeichner maximal sein darf. Darüber hinaus können weitergehende Benennungsregeln angewendet werden, die zum Teil öffentlich definiert sind (zum Beispiel in der Ungarischen Notation) oder die als Unternehmensstandard, den Programmierstil betreffend, festgelegt wurden.},
  langid = {ngerman},
  annotation = {Page Version ID: 201100315},
  file = {/home/areo/Zotero/storage/J8HG72X9/Bezeichner.html}
}

@online{bhass1AnswerWhyCBC2017,
  title = {Answer to "{{Why}} Is {{CBC}} with Predictable {{IV}} Considered Insecure against Chosen-Plaintext Attack?"},
  shorttitle = {Answer to "{{Why}} Is {{CBC}} with Predictable {{IV}} Considered Insecure against Chosen-Plaintext Attack?},
  author = {{bhass1}},
  date = {2017-02-28},
  url = {https://crypto.stackexchange.com/a/44275},
  urldate = {2024-06-17},
  organization = {Cryptography Stack Exchange},
  file = {/home/areo/Zotero/storage/MIXIXP3Z/why-is-cbc-with-predictable-iv-considered-insecure-against-chosen-plaintext-atta.html}
}

@article{biryukov2021argon2,
  title = {Argon2 Memory-Hard Function for Password Hashing and Proof-of-Work Applications},
  author = {Biryukov, Alex and Dinu, Daniel and Khovratovich, Dmitry and Josefsson, Simon},
  date = {2021},
  journaltitle = {Internet Research Task Force (IRTF), RFC},
  volume = {9106}
}

@article{biryukov2021argon2,
  title = {Argon2 Memory-Hard Function for Password Hashing and Proof-of-Work Applications},
  author = {Biryukov, Alex and Dinu, Daniel and Khovratovich, Dmitry and Josefsson, Simon},
  date = {2021},
  journaltitle = {Internet Research Task Force (IRTF), RFC},
  volume = {9106}
}

@article{biryukovArgon2MemoryhardFunction,
  title = {Argon2: The Memory-Hard Function for Password Hashing and Other Applications},
  author = {Biryukov, Alex and Dinu, Daniel and Khovratovich, Dmitry},
  langid = {english},
  file = {/home/areo/Zotero/storage/N52KEDLM/Biryukov et al. - Argon2 the memory-hard function for password hash.pdf}
}

@online{BitcoinHashrateChart,
  title = {Bitcoin {{Hashrate Chart}} - {{BTC Hashrate}} 639.22 {{EH}}/s},
  url = {https://www.coinwarz.com/mining/bitcoin/hashrate-chart},
  urldate = {2024-07-09},
  abstract = {The Bitcoin hashrate chart provides the current BTC hashrate as well as the history of Bitcoin hashrate in graph format with an option to expand the Bitcoin global hashrate chart time span back to 2009.},
  langid = {english},
  file = {/home/areo/Zotero/storage/PQZJPHCK/hashrate-chart.html}
}

@incollection{blackBlockCipherModeOperation2002,
  title = {A {{Block-Cipher Mode}} of {{Operation}} for {{Parallelizable Message Authentication}}},
  booktitle = {Advances in {{Cryptology}} — {{EUROCRYPT}} 2002},
  author = {Black, John and Rogaway, Phillip},
  editor = {Knudsen, Lars R.},
  editora = {Goos, Gerhard and Hartmanis, Juris and Van Leeuwen, Jan},
  editoratype = {redactor},
  date = {2002},
  volume = {2332},
  pages = {384--397},
  publisher = {Springer Berlin Heidelberg},
  location = {Berlin, Heidelberg},
  doi = {10.1007/3-540-46035-7_25},
  url = {http://link.springer.com/10.1007/3-540-46035-7_25},
  urldate = {2024-05-30},
  abstract = {We define and analyze a simple and fully parallelizable block-cipher mode of operation for message authentication. Parallelizability does not come at the expense of serial efficiency: in a conventional, serial environment, the algorithm’s speed is within a few percent of the (inherently sequential) CBC MAC. The new mode, PMAC, is deterministic, resembles a standard mode of operation (and not a Carter-Wegman MAC), works for strings of any bit length, employs a single block-cipher key, and uses just max\{1, |M |/n \} block-cipher calls to MAC a string M ∈ \{0, 1\}∗ using an n-bit block cipher. We prove PMAC secure, quantifying an adversary’s forgery probability in terms of the quality of the block cipher as a pseudorandom permutation.},
  isbn = {978-3-540-43553-2 978-3-540-46035-0},
  langid = {english},
  file = {/home/areo/Zotero/storage/NXGITVJP/Black and Rogaway - 2002 - A Block-Cipher Mode of Operation for Parallelizabl.pdf}
}

@online{blckknghtAnswerWhatPythonic2016,
  title = {Answer to "{{What}} Is a Pythonic Way of Slicing a Set?"},
  shorttitle = {Answer to "{{What}} Is a Pythonic Way of Slicing a Set?},
  author = {{Blckknght}},
  date = {2016-11-22},
  url = {https://stackoverflow.com/a/40737853},
  urldate = {2022-05-09},
  file = {/home/areo/Zotero/storage/K459UJ9Y/what-is-a-pythonic-way-of-slicing-a-set.html;/home/areo/Zotero/storage/VEW5WPRH/what-is-a-pythonic-way-of-slicing-a-set.html}
}

@inreference{BlockCipherMode2024,
  title = {Block Cipher Mode of Operation},
  booktitle = {Wikipedia},
  date = {2024-04-07T08:12:35Z},
  url = {https://en.wikipedia.org/w/index.php?title=Block_cipher_mode_of_operation&oldid=1217686350},
  urldate = {2024-05-22},
  abstract = {In cryptography, a block cipher mode of operation is an algorithm that uses a block cipher to provide information security such as confidentiality or authenticity. A block cipher by itself is only suitable for the secure cryptographic transformation (encryption or decryption) of one fixed-length group of bits called a block. A mode of operation describes how to repeatedly apply a cipher's single-block operation to securely transform amounts of data larger than a block. Most modes require a unique binary sequence, often called an initialization vector (IV), for each encryption operation. The IV must be non-repeating, and for some modes must also be random. The initialization vector is used to ensure that distinct ciphertexts are produced even when the same plaintext is encrypted multiple times independently with the same key. Block ciphers may be capable of operating on more than one block size, but during transformation the block size is always fixed. Block cipher modes operate on whole blocks and require that the final data fragment be padded to a full block if it is smaller than the current block size. There are, however, modes that do not require padding because they effectively use a block cipher as a stream cipher. Historically, encryption modes have been studied extensively in regard to their error propagation properties under various scenarios of data modification. Later development regarded integrity protection as an entirely separate cryptographic goal. Some modern modes of operation combine confidentiality and authenticity in an efficient way, and are known as authenticated encryption modes.},
  langid = {english},
  annotation = {Page Version ID: 1217686350},
  file = {/home/areo/Zotero/storage/TXVLV8UC/Block_cipher_mode_of_operation.html}
}

@inreference{BlockCipherMode2024a,
  title = {Block Cipher Mode of Operation},
  booktitle = {Wikipedia},
  date = {2024-04-07T08:12:35Z},
  url = {https://en.wikipedia.org/w/index.php?title=Block_cipher_mode_of_operation&oldid=1217686350},
  urldate = {2024-05-22},
  abstract = {In cryptography, a block cipher mode of operation is an algorithm that uses a block cipher to provide information security such as confidentiality or authenticity. A block cipher by itself is only suitable for the secure cryptographic transformation (encryption or decryption) of one fixed-length group of bits called a block. A mode of operation describes how to repeatedly apply a cipher's single-block operation to securely transform amounts of data larger than a block. Most modes require a unique binary sequence, often called an initialization vector (IV), for each encryption operation. The IV must be non-repeating, and for some modes must also be random. The initialization vector is used to ensure that distinct ciphertexts are produced even when the same plaintext is encrypted multiple times independently with the same key. Block ciphers may be capable of operating on more than one block size, but during transformation the block size is always fixed. Block cipher modes operate on whole blocks and require that the final data fragment be padded to a full block if it is smaller than the current block size. There are, however, modes that do not require padding because they effectively use a block cipher as a stream cipher. Historically, encryption modes have been studied extensively in regard to their error propagation properties under various scenarios of data modification. Later development regarded integrity protection as an entirely separate cryptographic goal. Some modern modes of operation combine confidentiality and authenticity in an efficient way, and are known as authenticated encryption modes.},
  langid = {english},
  annotation = {Page Version ID: 1217686350},
  file = {/home/areo/Zotero/storage/NQPJVXYB/Block_cipher_mode_of_operation.html}
}

@inreference{BlockCipherMode2024b,
  title = {Block Cipher Mode of Operation},
  booktitle = {Wikipedia},
  date = {2024-04-07T08:12:35Z},
  url = {https://en.wikipedia.org/w/index.php?title=Block_cipher_mode_of_operation&oldid=1217686350},
  urldate = {2024-05-22},
  abstract = {In cryptography, a block cipher mode of operation is an algorithm that uses a block cipher to provide information security such as confidentiality or authenticity. A block cipher by itself is only suitable for the secure cryptographic transformation (encryption or decryption) of one fixed-length group of bits called a block. A mode of operation describes how to repeatedly apply a cipher's single-block operation to securely transform amounts of data larger than a block. Most modes require a unique binary sequence, often called an initialization vector (IV), for each encryption operation. The IV must be non-repeating, and for some modes must also be random. The initialization vector is used to ensure that distinct ciphertexts are produced even when the same plaintext is encrypted multiple times independently with the same key. Block ciphers may be capable of operating on more than one block size, but during transformation the block size is always fixed. Block cipher modes operate on whole blocks and require that the final data fragment be padded to a full block if it is smaller than the current block size. There are, however, modes that do not require padding because they effectively use a block cipher as a stream cipher. Historically, encryption modes have been studied extensively in regard to their error propagation properties under various scenarios of data modification. Later development regarded integrity protection as an entirely separate cryptographic goal. Some modern modes of operation combine confidentiality and authenticity in an efficient way, and are known as authenticated encryption modes.},
  langid = {english},
  annotation = {Page Version ID: 1217686350},
  file = {/home/areo/Zotero/storage/GLQ8TJ6X/Block_cipher_mode_of_operation.html}
}

@inreference{BlockCipherMode2024c,
  title = {Block Cipher Mode of Operation},
  booktitle = {Wikipedia},
  date = {2024-04-07T08:12:35Z},
  url = {https://en.wikipedia.org/w/index.php?title=Block_cipher_mode_of_operation&oldid=1217686350},
  urldate = {2024-05-22},
  abstract = {In cryptography, a block cipher mode of operation is an algorithm that uses a block cipher to provide information security such as confidentiality or authenticity. A block cipher by itself is only suitable for the secure cryptographic transformation (encryption or decryption) of one fixed-length group of bits called a block. A mode of operation describes how to repeatedly apply a cipher's single-block operation to securely transform amounts of data larger than a block. Most modes require a unique binary sequence, often called an initialization vector (IV), for each encryption operation. The IV must be non-repeating, and for some modes must also be random. The initialization vector is used to ensure that distinct ciphertexts are produced even when the same plaintext is encrypted multiple times independently with the same key. Block ciphers may be capable of operating on more than one block size, but during transformation the block size is always fixed. Block cipher modes operate on whole blocks and require that the final data fragment be padded to a full block if it is smaller than the current block size. There are, however, modes that do not require padding because they effectively use a block cipher as a stream cipher. Historically, encryption modes have been studied extensively in regard to their error propagation properties under various scenarios of data modification. Later development regarded integrity protection as an entirely separate cryptographic goal. Some modern modes of operation combine confidentiality and authenticity in an efficient way, and are known as authenticated encryption modes.},
  langid = {english},
  annotation = {Page Version ID: 1217686350},
  file = {/home/areo/Zotero/storage/ZP22Q7GH/Block_cipher_mode_of_operation.html}
}

@inreference{BlockCipherMode2024d,
  title = {Block Cipher Mode of Operation},
  booktitle = {Wikipedia},
  date = {2024-04-07T08:12:35Z},
  url = {https://en.wikipedia.org/w/index.php?title=Block_cipher_mode_of_operation&oldid=1217686350},
  urldate = {2024-05-22},
  abstract = {In cryptography, a block cipher mode of operation is an algorithm that uses a block cipher to provide information security such as confidentiality or authenticity. A block cipher by itself is only suitable for the secure cryptographic transformation (encryption or decryption) of one fixed-length group of bits called a block. A mode of operation describes how to repeatedly apply a cipher's single-block operation to securely transform amounts of data larger than a block. Most modes require a unique binary sequence, often called an initialization vector (IV), for each encryption operation. The IV must be non-repeating, and for some modes must also be random. The initialization vector is used to ensure that distinct ciphertexts are produced even when the same plaintext is encrypted multiple times independently with the same key. Block ciphers may be capable of operating on more than one block size, but during transformation the block size is always fixed. Block cipher modes operate on whole blocks and require that the final data fragment be padded to a full block if it is smaller than the current block size. There are, however, modes that do not require padding because they effectively use a block cipher as a stream cipher. Historically, encryption modes have been studied extensively in regard to their error propagation properties under various scenarios of data modification. Later development regarded integrity protection as an entirely separate cryptographic goal. Some modern modes of operation combine confidentiality and authenticity in an efficient way, and are known as authenticated encryption modes.},
  langid = {english},
  annotation = {Page Version ID: 1217686350},
  file = {/home/areo/Zotero/storage/3AJJTNUF/Block_cipher_mode_of_operation.html}
}

@inreference{BlockCipherMode2024e,
  title = {Block Cipher Mode of Operation},
  booktitle = {Wikipedia},
  date = {2024-04-07T08:12:35Z},
  url = {https://en.wikipedia.org/w/index.php?title=Block_cipher_mode_of_operation&oldid=1217686350},
  urldate = {2024-05-22},
  abstract = {In cryptography, a block cipher mode of operation is an algorithm that uses a block cipher to provide information security such as confidentiality or authenticity. A block cipher by itself is only suitable for the secure cryptographic transformation (encryption or decryption) of one fixed-length group of bits called a block. A mode of operation describes how to repeatedly apply a cipher's single-block operation to securely transform amounts of data larger than a block. Most modes require a unique binary sequence, often called an initialization vector (IV), for each encryption operation. The IV must be non-repeating, and for some modes must also be random. The initialization vector is used to ensure that distinct ciphertexts are produced even when the same plaintext is encrypted multiple times independently with the same key. Block ciphers may be capable of operating on more than one block size, but during transformation the block size is always fixed. Block cipher modes operate on whole blocks and require that the final data fragment be padded to a full block if it is smaller than the current block size. There are, however, modes that do not require padding because they effectively use a block cipher as a stream cipher. Historically, encryption modes have been studied extensively in regard to their error propagation properties under various scenarios of data modification. Later development regarded integrity protection as an entirely separate cryptographic goal. Some modern modes of operation combine confidentiality and authenticity in an efficient way, and are known as authenticated encryption modes.},
  langid = {english},
  annotation = {Page Version ID: 1217686350},
  file = {/home/areo/Zotero/storage/GSW8KACN/Block_cipher_mode_of_operation.html}
}

@inreference{BlockCipherMode2024f,
  title = {Block Cipher Mode of Operation},
  booktitle = {Wikipedia},
  date = {2024-04-07T08:12:35Z},
  url = {https://en.wikipedia.org/w/index.php?title=Block_cipher_mode_of_operation&oldid=1217686350},
  urldate = {2024-05-22},
  abstract = {In cryptography, a block cipher mode of operation is an algorithm that uses a block cipher to provide information security such as confidentiality or authenticity. A block cipher by itself is only suitable for the secure cryptographic transformation (encryption or decryption) of one fixed-length group of bits called a block. A mode of operation describes how to repeatedly apply a cipher's single-block operation to securely transform amounts of data larger than a block. Most modes require a unique binary sequence, often called an initialization vector (IV), for each encryption operation. The IV must be non-repeating, and for some modes must also be random. The initialization vector is used to ensure that distinct ciphertexts are produced even when the same plaintext is encrypted multiple times independently with the same key. Block ciphers may be capable of operating on more than one block size, but during transformation the block size is always fixed. Block cipher modes operate on whole blocks and require that the final data fragment be padded to a full block if it is smaller than the current block size. There are, however, modes that do not require padding because they effectively use a block cipher as a stream cipher. Historically, encryption modes have been studied extensively in regard to their error propagation properties under various scenarios of data modification. Later development regarded integrity protection as an entirely separate cryptographic goal. Some modern modes of operation combine confidentiality and authenticity in an efficient way, and are known as authenticated encryption modes.},
  langid = {english},
  annotation = {Page Version ID: 1217686350},
  file = {/home/areo/Zotero/storage/ECD4X3YD/Block_cipher_mode_of_operation.html}
}

@inreference{BlockCipherMode2024g,
  title = {Block Cipher Mode of Operation},
  booktitle = {Wikipedia},
  date = {2024-04-07T08:12:35Z},
  url = {https://en.wikipedia.org/w/index.php?title=Block_cipher_mode_of_operation&oldid=1217686350},
  urldate = {2024-05-22},
  abstract = {In cryptography, a block cipher mode of operation is an algorithm that uses a block cipher to provide information security such as confidentiality or authenticity. A block cipher by itself is only suitable for the secure cryptographic transformation (encryption or decryption) of one fixed-length group of bits called a block. A mode of operation describes how to repeatedly apply a cipher's single-block operation to securely transform amounts of data larger than a block. Most modes require a unique binary sequence, often called an initialization vector (IV), for each encryption operation. The IV must be non-repeating, and for some modes must also be random. The initialization vector is used to ensure that distinct ciphertexts are produced even when the same plaintext is encrypted multiple times independently with the same key. Block ciphers may be capable of operating on more than one block size, but during transformation the block size is always fixed. Block cipher modes operate on whole blocks and require that the final data fragment be padded to a full block if it is smaller than the current block size. There are, however, modes that do not require padding because they effectively use a block cipher as a stream cipher. Historically, encryption modes have been studied extensively in regard to their error propagation properties under various scenarios of data modification. Later development regarded integrity protection as an entirely separate cryptographic goal. Some modern modes of operation combine confidentiality and authenticity in an efficient way, and are known as authenticated encryption modes.},
  langid = {english},
  annotation = {Page Version ID: 1217686350},
  file = {/home/areo/Zotero/storage/LM46M2EV/Block_cipher_mode_of_operation.html}
}

@inreference{BlockCipherMode2024h,
  title = {Block Cipher Mode of Operation},
  booktitle = {Wikipedia},
  date = {2024-04-07T08:12:35Z},
  url = {https://en.wikipedia.org/w/index.php?title=Block_cipher_mode_of_operation&oldid=1217686350},
  urldate = {2024-05-22},
  abstract = {In cryptography, a block cipher mode of operation is an algorithm that uses a block cipher to provide information security such as confidentiality or authenticity. A block cipher by itself is only suitable for the secure cryptographic transformation (encryption or decryption) of one fixed-length group of bits called a block. A mode of operation describes how to repeatedly apply a cipher's single-block operation to securely transform amounts of data larger than a block. Most modes require a unique binary sequence, often called an initialization vector (IV), for each encryption operation. The IV must be non-repeating, and for some modes must also be random. The initialization vector is used to ensure that distinct ciphertexts are produced even when the same plaintext is encrypted multiple times independently with the same key. Block ciphers may be capable of operating on more than one block size, but during transformation the block size is always fixed. Block cipher modes operate on whole blocks and require that the final data fragment be padded to a full block if it is smaller than the current block size. There are, however, modes that do not require padding because they effectively use a block cipher as a stream cipher. Historically, encryption modes have been studied extensively in regard to their error propagation properties under various scenarios of data modification. Later development regarded integrity protection as an entirely separate cryptographic goal. Some modern modes of operation combine confidentiality and authenticity in an efficient way, and are known as authenticated encryption modes.},
  langid = {english},
  annotation = {Page Version ID: 1217686350},
  file = {/home/areo/Zotero/storage/KICGDLZI/Block_cipher_mode_of_operation.html}
}

@inreference{BlockCipherMode2024i,
  title = {Block Cipher Mode of Operation},
  booktitle = {Wikipedia},
  date = {2024-04-07T08:12:35Z},
  url = {https://en.wikipedia.org/w/index.php?title=Block_cipher_mode_of_operation&oldid=1217686350},
  urldate = {2024-05-22},
  abstract = {In cryptography, a block cipher mode of operation is an algorithm that uses a block cipher to provide information security such as confidentiality or authenticity. A block cipher by itself is only suitable for the secure cryptographic transformation (encryption or decryption) of one fixed-length group of bits called a block. A mode of operation describes how to repeatedly apply a cipher's single-block operation to securely transform amounts of data larger than a block. Most modes require a unique binary sequence, often called an initialization vector (IV), for each encryption operation. The IV must be non-repeating, and for some modes must also be random. The initialization vector is used to ensure that distinct ciphertexts are produced even when the same plaintext is encrypted multiple times independently with the same key. Block ciphers may be capable of operating on more than one block size, but during transformation the block size is always fixed. Block cipher modes operate on whole blocks and require that the final data fragment be padded to a full block if it is smaller than the current block size. There are, however, modes that do not require padding because they effectively use a block cipher as a stream cipher. Historically, encryption modes have been studied extensively in regard to their error propagation properties under various scenarios of data modification. Later development regarded integrity protection as an entirely separate cryptographic goal. Some modern modes of operation combine confidentiality and authenticity in an efficient way, and are known as authenticated encryption modes.},
  langid = {english},
  annotation = {Page Version ID: 1217686350},
  file = {/home/areo/Zotero/storage/I6CFVH9K/Block_cipher_mode_of_operation.html}
}

@inreference{BlockCipherMode2024j,
  title = {Block Cipher Mode of Operation},
  booktitle = {Wikipedia},
  date = {2024-04-07T08:12:35Z},
  url = {https://en.wikipedia.org/w/index.php?title=Block_cipher_mode_of_operation&oldid=1217686350},
  urldate = {2024-05-22},
  abstract = {In cryptography, a block cipher mode of operation is an algorithm that uses a block cipher to provide information security such as confidentiality or authenticity. A block cipher by itself is only suitable for the secure cryptographic transformation (encryption or decryption) of one fixed-length group of bits called a block. A mode of operation describes how to repeatedly apply a cipher's single-block operation to securely transform amounts of data larger than a block. Most modes require a unique binary sequence, often called an initialization vector (IV), for each encryption operation. The IV must be non-repeating, and for some modes must also be random. The initialization vector is used to ensure that distinct ciphertexts are produced even when the same plaintext is encrypted multiple times independently with the same key. Block ciphers may be capable of operating on more than one block size, but during transformation the block size is always fixed. Block cipher modes operate on whole blocks and require that the final data fragment be padded to a full block if it is smaller than the current block size. There are, however, modes that do not require padding because they effectively use a block cipher as a stream cipher. Historically, encryption modes have been studied extensively in regard to their error propagation properties under various scenarios of data modification. Later development regarded integrity protection as an entirely separate cryptographic goal. Some modern modes of operation combine confidentiality and authenticity in an efficient way, and are known as authenticated encryption modes.},
  langid = {english},
  annotation = {Page Version ID: 1217686350},
  file = {/home/areo/Zotero/storage/9RUC7XZI/Block_cipher_mode_of_operation.html}
}

@inreference{BlockCipherMode2024k,
  title = {Block Cipher Mode of Operation},
  booktitle = {Wikipedia},
  date = {2024-04-07T08:12:35Z},
  url = {https://en.wikipedia.org/w/index.php?title=Block_cipher_mode_of_operation&oldid=1217686350},
  urldate = {2024-05-22},
  abstract = {In cryptography, a block cipher mode of operation is an algorithm that uses a block cipher to provide information security such as confidentiality or authenticity. A block cipher by itself is only suitable for the secure cryptographic transformation (encryption or decryption) of one fixed-length group of bits called a block. A mode of operation describes how to repeatedly apply a cipher's single-block operation to securely transform amounts of data larger than a block. Most modes require a unique binary sequence, often called an initialization vector (IV), for each encryption operation. The IV must be non-repeating, and for some modes must also be random. The initialization vector is used to ensure that distinct ciphertexts are produced even when the same plaintext is encrypted multiple times independently with the same key. Block ciphers may be capable of operating on more than one block size, but during transformation the block size is always fixed. Block cipher modes operate on whole blocks and require that the final data fragment be padded to a full block if it is smaller than the current block size. There are, however, modes that do not require padding because they effectively use a block cipher as a stream cipher. Historically, encryption modes have been studied extensively in regard to their error propagation properties under various scenarios of data modification. Later development regarded integrity protection as an entirely separate cryptographic goal. Some modern modes of operation combine confidentiality and authenticity in an efficient way, and are known as authenticated encryption modes.},
  langid = {english},
  annotation = {Page Version ID: 1217686350},
  file = {/home/areo/Zotero/storage/WQMHQBP6/Block_cipher_mode_of_operation.html}
}

@inreference{BlockCipherMode2024l,
  title = {Block Cipher Mode of Operation},
  booktitle = {Wikipedia},
  date = {2024-04-07T08:12:35Z},
  url = {https://en.wikipedia.org/w/index.php?title=Block_cipher_mode_of_operation&oldid=1217686350},
  urldate = {2024-05-22},
  abstract = {In cryptography, a block cipher mode of operation is an algorithm that uses a block cipher to provide information security such as confidentiality or authenticity. A block cipher by itself is only suitable for the secure cryptographic transformation (encryption or decryption) of one fixed-length group of bits called a block. A mode of operation describes how to repeatedly apply a cipher's single-block operation to securely transform amounts of data larger than a block. Most modes require a unique binary sequence, often called an initialization vector (IV), for each encryption operation. The IV must be non-repeating, and for some modes must also be random. The initialization vector is used to ensure that distinct ciphertexts are produced even when the same plaintext is encrypted multiple times independently with the same key. Block ciphers may be capable of operating on more than one block size, but during transformation the block size is always fixed. Block cipher modes operate on whole blocks and require that the final data fragment be padded to a full block if it is smaller than the current block size. There are, however, modes that do not require padding because they effectively use a block cipher as a stream cipher. Historically, encryption modes have been studied extensively in regard to their error propagation properties under various scenarios of data modification. Later development regarded integrity protection as an entirely separate cryptographic goal. Some modern modes of operation combine confidentiality and authenticity in an efficient way, and are known as authenticated encryption modes.},
  langid = {english},
  annotation = {Page Version ID: 1217686350},
  file = {/home/areo/Zotero/storage/GQW67E7Q/Block_cipher_mode_of_operation.html}
}

@inreference{BlockCipherMode2024m,
  title = {Six Common Block Cipher Modes of Operation for Encrypting},
  booktitle = {Wikipedia},
  date = {2024-04-07T08:12:35Z},
  url = {https://en.wikipedia.org/w/index.php?title=Block_cipher_mode_of_operation&oldid=1217686350},
  urldate = {2024-05-22},
  abstract = {In cryptography, a block cipher mode of operation is an algorithm that uses a block cipher to provide information security such as confidentiality or authenticity. A block cipher by itself is only suitable for the secure cryptographic transformation (encryption or decryption) of one fixed-length group of bits called a block. A mode of operation describes how to repeatedly apply a cipher's single-block operation to securely transform amounts of data larger than a block. Most modes require a unique binary sequence, often called an initialization vector (IV), for each encryption operation. The IV must be non-repeating, and for some modes must also be random. The initialization vector is used to ensure that distinct ciphertexts are produced even when the same plaintext is encrypted multiple times independently with the same key. Block ciphers may be capable of operating on more than one block size, but during transformation the block size is always fixed. Block cipher modes operate on whole blocks and require that the final data fragment be padded to a full block if it is smaller than the current block size. There are, however, modes that do not require padding because they effectively use a block cipher as a stream cipher. Historically, encryption modes have been studied extensively in regard to their error propagation properties under various scenarios of data modification. Later development regarded integrity protection as an entirely separate cryptographic goal. Some modern modes of operation combine confidentiality and authenticity in an efficient way, and are known as authenticated encryption modes.},
  langid = {english},
  annotation = {Page Version ID: 1217686350},
  file = {/home/areo/Zotero/storage/STRL2Q6D/Block_cipher_mode_of_operation.html}
}

@inproceedings{bolingbrokeTypesAreCalling2009,
  title = {Types Are Calling Conventions},
  booktitle = {Proceedings of the 2nd {{ACM SIGPLAN}} Symposium on {{Haskell}} - {{Haskell}} '09},
  author = {Bolingbroke, Maximilian C. and Peyton Jones, Simon L.},
  date = {2009},
  pages = {1},
  publisher = {ACM Press},
  location = {Edinburgh, Scotland},
  doi = {10.1145/1596638.1596640},
  url = {http://portal.acm.org/citation.cfm?doid=1596638.1596640},
  urldate = {2022-07-23},
  abstract = {It is common for compilers to derive the calling convention of a function from its type. Doing so is simple and modular but misses many optimisation opportunities, particularly in lazy, higher-order functional languages with extensive use of currying. We restore the lost opportunities by defining Strict Core, a new intermediate language whose type system makes the missing distinctions: laziness is explicit, and functions take multiple arguments and return multiple results.},
  eventtitle = {The 2nd {{ACM SIGPLAN}} Symposium},
  isbn = {978-1-60558-508-6},
  langid = {english},
  file = {/home/areo/Zotero/storage/ZUHHKDZ5/Bolingbroke and Peyton Jones - 2009 - Types are calling conventions.pdf}
}

@inproceedings{boneh2016balloon,
  title = {Balloon Hashing: {{A}} Memory-Hard Function Providing Provable Protection against Sequential Attacks},
  booktitle = {Advances in Cryptology–{{ASIACRYPT}} 2016: 22nd International Conference on the Theory and Application of Cryptology and Information Security, Hanoi, Vietnam, December 4-8, 2016, Proceedings, Part {{I}} 22},
  author = {Boneh, Dan and Corrigan-Gibbs, Henry and Schechter, Stuart},
  date = {2016},
  pages = {220--248},
  publisher = {Springer}
}

@online{bonehBalloonHashingMemoryHard2016,
  title = {Balloon {{Hashing}}: {{A Memory-Hard Function Providing Provable Protection Against Sequential Attacks}}},
  shorttitle = {Balloon {{Hashing}}},
  author = {Boneh, Dan and Corrigan-Gibbs, Henry and Schechter, Stuart},
  date = {2016},
  number = {2016/027},
  url = {https://eprint.iacr.org/2016/027},
  urldate = {2024-07-10},
  abstract = {We present the Balloon password-hashing algorithm. This is the first practical cryptographic hash function that: (i) has proven memory-hardness properties in the random-oracle model, (ii) uses a password-independent access pattern, and (iii) meets or exceeds the performance of the best heuristically secure password-hashing algorithms. Memory-hard functions require a large amount of working space to evaluate efficiently and when used for password hashing, they dramatically increase the cost of offline dictionary attacks. In this work, we leverage a previously unstudied property of a certain class of graphs (“random sandwich graphs”) to analyze the memory-hardness of the Balloon algorithm. The techniques we develop are general: we also use them to give a proof of security of the scrypt and Argon2i password-hashing functions in the random-oracle model. Our security analysis uses a sequential model of computation, which essentially captures attacks that run on single-core machines. Recent work shows how to use massively parallel special-purpose machines (e.g., with hundreds of cores) to attack Balloon and other memory-hard functions. We discuss these important attacks, which are outside of our adversary model, and propose practical defenses against them. To motivate the need for security proofs in the area of password hashing, we demonstrate and implement a practical attack against Argon2i that successfully evaluates the function with less space than was previously claimed possible. Finally, we use experimental results to compare the performance of the Balloon hashing algorithm to other memory-hard functions.},
  pubstate = {prepublished},
  keywords = {Argon2,memory-hard functions,password hashing,pebbling arguments,sandwich graph,scrypt,time-space trade-offs},
  annotation = {Publication info: A major revision of an IACR publication in ASIACRYPT 2016},
  file = {/home/areo/Zotero/storage/FTHAM883/Boneh et al. - 2016 - Balloon Hashing A Memory-Hard Function Providing .pdf}
}

@inreference{BootstrappingCompilers2022,
  title = {Bootstrapping (Compilers)},
  booktitle = {Wikipedia},
  date = {2022-08-30T09:30:34Z},
  url = {https://en.wikipedia.org/w/index.php?title=Bootstrapping_(compilers)&oldid=1107502446},
  urldate = {2022-09-13},
  abstract = {In computer science, bootstrapping is the technique for producing a self-compiling compiler – that is, a compiler (or assembler) written in the source programming language that it intends to compile. An initial core version of the compiler (the bootstrap compiler) is generated in a different language (which could be assembly language); successive expanded versions of the compiler are developed using this minimal subset of the language. The problem of compiling a self-compiling compiler has been called the chicken-or-egg problem in compiler design, and bootstrapping is a solution to this problem.Many compilers for many programming languages are bootstrapped, including compilers for BASIC, ALGOL, C, C\#, D, Pascal, PL/I, Haskell, Modula-2, Oberon, OCaml, Common Lisp, Scheme, Go, Java, Elixir, Rust, Python, Scala, Nim, Eiffel, TypeScript, Vala, Zig and more.},
  langid = {english},
  annotation = {Page Version ID: 1107502446},
  file = {/home/areo/Zotero/storage/53AATE5Y/Bootstrapping_(compilers).html}
}

@online{borgeltAnswerInvertingPermutations2020,
  title = {Answer to "{{Inverting}} Permutations in {{Python}}"},
  author = {Borgelt, Christian},
  date = {2020-07-03},
  url = {https://stackoverflow.com/a/62715531},
  urldate = {2023-11-07},
  organization = {Stack Overflow},
  file = {/home/areo/Zotero/storage/MWSKGUA9/inverting-permutations-in-python.html}
}

@inreference{BritishAmericanKeyboards2023,
  title = {British and {{American}} Keyboards},
  booktitle = {Wikipedia},
  date = {2023-05-26T22:21:36Z},
  url = {https://en.wikipedia.org/w/index.php?title=British_and_American_keyboards&oldid=1157184290},
  urldate = {2023-10-23},
  abstract = {There are two major English language computer keyboard layouts, the United States layout and the United Kingdom layout defined in BS 4822 (48-key version). Both are QWERTY layouts. Users in the United States do not frequently need to make use of the £ (pound) and € (euro) currency symbols, which are common needs in the United Kingdom and Ireland, although the \$ (dollar sign) symbol is also provided as standard on UK and Irish keyboards. In other countries which predominantly use English as a common working language, such as Australia, Canada (in English-speaking parts), and New Zealand, the US keyboard is commonly used.},
  langid = {english},
  annotation = {Page Version ID: 1157184290},
  file = {/home/areo/Zotero/storage/Z24MEKYI/British_and_American_keyboards.html}
}

@online{CallingTextMateOther,
  title = {Calling {{TextMate}} from {{Other Applications}} — {{TextMate}} 1.x {{Manual}}},
  url = {https://macromates.com/manual/en/using_textmate_from_terminal#url_scheme_html},
  urldate = {2023-11-05},
  file = {/home/areo/Zotero/storage/P7GTBBD4/using_textmate_from_terminal.html}
}

@online{chazelasAnswerDifferenceHelp2014,
  title = {Answer to "{{Difference}} between Help, Info and Man Command"},
  author = {Chazelas, Stéphane},
  date = {2014-10-07},
  url = {https://unix.stackexchange.com/a/159817},
  urldate = {2023-11-14},
  organization = {Unix \& Linux Stack Exchange},
  file = {/home/areo/Zotero/storage/YHKP7ITD/difference-between-help-info-and-man-command.html}
}

@inreference{ChomskyHierarchie2022,
  title = {Chomsky-Hierarchie},
  booktitle = {Wikipedia},
  date = {2022-09-05T14:15:13Z},
  url = {https://de.wikipedia.org/w/index.php?title=Chomsky-Hierarchie&oldid=225920254},
  urldate = {2022-09-13},
  abstract = {Chomsky-Hierarchie, gelegentlich Chomsky-Schützenberger-Hierarchie (benannt nach dem Linguisten Noam Chomsky und dem Mathematiker Marcel Schützenberger), ist ein Begriff aus der Theoretischen Informatik. Sie ist eine Hierarchie von Klassen formaler Grammatiken, die formale Sprachen erzeugen, und wurde 1956 erstmals von Noam Chomsky beschrieben. Die Hierarchiestufen unterscheiden sich darin, wie rigide die Einschränkungen für die Form zulässiger Produktionsregeln auf der jeweiligen Stufe sind; bei Typ-0-Grammatiken sind sie uneingeschränkt, bei höheren Stufen fortschreitend stärker beschränkt. Grammatiken niedrigeren Typs sind erzeugungsmächtiger als die höherer Typen. Eine Sprache, die von einer Grammatik des Typs k erzeugt wird, heißt eine Sprache des Typs k. Neben die Chomsky-Hierarchie der Grammatiken tritt in diesem Sinne eine Chomsky-Hierarchie der Sprachen.},
  langid = {ngerman},
  annotation = {Page Version ID: 225920254},
  file = {/home/areo/Zotero/storage/5W6ZQVF6/Chomsky-Hierarchie.html}
}

@software{chubinChubinCheatSh2023,
  title = {Chubin/Cheat.Sh},
  author = {Chubin, Igor},
  date = {2023-11-14T10:40:42Z},
  origdate = {2017-05-07T21:40:56Z},
  url = {https://github.com/chubin/cheat.sh},
  urldate = {2023-11-14},
  abstract = {the only cheat sheet you need},
  keywords = {cheatsheet,cli,command-line,curl,documentation,examples,hacktoberfest2021,help,terminal,tldr}
}

@online{ClangCompiler,
  title = {Clang: {{C}}++ {{Compiler}}},
  url = {http://clang.org/},
  urldate = {2022-07-29}
}

@online{ClockwiseSpiralRule,
  title = {Clockwise/{{Spiral Rule}}},
  url = {https://c-faq.com/decl/spiral.anderson.html},
  urldate = {2022-07-29}
}

@online{Cmd2IndexRst2022,
  title = {Cmd2/Index.Rst at Bef3c758829fe2aa82d58699d61fa78aa961f29d · Python-Cmd2/Cmd2},
  date = {2022-01-28},
  url = {https://github.com/python-cmd2/cmd2},
  urldate = {2022-01-28},
  abstract = {cmd2 - quickly build feature-rich and user-friendly interactive command line applications in Python - cmd2/index.rst at bef3c758829fe2aa82d58699d61fa78aa961f29d · python-cmd2/cmd2}
}

@inreference{Compiler2022,
  title = {Compiler},
  booktitle = {Wikipedia},
  date = {2022-08-22T13:26:56Z},
  url = {https://de.wikipedia.org/w/index.php?title=Compiler&oldid=225542576},
  urldate = {2022-09-13},
  abstract = {Ein Compiler (auch Kompilierer; von englisch compile ‚zusammentragen‘ bzw. lateinisch compilare ‚aufhäufen‘) ist ein Computerprogramm, das Quellcodes einer bestimmten Programmiersprache in eine Form übersetzt, die von einem Computer (direkter) ausgeführt werden kann. Daraus entsteht ein mehr oder weniger direkt ausführbares Programm. Davon zu unterscheiden sind Interpreter, etwa für frühe Versionen von BASIC, die keinen Maschinencode erzeugen. Teils wird zwischen den Begriffen Übersetzer und Compiler unterschieden. Ein Übersetzer übersetzt ein Programm aus einer formalen Quellsprache in ein semantisches Äquivalent in einer formalen Zielsprache. Compiler sind spezielle Übersetzer, die Programmcode aus problemorientierten Programmiersprachen, sogenannten Hochsprachen, in ausführbaren Maschinencode einer bestimmten Architektur oder einen Zwischencode (Bytecode, p-Code oder .NET-Code) überführen. Diese Trennung zwischen den Begriffen Übersetzer und Compiler wird nicht in allen Fällen vorgenommen. Der Vorgang der Übersetzung wird auch als Kompilierung oder Umwandlung (bzw. mit dem entsprechenden Verb) bezeichnet. Das Gegenteil, also die Rückübersetzung von Maschinensprache in Quelltext einer bestimmten Programmiersprache, wird Dekompilierung und entsprechende Programme Decompiler genannt.},
  langid = {ngerman},
  annotation = {Page Version ID: 225542576},
  file = {/home/areo/Zotero/storage/KPR8E2SG/Compiler.html}
}

@online{CompilerDesignPhases,
  title = {Compiler {{Design}} - {{Phases}} of {{Compiler}}},
  url = {https://www.tutorialspoint.com/compiler_design/compiler_design_phases_of_compiler.htm},
  urldate = {2022-06-19}
}

@online{ComputationalCapacityFastest,
  title = {Computational Capacity of the Fastest Supercomputers},
  url = {https://ourworldindata.org/grapher/supercomputer-power-flops},
  urldate = {2024-05-23},
  abstract = {The number of floating-point operations carried out per second by the fastest supercomputer in any given year. This is expressed in gigaFLOPS, equivalent to 10⁹ floating-point operations per second.},
  organization = {Our World in Data},
  file = {/home/areo/Zotero/storage/VYAMZPZU/supercomputer-power-flops.html}
}

@inreference{ControlFlowAnalysis2022,
  title = {Control Flow Analysis},
  booktitle = {Wikipedia},
  date = {2022-02-05T15:55:55Z},
  url = {https://en.wikipedia.org/w/index.php?title=Control_flow_analysis&oldid=1070083426},
  urldate = {2022-09-13},
  abstract = {In computer science, control-flow analysis (CFA) is a static-code-analysis technique for determining the control flow of a program. The control flow is expressed as a control-flow graph (CFG). For both functional programming languages and object-oriented programming languages, the term CFA, and elaborations such as k-CFA, refer to specific algorithms that compute control flow.For many imperative programming languages, the control flow of a program is explicit in a program's source code.  As a result, interprocedural control-flow analysis implicitly usually refers to a static analysis technique for determining the receiver(s) of function or method calls in computer programs written in a higher-order programming language. For example, in a programming language with higher-order functions like Scheme, the target of a function call may not be explicit: in the isolated expression it is unclear to which procedure f may refer.  A control-flow analysis must consider where this expression could be invoked and what argument it may receive to determine the possible targets. Techniques such as abstract interpretation, constraint solving, and type systems may be used for control-flow analysis.},
  langid = {english},
  annotation = {Page Version ID: 1070083426},
  file = {/home/areo/Zotero/storage/PCLUJIQK/Control_flow_analysis.html}
}

@inreference{CrossCompiler2022,
  title = {Cross Compiler},
  booktitle = {Wikipedia},
  date = {2022-06-26T21:29:28Z},
  url = {https://en.wikipedia.org/w/index.php?title=Cross_compiler&oldid=1095178458},
  urldate = {2022-09-13},
  abstract = {A cross compiler is a compiler capable of creating executable code for a platform other than the one on which the compiler is running.  For example, a compiler that runs on a PC but generates code that runs on an Android smartphone is a cross compiler. A cross compiler is useful to compile code for multiple platforms from one development host. Direct compilation on the target platform might be infeasible, for example on embedded systems with limited computing resources. Cross compilers are distinct from source-to-source compilers. A cross compiler is for cross-platform software generation of machine code, while a source-to-source compiler translates from one coding language to another in text code. Both are programming tools.},
  langid = {english},
  annotation = {Page Version ID: 1095178458},
  file = {/home/areo/Zotero/storage/ET4VYYY2/Cross_compiler.html}
}

@misc{cryptoeprint:2011/541,
  title = {Minimalism in Cryptography: {{The}} Even-Mansour Scheme Revisited},
  author = {Dunkelman, Orr and Keller, Nathan and Shamir, Adi},
  date = {2011},
  url = {https://eprint.iacr.org/2011/541},
  howpublished = {Cryptology ePrint Archive, Paper 2011/541}
}

@incollection{daemenLimitationsEvenMansourConstruction1993,
  title = {Limitations of the {{Even-Mansour}} Construction},
  booktitle = {Advances in {{Cryptology}} — {{ASIACRYPT}} '91},
  author = {Daemen, Joan},
  editor = {Imai, Hideki and Rivest, Ronald L. and Matsumoto, Tsutomu},
  editora = {Goos, G. and Hartmanis, J.},
  editoratype = {redactor},
  date = {1993},
  volume = {739},
  pages = {495--498},
  publisher = {Springer Berlin Heidelberg},
  location = {Berlin, Heidelberg},
  doi = {10.1007/3-540-57332-1_46},
  url = {http://link.springer.com/10.1007/3-540-57332-1_46},
  urldate = {2024-06-16},
  abstract = {In [1] a construction of a block cipher from a single pseudorandom permutation is proposed. In a complexity theoretical setting they prove that this scheme is secure against a polynomially bounded adversary. In this paper it is shown that this construction suffers from severe limitations that are immediately apparent if differential cryptanalysis [3] is performed. The fact that these limitations do not contradict the theoretical results obtained in [1] leads the authors to question the relevance of computational complexity theory in practical conventional cryptography.},
  isbn = {978-3-540-57332-6 978-3-540-48066-2},
  langid = {english},
  file = {/home/areo/Zotero/storage/KPLTGAUZ/Daemen - 1993 - Limitations of the Even-Mansour construction.pdf}
}

@online{Debugger2022,
  title = {Debugger},
  date = {2022-05-31},
  url = {https://www.techopedia.com/definition/597/debugger},
  urldate = {2024-02-20},
  abstract = {This definition explains the meaning of Debugger and why it matters.},
  langid = {american},
  organization = {Techopedia},
  file = {/home/areo/Zotero/storage/Q2GCBSEE/debugger.html}
}

@inreference{DeklarationProgrammierung2022,
  title = {Deklaration (Programmierung)},
  booktitle = {Wikipedia},
  date = {2022-07-05T06:58:39Z},
  url = {https://de.wikipedia.org/w/index.php?title=Deklaration_(Programmierung)&oldid=224245160},
  urldate = {2022-09-13},
  abstract = {In der Informatik und Programmierung ist eine Deklaration die Festlegung von Dimension, Bezeichner, Datentyp und weiteren Aspekten einer Variable oder eines Unterprogramms. Durch die Deklaration wird dem Übersetzer (Compiler oder Interpreter) diese Variable bzw. dieses Unterprogramm bekannt gemacht; es ist damit möglich, diese an anderen Stellen im selben Quelltext zu verwenden. Häufig werden die Ausdrücke Deklaration und Definition mit der allgemeinen Bedeutung „Daten/Datenstrukturen/Datentypen festlegen/beschreiben“ als Synonyme verwendet. Beispiele siehe „eigene Datentypen definieren“ in, „definierte Variable“ in oder „definieren einer Klasse“ in Klasse. Programmiersprachenabhängig werden diese Begriffe jedoch zum Teil auch unterschiedlich verwendet. So werden zum Beispiel in Haskell per Deklaration auch Funktionen spezifiziert, in den Programmiersprachen C++ und C wird dies ‚Definition‘ genannt. ‚Definition‘ wird dabei als Sonderfall der Deklaration verstanden. Bei Variablen spricht man von Definition, wenn der Übersetzer Code erzeugt, der entweder statisch (im Datensegment) oder dynamisch (zur Laufzeit) Speicherplatz für diese Variable reserviert. Bei Unterprogrammen spricht man von Definition, wenn an dieser Stelle der Quelltext des Unterprogramms angegeben ist. Die Deklaration eines Unterprogramms ohne Definition wird auch oft als Prototyp bezeichnet. Bei der Referenzierung einer deklarierten (nicht definierten) Variable bzw. Unterprogrammes überprüft der Linker, dass die Variable bzw. das Unterprogramm an anderer Stelle definiert wurde und verknüpft die Referenzen mit der Definition. Erst nach der Deklaration kann einer Variablen ein Ausdruck zugewiesen werden. Neben der expliziten Deklaration gibt es in einigen Programmiersprachen (z. B. Fortran, BASIC, PL/I) aber auch die Möglichkeit einer impliziten Deklaration von Variablen: In diesem Fall führt das erste Auftreten einer Variablen zu einer automatischen Typzuordnung.},
  langid = {ngerman},
  annotation = {Page Version ID: 224245160},
  file = {/home/areo/Zotero/storage/PDNGE5SM/Deklaration_(Programmierung).html}
}

@online{DesktopEntriesArchWiki,
  title = {Desktop Entries - {{ArchWiki}}},
  url = {https://wiki.archlinux.org/title/desktop_entries},
  urldate = {2023-11-05},
  file = {/home/areo/Zotero/storage/AUM3KFTQ/desktop_entries.html}
}

@online{DesktopEntrySpecification,
  title = {Desktop {{Entry Specification}}},
  url = {https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#recognized-keys},
  urldate = {2023-11-05}
}

@online{developersDrawFreelyInkscape,
  title = {Draw {{Freely}} | {{Inkscape}}},
  author = {Developers, Inkscape Website},
  url = {https://inkscape.org/},
  urldate = {2022-08-03},
  abstract = {Inkscape is professional quality vector graphics software which runs on Linux, Mac OS X and Windows desktop computers.},
  langid = {english},
  file = {/home/areo/Zotero/storage/7WYZ7LL2/inkscape.org.html}
}

@online{DevelopNeovimPlugin2023,
  title = {Develop a {{Neovim}} Plugin in {{Lua}} | {{Max Shen Dev}}},
  date = {2023-09-15},
  url = {https://m4xshen.dev/posts/develop-a-neovim-plugin-in-lua/},
  urldate = {2024-01-11},
  abstract = {Learn how to develop a Neovim plugin in Lua. Understand the structure of Neovim plugin, Lua module, and create a simple plugin.},
  langid = {english},
  file = {/home/areo/Zotero/storage/FGMRLPGX/develop-a-neovim-plugin-in-lua.html}
}

@article{dijkstraLettersEditorGo1968,
  title = {Letters to the Editor: Go to Statement Considered Harmful},
  shorttitle = {Letters to the Editor},
  author = {Dijkstra, Edsger W.},
  date = {1968-03},
  journaltitle = {Communications of the ACM},
  shortjournal = {Commun. ACM},
  volume = {11},
  number = {3},
  pages = {147--148},
  issn = {0001-0782, 1557-7317},
  doi = {10.1145/362929.362947},
  url = {https://dl.acm.org/doi/10.1145/362929.362947},
  urldate = {2024-01-30},
  langid = {english}
}

@inreference{DisjunktiveNormalform2023,
  title = {Disjunktive Normalform},
  booktitle = {Wikipedia},
  date = {2023-02-08T14:08:34Z},
  url = {https://de.wikipedia.org/w/index.php?title=Disjunktive_Normalform&oldid=230680696},
  urldate = {2023-04-27},
  abstract = {Als disjunktive Normalform (kurz DNF) wird in der Booleschen Algebra eine in besonderer Weise normierte Funktionsdarstellung Boolescher Funktionen bezeichnet.},
  langid = {ngerman},
  annotation = {Page Version ID: 230680696},
  file = {/home/areo/Zotero/storage/SXQLX3QN/Disjunktive_Normalform.html}
}

@online{DownloadWhiteBackground,
  title = {Download {{White}} Background with Orange Geometric for Free},
  url = {https://www.vecteezy.com/vector-art/11171111-white-background-with-orange-geometric},
  urldate = {2023-04-25},
  abstract = {Download the White background with orange geometric 11171111 royalty-free Vector from Vecteezy for your project and explore over a million other vectors, icons and clipart graphics!},
  langid = {english},
  organization = {Vecteezy},
  file = {/home/areo/Zotero/storage/4UXYW48J/11171111-white-background-with-orange-geometric.html}
}

@software{drewOthneildrewBestREADMETemplate2022,
  title = {Othneildrew/{{Best-README-Template}}},
  author = {Drew, Othneil},
  date = {2022-01-28},
  url = {https://github.com/othneildrew/Best-README-Template},
  urldate = {2022-01-28},
  abstract = {An awesome README template to jumpstart your projects!},
  keywords = {readme,readme-template}
}

@online{DudenPatchRechtschreibung,
  title = {Duden | Patch | Rechtschreibung, Bedeutung, Definition, Herkunft},
  url = {https://www.duden.de/rechtschreibung/Patch_Software_Programm},
  urldate = {2022-07-23},
  abstract = {Definition, Rechtschreibung, Synonyme und Grammatik von 'Patch' auf Duden online nachschlagen. Wörterbuch der deutschen Sprache.},
  langid = {ngerman},
  file = {/home/areo/Zotero/storage/QERL6R42/Patch_Software_Programm.html}
}

@online{dunkelmanMinimalismCryptographyEvenMansour2011,
  title = {Minimalism in {{Cryptography}}: {{The Even-Mansour Scheme Revisited}}},
  shorttitle = {Minimalism in {{Cryptography}}},
  author = {Dunkelman, Orr and Keller, Nathan and Shamir, Adi},
  date = {2011},
  number = {2011/541},
  url = {https://eprint.iacr.org/2011/541},
  urldate = {2024-06-16},
  abstract = {In this paper we consider the following fundamental problem: What is the simplest possible construction of a block cipher which is provably secure in some formal sense? This problem motivated Even and Mansour to develop their scheme in 1991, but its exact security remained open for more than 20 years in the sense that the lower bound proof considered known plaintexts, whereas the best published attack (which was based on differential cryptanalysis) required chosen plaintexts. In this paper we solve this long standing open problem by describing the new Slidex attack which matches the T = \textbackslash Omega(2\textasciicircum n/D) lower bound on the time T for any number of known plaintexts D. Once we obtain this tight bound, we can show that the original two-key Even-Mansour scheme is not minimal in the sense that it can be simplified into a single key scheme with half as many key bits which provides exactly the same security, and which can be argued to be the simplest conceivable provably secure block cipher. We then show that there can be no comparable lower bound on the memory requirements of such attacks, by developing a new memoryless attack which can be applied with the same time complexity but only in the special case of D=2\textasciicircum\{n/2\}. In the last part of the paper we analyze the security of several other variants of the Even-Mansour scheme, showing that some of them provide the same level of security while in others the lower bound proof fails for very delicate reasons.},
  pubstate = {prepublished},
  keywords = {Even-Mansour block cipher,minimalism,mirror slide attack.,provable security,slide attacks,slidex attack,whitening keys},
  annotation = {Publication info: Published elsewhere. Unknown where it was published},
  file = {/home/areo/Zotero/storage/F3U87YRF/Dunkelman et al. - 2011 - Minimalism in Cryptography The Even-Mansour Schem.pdf}
}

@online{dunkelmanMinimalismCryptographyEvenMansour2011a,
  title = {Minimalism in {{Cryptography}}: {{The Even-Mansour Scheme Revisited}}},
  shorttitle = {Minimalism in {{Cryptography}}},
  author = {Dunkelman, Orr and Keller, Nathan and Shamir, Adi},
  date = {2011},
  number = {2011/541},
  url = {https://eprint.iacr.org/2011/541},
  urldate = {2024-06-16},
  abstract = {In this paper we consider the following fundamental problem: What is the simplest possible construction of a block cipher which is provably secure in some formal sense? This problem motivated Even and Mansour to develop their scheme in 1991, but its exact security remained open for more than 20 years in the sense that the lower bound proof considered known plaintexts, whereas the best published attack (which was based on differential cryptanalysis) required chosen plaintexts. In this paper we solve this long standing open problem by describing the new Slidex attack which matches the T = \textbackslash Omega(2\textasciicircum n/D) lower bound on the time T for any number of known plaintexts D. Once we obtain this tight bound, we can show that the original two-key Even-Mansour scheme is not minimal in the sense that it can be simplified into a single key scheme with half as many key bits which provides exactly the same security, and which can be argued to be the simplest conceivable provably secure block cipher. We then show that there can be no comparable lower bound on the memory requirements of such attacks, by developing a new memoryless attack which can be applied with the same time complexity but only in the special case of D=2\textasciicircum\{n/2\}. In the last part of the paper we analyze the security of several other variants of the Even-Mansour scheme, showing that some of them provide the same level of security while in others the lower bound proof fails for very delicate reasons.},
  pubstate = {prepublished},
  keywords = {Even-Mansour block cipher,minimalism,mirror slide attack.,provable security,slide attacks,slidex attack,whitening keys},
  annotation = {Publication info: Published elsewhere. Unknown where it was published},
  file = {/home/areo/Zotero/storage/ZFX52ZVJ/Dunkelman et al. - 2011 - Minimalism in Cryptography The Even-Mansour Schem.pdf}
}

@online{dunkelmanMinimalismCryptographyEvenMansour2011b,
  title = {Minimalism in {{Cryptography}}: {{The Even-Mansour Scheme Revisited}}},
  shorttitle = {Minimalism in {{Cryptography}}},
  author = {Dunkelman, Orr and Keller, Nathan and Shamir, Adi},
  date = {2011},
  number = {2011/541},
  url = {https://eprint.iacr.org/2011/541},
  urldate = {2024-06-16},
  abstract = {In this paper we consider the following fundamental problem: What is the simplest possible construction of a block cipher which is provably secure in some formal sense? This problem motivated Even and Mansour to develop their scheme in 1991, but its exact security remained open for more than 20 years in the sense that the lower bound proof considered known plaintexts, whereas the best published attack (which was based on differential cryptanalysis) required chosen plaintexts. In this paper we solve this long standing open problem by describing the new Slidex attack which matches the T = \textbackslash Omega(2\textasciicircum n/D) lower bound on the time T for any number of known plaintexts D. Once we obtain this tight bound, we can show that the original two-key Even-Mansour scheme is not minimal in the sense that it can be simplified into a single key scheme with half as many key bits which provides exactly the same security, and which can be argued to be the simplest conceivable provably secure block cipher. We then show that there can be no comparable lower bound on the memory requirements of such attacks, by developing a new memoryless attack which can be applied with the same time complexity but only in the special case of D=2\textasciicircum\{n/2\}. In the last part of the paper we analyze the security of several other variants of the Even-Mansour scheme, showing that some of them provide the same level of security while in others the lower bound proof fails for very delicate reasons.},
  pubstate = {prepublished},
  keywords = {Even-Mansour block cipher,minimalism,mirror slide attack.,provable security,slide attacks,slidex attack,whitening keys},
  annotation = {Publication info: Published elsewhere. Unknown where it was published},
  file = {/home/areo/Zotero/storage/LU4G9KE4/Dunkelman et al. - 2011 - Minimalism in Cryptography The Even-Mansour Schem.pdf}
}

@article{earleyEfiicientContextfreeParsing1968,
  title = {An Efiicient Context-Free Parsing},
  author = {Earley, Jay},
  date = {1968},
  journaltitle = {Commun.ACM},
  volume = {13},
  url = {https://web.archive.org/web/20040708052627/http://www-2.cs.cmu.edu/afs/cs.cmu.edu/project/cmt-55/lti/Courses/711/Class-notes/p94-earley.pdf},
  urldate = {2022-08-10},
  file = {/home/areo/Zotero/storage/T44BWJJP/2004 - Wayback Machine.pdf}
}

@article{earleyFormalismTranslatorInteractions1970,
  title = {A Formalism for Translator Interactions},
  author = {Earley, J. and Sturgis, Howard E.},
  date = {1970},
  journaltitle = {CACM},
  doi = {10.1145/355598.362740},
  abstract = {A formalism is presented for describing the actions of processors for programming languages—compilers, interpreters, assemblers—and their interactions in complex systems such as compiler-compilers or extendible languages. The formalism here might be used to define and answer such a question as “Can one do bootstrapping using a metacompiler whose metaphase is interpretive?” In addition an algorithm is presented for deciding whether or not a given system can be produced from a given set of component processors.}
}

@online{EarleyParser,
  title = {Earley {{Parser}}},
  url = {https://rahul.gopinath.org/post/2021/02/06/earley-parsing/},
  urldate = {2022-06-20}
}

@inreference{EarleyParser2022,
  title = {Earley Parser},
  booktitle = {Wikipedia},
  date = {2022-05-31T18:52:44Z},
  url = {https://en.wikipedia.org/w/index.php?title=Earley_parser&oldid=1090848932},
  urldate = {2022-08-15},
  abstract = {In computer science, the Earley parser is an algorithm for parsing strings that belong to a given context-free language, though (depending on the variant) it may suffer problems with certain nullable grammars. The algorithm, named after its inventor, Jay Earley, is a chart parser that uses dynamic programming; it is mainly used for parsing in computational linguistics. It was first introduced in his dissertation in 1968 (and later appeared in an abbreviated, more legible, form in a journal). Earley parsers are appealing because they can parse all context-free languages, unlike LR parsers and LL parsers, which are more typically used in compilers but which can only handle restricted classes of languages.  The Earley parser executes in cubic time in the general case                                    O                  (                    n                        3                             )                 \{\textbackslash displaystyle \{O\}(n\textasciicircum\{3\})\}   , where n is the length of the parsed string, quadratic time for unambiguous grammars                                    O                  (                    n                        2                             )                 \{\textbackslash displaystyle \{O\}(n\textasciicircum\{2\})\}   , and linear time for all deterministic context-free grammars. It performs particularly well when the rules are written left-recursively.},
  langid = {english},
  annotation = {Page Version ID: 1090848932}
}

@inreference{EarleyParser2022a,
  title = {Earley Parser},
  booktitle = {Wikipedia},
  date = {2022-05-31T18:52:44Z},
  url = {https://en.wikipedia.org/w/index.php?title=Earley_parser&oldid=1090848932},
  urldate = {2022-09-13},
  abstract = {In computer science, the Earley parser is an algorithm for parsing strings that belong to a given context-free language, though (depending on the variant) it may suffer problems with certain nullable grammars. The algorithm, named after its inventor, Jay Earley, is a chart parser that uses dynamic programming; it is mainly used for parsing in computational linguistics. It was first introduced in his dissertation in 1968 (and later appeared in an abbreviated, more legible, form in a journal). Earley parsers are appealing because they can parse all context-free languages, unlike LR parsers and LL parsers, which are more typically used in compilers but which can only handle restricted classes of languages.  The Earley parser executes in cubic time in the general case                                    O                  (                    n                        3                             )                 \{\textbackslash displaystyle \{O\}(n\textasciicircum\{3\})\}   , where n is the length of the parsed string, quadratic time for unambiguous grammars                                    O                  (                    n                        2                             )                 \{\textbackslash displaystyle \{O\}(n\textasciicircum\{2\})\}   , and linear time for all deterministic context-free grammars. It performs particularly well when the rules are written left-recursively.},
  langid = {english},
  annotation = {Page Version ID: 1090848932},
  file = {/home/areo/Zotero/storage/CQL5E3PS/Earley_parser.html}
}

@online{EarleyParsera,
  title = {Earley {{Parser}}},
  url = {https://rahul.gopinath.org/post/2021/02/06/earley-parsing/},
  urldate = {2022-08-10},
  file = {/home/areo/Zotero/storage/5HYW2WGJ/earley-parsing.html}
}

@online{ebermannAnswerWhyMixColumns2011,
  title = {Answer to "{{Why}} Is {{MixColumns}} Omitted from the Last Round of {{AES}}?"},
  shorttitle = {Answer to "{{Why}} Is {{MixColumns}} Omitted from the Last Round of {{AES}}?},
  author = {Ebermann, Paŭlo},
  date = {2011-11-29},
  url = {https://crypto.stackexchange.com/a/1362},
  urldate = {2023-11-03},
  organization = {Cryptography Stack Exchange},
  file = {/home/areo/Zotero/storage/8EYAZRD3/why-is-mixcolumns-omitted-from-the-last-round-of-aes.html}
}

@online{eliasAnswerDifferenceTweak2017,
  title = {Answer to "{{Difference}} between {{Tweak}} and Nonce"},
  author = {Elias},
  date = {2017-06-21},
  url = {https://crypto.stackexchange.com/a/48518},
  urldate = {2024-06-14},
  organization = {Cryptography Stack Exchange},
  file = {/home/areo/Zotero/storage/LI4UFBU7/difference-between-tweak-and-nonce.html}
}

@inreference{EntartungInformatik2021,
  title = {Entartung (Informatik)},
  booktitle = {Wikipedia},
  date = {2021-09-11T14:39:03Z},
  url = {https://de.wikipedia.org/w/index.php?title=Entartung_(Informatik)&oldid=215501841},
  urldate = {2022-09-13},
  abstract = {Eine Datenstruktur wird als entartet bezeichnet, wenn sie final einen Zustand angenommen hat, in der sie anders als vor der Entartung nachteilig wirkt. Dies kann aufgrund ungünstiger Eingabedaten geschehen.},
  langid = {ngerman},
  annotation = {Page Version ID: 215501841},
  file = {/home/areo/Zotero/storage/UBJKYCPZ/Entartung_(Informatik).html}
}

@artwork{epachamoEnglishDiagramShowing2024,
  title = {English:  {{Diagram}} Showing Six Common Cipher Modes of Operation},
  shorttitle = {English},
  author = {{Epachamo}},
  date = {2024-04-05},
  url = {https://commons.wikimedia.org/wiki/File:BlockcipherModesofOperation.png},
  urldate = {2024-05-22},
  file = {/home/areo/Zotero/storage/RBM5TMAI/FileBlockcipherModesofOperation.html}
}

@online{ErrorsGeeksforGeeks,
  title = {Errors in {{C}}/{{C}}++ - {{GeeksforGeeks}}},
  url = {https://www.geeksforgeeks.org/errors-in-cc/},
  urldate = {2022-05-10}
}

@inreference{EvaluationStrategy2022,
  title = {Evaluation Strategy},
  booktitle = {Wikipedia},
  date = {2022-09-12T23:01:04Z},
  url = {https://en.wikipedia.org/w/index.php?title=Evaluation_strategy&oldid=1109984435},
  urldate = {2022-09-13},
  abstract = {In a programming language, an evaluation strategy is a set of rules for evaluating expressions. The term is often used to refer to the more specific notion of a parameter-passing strategy that defines the kind of value that is passed to the function for each parameter (the binding strategy) and whether to evaluate the parameters of a function call, and if so in what order (the evaluation order). The notion of reduction strategy is distinct, although some authors conflate the two terms and the definition of each term is not widely agreed upon.To illustrate, executing a function call f(a,b) may first evaluate the arguments a and b, store the results in references or memory locations ref\_a and ref\_b, then evaluate the function's body with those references passed in. This gives the function the ability to look up the argument values, to modify them via assignment as if they were local variables, and to return values via the references. This is the call-by-reference evaluation strategy.Evaluation strategy is specified by the programming language definition, and is not a function of any specific implementation. The calling convention defines implementation-specific parameter passing details.},
  langid = {english},
  annotation = {Page Version ID: 1109984435}
}

@article{evenConstructionCipherSingle1997,
  title = {A Construction of a Cipher from a Single Pseudorandom Permutation},
  author = {Even, Shimon and Mansour, Yishay},
  date = {1997-06-01},
  journaltitle = {Journal of Cryptology},
  shortjournal = {J. Cryptology},
  volume = {10},
  number = {3},
  pages = {151--161},
  issn = {1432-1378},
  doi = {10.1007/s001459900025},
  url = {https://doi.org/10.1007/s001459900025},
  urldate = {2024-06-25},
  abstract = {We suggest a scheme for a block cipher which uses only one randomly chosen permutation,F. The key, consisting of two blocks,K1 andK2, is used in the following way. The message block is XORed withK1 before applyingF, and the outcome is XORed withK2, to produce the cryptogram block. We show that the resulting cipher is secure (when the permutation is random or pseudorandom). This removes the need to store, or generate a multitude of permutations.},
  langid = {english},
  keywords = {Block cypher,DES,Pseudorandomness},
  file = {/home/areo/Zotero/storage/QCL767EK/Even and Mansour - 1997 - A construction of a cipher from a single pseudoran.pdf}
}

@online{evilAnswerWhyWe2014,
  title = {Answer to "{{Why}} Do We Use {{XTS}} over {{CTR}} for Disk Encryption?"},
  shorttitle = {Answer to "{{Why}} Do We Use {{XTS}} over {{CTR}} for Disk Encryption?},
  author = {family=evil', given=Gilles 'SO-stop, prefix=being, useprefix=false},
  date = {2014-02-21},
  url = {https://crypto.stackexchange.com/a/14630},
  urldate = {2024-06-04},
  organization = {Cryptography Stack Exchange}
}

@online{evilAnswerWhyWe2014a,
  title = {Answer to "{{Why}} Do We Use {{XTS}} over {{CTR}} for Disk Encryption?"},
  shorttitle = {Answer to "{{Why}} Do We Use {{XTS}} over {{CTR}} for Disk Encryption?},
  author = {family=evil', given=Gilles 'SO-stop, prefix=being, useprefix=false},
  date = {2014-02-21},
  url = {https://crypto.stackexchange.com/a/14630},
  urldate = {2024-06-13},
  organization = {Cryptography Stack Exchange},
  file = {/home/areo/Zotero/storage/IWY5M2EV/why-do-we-use-xts-over-ctr-for-disk-encryption.html}
}

@online{evilAnswerWhyWe2014b,
  title = {Answer to "{{Why}} Do We Use {{XTS}} over {{CTR}} for Disk Encryption?"},
  shorttitle = {Answer to "{{Why}} Do We Use {{XTS}} over {{CTR}} for Disk Encryption?},
  author = {family=evil', given=Gilles 'SO-stop, prefix=being, useprefix=false},
  date = {2014-02-21},
  url = {https://crypto.stackexchange.com/a/14630},
  urldate = {2024-06-16},
  organization = {Cryptography Stack Exchange},
  file = {/home/areo/Zotero/storage/GQY3UK7M/why-do-we-use-xts-over-ctr-for-disk-encryption.html}
}

@inreference{ExtendedBackusNaur2022,
  title = {Extended {{Backus}}–{{Naur}} Form},
  booktitle = {Wikipedia},
  date = {2022-06-17T13:55:45Z},
  url = {https://en.wikipedia.org/w/index.php?title=Extended_Backus%E2%80%93Naur_form&oldid=1093574831},
  urldate = {2022-07-31},
  abstract = {In computer science, extended Backus–Naur form (EBNF) is a family of metasyntax notations, any of which can be used to express a context-free grammar.  EBNF is used to make a formal description of a formal language such as a computer programming language. They are extensions of the basic Backus–Naur form (BNF) metasyntax notation. The earliest EBNF was developed by Niklaus Wirth incorporating some of the concepts (with a different syntax and notation) from Wirth syntax notation. However, many variants of EBNF are in use. The International Organization for Standardization adopted an EBNF standard (ISO/IEC 14977) in 1996. However, according to Zaytsev this standard "only ended up adding yet another three dialects to the chaos" and, after noting its lack of success, also notes that the ISO EBNF is not even used in all ISO standards. Wheeler argues against using the ISO standard when using an EBNF, and recommends considering alternative EBNF notations such as the one from the W3C Extensible Markup Language (XML) 1.0 (Fifth Edition). This article uses EBNF as specified by the ISO for examples applying to all EBNFs. Other EBNF variants use somewhat different syntactic conventions.},
  langid = {english},
  annotation = {Page Version ID: 1093574831},
  file = {/home/areo/Zotero/storage/HB4NQHVX/Extended_Backus–Naur_form.html}
}

@online{FAQPyinstallerPyinstaller2022,
  title = {{{FAQ}} · Pyinstaller/Pyinstaller {{Wiki}}},
  date = {2022-01-28},
  url = {https://github.com/pyinstaller/pyinstaller},
  urldate = {2022-01-28},
  abstract = {Freeze (package) Python programs into stand-alone executables - FAQ · pyinstaller/pyinstaller Wiki}
}

@online{FigCipherClassifications,
  title = {Fig. 2. {{The}} Cipher Classifications.},
  url = {https://www.researchgate.net/figure/The-cipher-classifications_fig2_366174830},
  urldate = {2023-11-03},
  abstract = {Download scientific diagram | The cipher classifications. from publication: Modern and Lightweight Component-based Symmetric Cipher Algorithms: A Review | Information security, being one of the corner stones of network and communication technology, has been evolving tremendously to cope with the parallel evolution of network security threats. Hence, cipher algorithms in the core of the information security process have more... | Modernism, Cryptography Algorithms and Security | ResearchGate, the professional network for scientists.},
  langid = {english},
  organization = {ResearchGate},
  file = {/home/areo/Zotero/storage/VHX7RJST/The-cipher-classifications_fig2_366174830.html}
}

@online{FileCBCDecryption2013,
  title = {File:{{CBC}} Decryption.Svg - {{Wikipedia}}},
  shorttitle = {File},
  date = {2013-06-01},
  url = {https://commons.wikimedia.org/wiki/File:CBC_decryption.svg},
  urldate = {2024-05-22},
  langid = {english}
}

@online{FileCBCEncryption2013,
  title = {File:{{CBC}} Encryption.Svg - {{Wikipedia}}},
  shorttitle = {File},
  date = {2013-06-01},
  url = {https://commons.wikimedia.org/wiki/File:CBC_encryption.svg},
  urldate = {2024-05-22},
  langid = {english}
}

@online{FileCFBDecryption2013,
  title = {File:{{CFB}} Decryption.Svg - {{Wikipedia}}},
  shorttitle = {File},
  date = {2013-06-01},
  url = {https://commons.wikimedia.org/wiki/File:CFB_decryption.svg},
  urldate = {2024-05-22},
  langid = {english}
}

@online{FileCFBEncryption2013,
  title = {File:{{CFB}} Encryption.Svg - {{Wikipedia}}},
  shorttitle = {File},
  date = {2013-06-01},
  url = {https://commons.wikimedia.org/wiki/File:CFB_encryption.svg},
  urldate = {2024-05-22},
  langid = {english}
}

@online{FileCTRDecryption2013,
  title = {File:{{CTR}} Decryption 2.Svg - {{Wikipedia}}},
  shorttitle = {File},
  date = {2013-06-01},
  url = {https://commons.wikimedia.org/wiki/File:CTR_decryption_2.svg},
  urldate = {2024-05-22},
  langid = {english}
}

@online{FileCTREncryption2013,
  title = {File:{{CTR}} Encryption 2.Svg - {{Wikipedia}}},
  shorttitle = {File},
  date = {2013-06-01},
  url = {https://commons.wikimedia.org/wiki/File:CTR_encryption_2.svg},
  urldate = {2024-05-22},
  langid = {english}
}

@online{FileHandshakeIcon2020,
  title = {File:{{Handshake}} Icon Black Circle.Svg - {{Wikipedia}}},
  shorttitle = {File},
  date = {2020-05-21},
  url = {https://commons.wikimedia.org/wiki/File:Handshake_icon_black_circle.svg},
  urldate = {2023-04-27},
  langid = {english},
  file = {/home/areo/Zotero/storage/WTU6IBT3/FileHandshake_icon_black_circle.html}
}

@inreference{FileHmacSvg2020,
  title = {File:{{Hmac}}.Svg},
  shorttitle = {File},
  booktitle = {Wikipedia},
  date = {2020-09-27T22:28:25Z},
  url = {https://en.wikipedia.org/w/index.php?title=File:Hmac.svg&oldid=980693262},
  urldate = {2024-05-27},
  langid = {english},
  annotation = {Page Version ID: 980693262},
  file = {/home/areo/Zotero/storage/4LQ2G54W/FileHmac.html}
}

@online{FileOFBDecryption2013,
  title = {File:{{OFB}} Decryption.Svg - {{Wikipedia}}},
  shorttitle = {File},
  date = {2013-06-01},
  url = {https://commons.wikimedia.org/wiki/File:OFB_decryption.svg},
  urldate = {2024-05-22},
  langid = {english}
}

@online{FileOFBEncryption2013,
  title = {File:{{OFB}} Encryption.Svg - {{Wikipedia}}},
  shorttitle = {File},
  date = {2013-06-01},
  url = {https://commons.wikimedia.org/wiki/File:OFB_encryption.svg},
  urldate = {2024-05-22},
  langid = {english}
}

@online{FilePCBCDecryption2013,
  title = {File:{{PCBC}} Decryption.Svg - {{Wikipedia}}},
  shorttitle = {File},
  date = {2013-06-01},
  url = {https://commons.wikimedia.org/wiki/File:PCBC_decryption.svg},
  urldate = {2024-05-22},
  langid = {english}
}

@online{FilePCBCEncryption2013,
  title = {File:{{PCBC}} Encryption.Svg - {{Wikipedia}}},
  shorttitle = {File},
  date = {2013-06-01},
  url = {https://commons.wikimedia.org/wiki/File:PCBC_encryption.svg},
  urldate = {2024-05-22},
  langid = {english}
}

@online{FileTuxECB2022,
  title = {File:{{Tux ECB}}.Png - {{Wikipedia}}},
  shorttitle = {File},
  date = {2022-11-17},
  url = {https://commons.wikimedia.org/wiki/File:Tux_ECB.png},
  urldate = {2024-05-22},
  langid = {english},
  file = {/home/areo/Zotero/storage/M3YB46C9/FileTux_ECB.html}
}

@online{FileTuxSecure2022,
  title = {File:{{Tux}} Secure.Png - {{Wikipedia}}},
  shorttitle = {File},
  date = {2022-11-17},
  url = {https://commons.wikimedia.org/wiki/File:Tux_secure.png},
  urldate = {2024-05-22},
  langid = {english},
  file = {/home/areo/Zotero/storage/586ZL89S/FileTux_secure.html}
}

@online{FileTuxSvg,
  title = {File:{{Tux}}.Svg - {{Wikipedia}}},
  shorttitle = {File},
  url = {https://commons.wikimedia.org/wiki/File:Tux.svg},
  urldate = {2024-05-22},
  langid = {english},
  file = {/home/areo/Zotero/storage/62AKBFBV/FileTux.html}
}

@online{FreePhotoTicket,
  title = {Free {{Photo}} | {{Ticket}} Barriers at Subway Entrance},
  url = {https://www.freepik.com/free-photo/ticket-barriers-subway-entrance_1120720.htm},
  urldate = {2023-11-06},
  abstract = {Download this Free Photo about Ticket barriers at subway entrance, and discover more than 1 Million Professional Stock Photos on Freepik. \#freepik \#photo \#securitygate \#metrostation \#subway},
  langid = {english},
  organization = {Freepik},
  file = {/home/areo/Zotero/storage/85PB728E/ticket-barriers-subway-entrance_1120720.html}
}

@online{frseGivingCybersecurityTweak2024,
  title = {Giving {{Cybersecurity}} a {{Tweak}}: {{XTS}}},
  shorttitle = {Giving {{Cybersecurity}} a {{Tweak}}},
  author = {FRSE, Prof Bill Buchanan OBE},
  date = {2024-02-25T07:37:29},
  url = {https://medium.com/asecuritysite-when-bob-met-alice/giving-cybersecurity-a-tweak-xts-f93c7ce32776},
  urldate = {2024-06-15},
  abstract = {I worry about cybersecurity sometimes. My worry is that there can be knowledge gaps that can be likened to a bridge building not knowing…},
  langid = {english},
  organization = {ASecuritySite: When Bob Met Alice},
  file = {/home/areo/Zotero/storage/U7QB7D4E/giving-cybersecurity-a-tweak-xts-f93c7ce32776.html}
}

@online{frseGivingCybersecurityTweak2024a,
  title = {Giving {{Cybersecurity}} a {{Tweak}}: {{XTS}}},
  shorttitle = {Giving {{Cybersecurity}} a {{Tweak}}},
  author = {FRSE, Prof Bill Buchanan OBE},
  date = {2024-02-25T07:37:29},
  url = {https://medium.com/asecuritysite-when-bob-met-alice/giving-cybersecurity-a-tweak-xts-f93c7ce32776},
  urldate = {2024-06-15},
  abstract = {I worry about cybersecurity sometimes. My worry is that there can be knowledge gaps that can be likened to a bridge building not knowing…},
  langid = {english},
  organization = {ASecuritySite: When Bob Met Alice},
  file = {/home/areo/Zotero/storage/9BF99979/giving-cybersecurity-a-tweak-xts-f93c7ce32776.html}
}

@report{fruhwirth2005new,
  title = {New Methods in Hard Disk Encryption},
  author = {Fruhwirth, Clemens},
  date = {2005},
  institution = {Vienna University of Technology},
  location = {Institute for Computer Languages, Theory and Logic Group}
}

@inproceedings{fruhwirthNewMethodsHard2005,
  title = {New {{Methods}} in {{Hard Disk Encryption}}},
  author = {Fruhwirth, Clemens},
  date = {2005},
  url = {https://www.semanticscholar.org/paper/New-Methods-in-Hard-Disk-Encryption-Fruhwirth/7e0d8dffdf7354e224fb807cdcb8aa2d698bc891},
  urldate = {2024-05-16},
  abstract = {This work investigates the state of the art in hard disk cryptography. As the choice of the cipher mode is essential for the security of hard disk data, we discuss the recent cipher mode developments at two standardisation bodies, NIST and IEEE. It is a necessity to consider new developments, as the most common cipher mode – namely CBC – has many security problems. This work devotes a chapter to the analysis of CBC weaknesses. Next to others, the main contributions of this work are (1) efficient algorithms for series of multiplications in a finite field (Galois Field), (2) analysis of the security of password-based cryptography with respect to low entropy attacks and (3) a design template for secure key management, namely TKS1. For the latter, it is assumed that key management has to be done on regular user hardware in the absence of any special security hardware like key tokens. We solve the problems arising from magnetic storage by introducing a method called anti-forensic information splitter. This work is complemented by the presentation of a system implementing a variant of TKS1. It is called LUKS and it was developed and implemented by the author of this work.},
  file = {/home/areo/Zotero/storage/7WRRF3RL/Fruhwirth - 2005 - New Methods in Hard Disk Encryption.pdf}
}

@inreference{Funktionsprototyp2020,
  title = {Funktionsprototyp},
  booktitle = {Wikipedia},
  date = {2020-01-22T18:19:47Z},
  url = {https://de.wikipedia.org/w/index.php?title=Funktionsprototyp&oldid=196075270},
  urldate = {2022-09-13},
  abstract = {Als Funktionsprototyp oder Funktionskopf bezeichnet man in verschiedenen Programmiersprachen (vor allem C und C++) die Deklaration einer Funktion – inklusive Angaben über Anzahl und Typ der Parameter und Typ des Rückgabewertes – getrennt von ihrer Implementierung (Definition). Man spricht auch ungenau von der Vorausdeklaration (englisch: forward declaration, oft falsch als „Vorwärtsdeklaration“ übersetzt) einer Funktion, diese muss aber nicht in jedem Fall einen vollwertigen Funktionsprototypen darstellen. Beispiel: int funktion(); wäre in C eine gültige Vorausdeklaration, aber kein Prototyp, da keinerlei Angaben über Funktionsparameter gemacht werden. Jede Definition einer Funktion liefert hingegen automatisch immer auch eine Prototypdeklaration für nachfolgenden Programmcode.},
  langid = {ngerman},
  annotation = {Page Version ID: 196075270},
  file = {/home/areo/Zotero/storage/JDMCGWPC/Funktionsprototyp.html}
}

@book{g.siekEssentialsCompilation2022,
  title = {Essentials of {{Compilation}}},
  author = {G. Siek, Jeremy},
  date = {2022-01-28},
  url = {https://iucompilercourse.github.io/IU-Fall-2021/},
  urldate = {2022-01-28}
}

@online{GCCGNUCompiler,
  title = {{{GCC}}, the {{GNU Compiler Collection}} - {{GNU Project}}},
  url = {https://gcc.gnu.org/},
  urldate = {2022-07-13}
}

@online{GDBGNUProject,
  title = {{{GDB}}: {{The GNU Project Debugger}}},
  url = {https://www.sourceware.org/gdb/},
  urldate = {2022-07-13}
}

@artwork{gdrooidEnglishDiagramSHA1HMAC2014,
  title = {English:  {{Diagram}} of {{SHA1-HMAC}} Generation.},
  shorttitle = {English},
  author = {{Gdrooid}},
  year = {2 August 2014, 19:51:38},
  url = {https://commons.wikimedia.org/wiki/File:SHAhmac.svg},
  urldate = {2024-05-27},
  file = {/home/areo/Zotero/storage/97T9FLNQ/FileSHAhmac.html}
}

@online{giteHowUseSed2017,
  title = {How to Use Sed to Find and Replace Text in Files in {{Linux}} / {{Unix}} Shell},
  author = {Gite, Vivek},
  date = {2017-05-24T11:05:51+00:00},
  url = {https://www.cyberciti.biz/faq/how-to-use-sed-to-find-and-replace-text-in-files-in-linux-unix-shell/},
  urldate = {2023-11-21},
  abstract = {sed find and replace text command: This guide explains how to use sed to find and replace text within a file on a Linux, macOS, *BSD and Unix},
  langid = {american},
  organization = {nixCraft},
  file = {/home/areo/Zotero/storage/AUVFGTB7/how-to-use-sed-to-find-and-replace-text-in-files-in-linux-unix-shell.html}
}

@online{GitHubMarpteamMarpcli2022,
  title = {{{GitHub}} - Marp-Team/Marp-Cli: {{A CLI}} Interface for {{Marp}} and {{Marpit}} Based Converters},
  date = {2022-01-28},
  url = {https://github.com/marp-team/marp-cli},
  urldate = {2022-01-28}
}

@online{GrammarLanguageLanguages,
  title = {Grammar: {{The}} Language of Languages ({{BNF}}, {{EBNF}}, {{ABNF}} and More)},
  url = {https://matt.might.net/articles/grammars-bnf-ebnf/},
  urldate = {2022-07-30}
}

@online{GrammarReferenceLark,
  title = {Grammar {{Reference}} — {{Lark}} Documentation},
  url = {https://lark-parser.readthedocs.io/en/latest/grammar.html},
  urldate = {2022-07-31}
}

@online{GrammarReferenceLarka,
  title = {Grammar {{Reference}} — {{Lark}} Documentation},
  url = {https://lark-parser.readthedocs.io/en/latest/grammar.html},
  urldate = {2022-09-13},
  file = {/home/areo/Zotero/storage/TZ8WEC4E/grammar.html}
}

@inreference{GraphColoring2022,
  title = {Graph Coloring},
  booktitle = {Wikipedia},
  date = {2022-09-13T13:50:58Z},
  url = {https://en.wikipedia.org/w/index.php?title=Graph_coloring&oldid=1110085555},
  urldate = {2022-09-13},
  abstract = {In graph theory, graph coloring is a special case of graph labeling; it is an assignment of labels traditionally called "colors" to elements of a graph subject to certain constraints. In its simplest form, it is a way of coloring the vertices of a graph such that no two adjacent vertices are of the same color; this is called a vertex coloring. Similarly, an edge coloring assigns a color to each edge so that no two adjacent edges are of the same color, and a face coloring of a planar graph assigns a color to each face or region so that no two faces that share a boundary have the same color. Vertex coloring is often used to introduce graph coloring problems, since other coloring problems can be transformed into a vertex coloring instance. For example, an edge coloring of a graph is just a vertex coloring of its line graph, and a face coloring of a plane graph is just a vertex coloring of its dual. However, non-vertex coloring problems are often stated and studied as-is. This is partly pedagogical, and partly because some problems are best studied in their non-vertex form, as in the case of edge coloring. The convention of using colors originates from coloring the countries of a map, where each face is literally colored. This was generalized to coloring the faces of a graph embedded in the plane. By planar duality it became coloring the vertices, and in this form it generalizes to all graphs. In mathematical and computer representations, it is typical to use the first few positive or non-negative integers as the "colors". In general, one can use any finite set as the "color set". The nature of the coloring problem depends on the number of colors but not on what they are. Graph coloring enjoys many practical applications as well as theoretical challenges. Beside the classical types of problems, different limitations can also be set on the graph, or on the way a color is assigned, or even on the color itself. It has even reached popularity with the general public in the form of the popular number puzzle Sudoku. Graph coloring is still a very active field of research. Note: Many terms used in this article are defined in Glossary of graph theory.},
  langid = {english},
  annotation = {Page Version ID: 1110085555},
  file = {/home/areo/Zotero/storage/PL34J7VD/Graph_coloring.html}
}

@article{griesNEWAPPROACHTEACHING1995,
  title = {A {{NEW APPROACH TO TEACHING DISCRETE MATHEMATICS}}},
  author = {Gries, David and Schneider, Fred B.},
  date = {1995-01},
  journaltitle = {PRIMUS},
  shortjournal = {PRIMUS},
  volume = {5},
  number = {2},
  pages = {113--138},
  issn = {1051-1970, 1935-4053},
  doi = {10.1080/10511979508965779},
  url = {http://www.tandfonline.com/doi/abs/10.1080/10511979508965779},
  urldate = {2024-01-30},
  langid = {english}
}

@software{griffithsScottgriffithsBitstring2022,
  title = {Scott-Griffiths/Bitstring},
  author = {Griffiths, Scott},
  date = {2022-01-20},
  url = {https://github.com/scott-griffiths/bitstring},
  urldate = {2022-01-28},
  abstract = {A Python module to help you manage your bits},
  keywords = {binary-data,bit-manipulation,bitarray,bitstring,python}
}

@artwork{gwendaEnglishDecryptionUsing2013,
  title = {English:  {{Decryption}} Using the {{Cipher Feedback}} ({{CFB}}) Mode.},
  shorttitle = {English},
  author = {{Gwenda}},
  year = {1 June 2013, 03:45:39},
  url = {https://commons.wikimedia.org/wiki/File:CFB_decryption.svg},
  urldate = {2024-05-22}
}

@artwork{gwendaEnglishDecryptionUsing2013a,
  title = {English:  {{Decryption}} Using the {{Counter}} ({{CTR}}) Mode.},
  shorttitle = {English},
  author = {{Gwenda}},
  year = {1 June 2013, 03:45:39},
  url = {https://commons.wikimedia.org/wiki/File:CTR_decryption_2.svg},
  urldate = {2024-05-22}
}

@artwork{gwendaEnglishEncryptionUsing2013,
  title = {English:  {{Encryption}} Using the {{Cipher Feedback}} ({{CFB}}) Mode.},
  shorttitle = {English},
  author = {{Gwenda}},
  year = {1 June 2013, 03:45:39},
  url = {https://commons.wikimedia.org/wiki/File:CFB_encryption.svg},
  urldate = {2024-05-22}
}

@online{HistoryGCCWiki,
  title = {History - {{GCC Wiki}}},
  url = {https://gcc.gnu.org/wiki/History},
  urldate = {2022-08-06},
  file = {/home/areo/Zotero/storage/YPIYF74M/History.html}
}

@online{HomeNeovim,
  title = {Home - {{Neovim}}},
  url = {http://neovim.io/},
  urldate = {2022-08-04}
}

@online{HowWriteNeovim,
  title = {How to Write Neovim Plugins in {{Lua}} | 2n},
  url = {https://www.2n.pl/blog/how-to-write-neovim-plugins-in-lua},
  urldate = {2024-01-11},
  file = {/home/areo/Zotero/storage/DPUWH76U/how-to-write-neovim-plugins-in-lua.html}
}

@online{htorqueAnswerWhyThere2011,
  title = {Answer to "{{Why}} Is There a 4-Layouts Limit for Keyboards?"},
  shorttitle = {Answer to "{{Why}} Is There a 4-Layouts Limit for Keyboards?},
  author = {{htorque}},
  date = {2011-01-16},
  url = {https://askubuntu.com/a/21844},
  urldate = {2023-11-05},
  organization = {Ask Ubuntu},
  file = {/home/areo/Zotero/storage/37Q3WGF7/why-is-there-a-4-layouts-limit-for-keyboards.html}
}

@inreference{IdentifierComputerLanguages2022,
  title = {Identifier (Computer Languages)},
  booktitle = {Wikipedia},
  date = {2022-04-05},
  url = {https://en.wikipedia.org/w/index.php?title=Identifier_(computer_languages)&oldid=1081115854},
  urldate = {2022-04-13},
  abstract = {In computer programming languages, an identifier is a lexical token (also called a symbol, but not to be confused with the symbol primitive data type) that names the language's entities. Some of the kinds of entities an identifier might denote include variables, data types, labels, subroutines, and modules.},
  file = {/home/areo/Zotero/storage/5XP2639V/Identifier_(computer_languages).html;/home/areo/Zotero/storage/L6UGYSD2/Identifier_(computer_languages).html}
}

@inreference{ImperativeProgrammierung2022,
  title = {Imperative Programmierung},
  booktitle = {Wikipedia},
  date = {2022-01-24T15:11:03Z},
  url = {https://de.wikipedia.org/w/index.php?title=Imperative_Programmierung&oldid=219505017},
  urldate = {2022-09-13},
  abstract = {Imperative Programmierung (lateinisch imperare ‚anordnen‘, ‚befehlen‘) ist ein Programmierparadigma, nach dem „ein Programm aus einer Folge von Anweisungen besteht, die vorgeben, in welcher Reihenfolge was vom Computer getan werden soll“.Die imperative Programmierung ist das am längsten bekannte Programmierparadigma. Diese Vorgehensweise war, bedingt durch den Sprachumfang früherer Programmiersprachen, ehemals die klassische Art des Programmierens. Sie liegt dem Entwurf von vielen Programmiersprachen, zum Beispiel ALGOL, BASIC, Fortran, Pascal, Ada, PL/I, Cobol, C und allen Assemblersprachen zugrunde.Abweichende Bezeichnungen: In der Literatur wird dieses Entwicklungskonzept zum Teil auch „imperativ/prozedural“, „algorithmisch“ oder auch „zustandsorientiert“ genannt. Auch die Bezeichnung „prozedurale Programmierung“ wird zum Teil synonym verwendet, was jedoch abweichend auch mit „Verwendung von Prozeduren“ definiert wird.},
  langid = {ngerman},
  annotation = {Page Version ID: 219505017},
  file = {/home/areo/Zotero/storage/QUVJN2CV/Imperative_Programmierung.html}
}

@online{InfiniteScrolling,
  title = {Infinite {{Scrolling}}},
  url = {https://xkcd.com/1309/},
  urldate = {2023-10-23},
  organization = {xkcd},
  file = {/home/areo/Zotero/storage/ETY6GVMD/1309.html}
}

@online{InstallAURPackages,
  title = {Install {{AUR}} Packages with Pacman},
  url = {http://gewhere.github.io/install-aur-with-pacman},
  urldate = {2023-11-05},
  file = {/home/areo/Zotero/storage/M3ZJYPIM/install-aur-with-pacman.html}
}

@inreference{Interpreter2022,
  title = {Interpreter},
  booktitle = {Wikipedia},
  date = {2022-06-16T13:48:37Z},
  url = {https://de.wikipedia.org/w/index.php?title=Interpreter&oldid=223748000},
  urldate = {2022-09-13},
  abstract = {Als Interpreter wird ein Computerprogramm bezeichnet, das eine Abfolge von Anweisungen anscheinend direkt ausführt, wobei das Format der Anweisungen vorgegeben ist. Der Interpreter liest dazu eine oder mehrere Quelldateien ein, analysiert diese und führt sie anschließend Anweisung für Anweisung aus, indem er den dafür vorgesehenen Programmcode (eventuell über Zwischenschritte schließlich als Maschinencode für das jeweilige Computersystem) direkt ausführt. Interpreter sind deutlich langsamer als Compiler, bieten im Allgemeinen jedoch eine bessere Fehleranalyse.Interpreter werden sowohl bei Programmiersprachen als auch bei Computerprogrammen sowie Kommandozeileninterpreter verwendet.},
  langid = {ngerman},
  annotation = {Page Version ID: 223748000},
  file = {/home/areo/Zotero/storage/8LKPH8TT/Interpreter.html}
}

@online{izmanAnswerHowSet2017,
  title = {Answer to "{{How}} to Set Subl:// Protocol Handler with {{Unity}}?"},
  shorttitle = {Answer to "{{How}} to Set Subl},
  author = {Izman, Andrey},
  date = {2017-05-28},
  url = {https://askubuntu.com/a/919825},
  urldate = {2023-11-05},
  organization = {Ask Ubuntu}
}

@online{JSONParserTutorial,
  title = {{{JSON}} Parser - {{Tutorial}} — {{Lark}} Documentation},
  url = {https://lark-parser.readthedocs.io/en/latest/json_tutorial.html},
  urldate = {2022-07-09},
  file = {/home/areo/Zotero/storage/CJHCPS2F/json_tutorial.html}
}

@online{kandasamyAnswerHowToggle2020,
  title = {Answer to "{{How}} to Toggle between Vim-Emulation and No-Vim-Emulation When the Vscodevim Extension Is Installed?"},
  shorttitle = {Answer to "{{How}} to Toggle between Vim-Emulation and No-Vim-Emulation When the Vscodevim Extension Is Installed?},
  author = {Kandasamy, Ramasamy},
  date = {2020-05-07},
  url = {https://stackoverflow.com/a/61652769},
  urldate = {2024-01-01},
  organization = {Stack Overflow},
  file = {/home/areo/Zotero/storage/BN6SQS52/61652769.html}
}

@online{karagilaAnswerPreciseDefinition2011,
  title = {Answer to "{{Precise}} Definition of "Weaker" and "Stronger"?"},
  shorttitle = {Answer to "{{Precise}} Definition of "Weaker" and "Stronger"?},
  author = {Karagila, Asaf},
  date = {2011-07-25},
  url = {https://math.stackexchange.com/a/53712},
  urldate = {2023-10-28},
  organization = {Mathematics Stack Exchange}
}

@online{karonenAnswerCanXEX2014,
  title = {Answer to "{{Can XEX}} or {{XTS}} Modes Be Used with Only One Tweak?"},
  shorttitle = {Answer to "{{Can XEX}} or {{XTS}} Modes Be Used with Only One Tweak?},
  author = {Karonen, Ilmari},
  date = {2014-04-30},
  url = {https://crypto.stackexchange.com/a/15912},
  urldate = {2024-06-30},
  organization = {Cryptography Stack Exchange},
  file = {/home/areo/Zotero/storage/XLSGAVLL/can-xex-or-xts-modes-be-used-with-only-one-tweak.html}
}

@online{karonenAnswerCanXEX2014a,
  title = {Answer to "{{Can XEX}} or {{XTS}} Modes Be Used with Only One Tweak?"},
  shorttitle = {Answer to "{{Can XEX}} or {{XTS}} Modes Be Used with Only One Tweak?},
  author = {Karonen, Ilmari},
  date = {2014-04-30},
  url = {https://crypto.stackexchange.com/a/15912},
  urldate = {2024-06-30},
  organization = {Cryptography Stack Exchange},
  file = {/home/areo/Zotero/storage/VV2MT46A/can-xex-or-xts-modes-be-used-with-only-one-tweak.html}
}

@online{karonenAnswerWhyCBC2012,
  title = {Answer to "{{Why}} Is {{CBC}} with Predictable {{IV}} Considered Insecure against Chosen-Plaintext Attack?"},
  shorttitle = {Answer to "{{Why}} Is {{CBC}} with Predictable {{IV}} Considered Insecure against Chosen-Plaintext Attack?},
  author = {Karonen, Ilmari},
  date = {2012-09-27},
  url = {https://crypto.stackexchange.com/a/3885},
  urldate = {2024-06-17},
  organization = {Cryptography Stack Exchange},
  file = {/home/areo/Zotero/storage/EQNH9QR2/why-is-cbc-with-predictable-iv-considered-insecure-against-chosen-plaintext-atta.html}
}

@book{katzIntroductionModernCryptography2007,
  title = {Introduction to {{Modern Cryptography}}: {{Principles}} and {{Protocols}}},
  shorttitle = {Introduction to {{Modern Cryptography}}},
  author = {Katz, Jonathan and Lindell, Yehuda},
  date = {2007-08-31},
  publisher = {{Chapman and Hall/CRC}},
  location = {New York},
  doi = {10.1201/9781420010756},
  abstract = {Cryptography plays a key role in ensuring the privacy and integrity of data and the security of computer networks. Introduction to Modern Cryptography provides a rigorous yet accessible treatment of modern cryptography, with a focus on formal definitions, precise assumptions, and rigorous proofs.The authors introduce the core principles of},
  isbn = {978-0-429-14380-9},
  pagetotal = {552}
}

@online{keithSingletonPatternPython2022,
  title = {Singleton {{Pattern In Python}}},
  author = {{Keith}},
  date = {2022-01-28},
  url = {https://stackoverflow.com/questions/52351312/singleton-pattern-in-python},
  urldate = {2022-01-28}
}

@software{klocknerPuDBConsolebasedVisual2022,
  title = {{{PuDB}}: A Console-Based Visual Debugger for {{Python}}},
  shorttitle = {{{PuDB}}},
  author = {Klöckner, Andreas},
  date = {2022-01-25},
  url = {https://github.com/inducer/pudb},
  urldate = {2022-01-28},
  abstract = {Full-screen console debugger for Python},
  keywords = {bpython,debug,debugger,ipython,pdb,pytest,pytest-plugin,python,urwid}
}

@misc{kol2022devicetrackinglinuxsnew,
  title = {Device Tracking via Linux's New {{TCP}} Source Port Selection Algorithm (Extended Version)},
  author = {Kol, Moshe and Klein, Amit and Gilad, Yossi},
  date = {2022},
  eprint = {2209.12993},
  eprinttype = {arXiv},
  eprintclass = {cs.CR},
  url = {https://arxiv.org/abs/2209.12993}
}

@inreference{KontextfreieGrammatik2021,
  title = {Kontextfreie Grammatik},
  booktitle = {Wikipedia},
  date = {2021-07-17T13:04:47Z},
  url = {https://de.wikipedia.org/w/index.php?title=Kontextfreie_Grammatik&oldid=213960399},
  urldate = {2022-09-13},
  abstract = {In der Theorie der formalen Sprachen ist eine kontextfreie Grammatik (englisch context-free grammar, CFG) eine formale Grammatik, die nur solche Ersetzungsregeln enthält, bei denen immer genau ein Nichtterminalsymbol auf eine beliebig lange Folge von Nichtterminal- und Terminalsymbolen abgeleitet wird. Die Ersetzungsregeln haben also die Form                         V         →         w                 \{\textbackslash displaystyle V\textbackslash rightarrow w\}    (mit Nichtterminalsymbol                         V                 \{\textbackslash displaystyle V\}    und Zeichenkette                         w                 \{\textbackslash displaystyle w\}    bestehend aus Nichtterminal- und/oder Terminalsymbolen). Weil die linke Seite einer Regel nur aus einem einzigen Nichtterminalsymbol                         V                 \{\textbackslash displaystyle V\}    besteht, hängt ihre Anwendbarkeit auf eine Zeichenkette nur davon ab, ob das Nichtterminalsymbol                         V                 \{\textbackslash displaystyle V\}    in der Zeichenkette vorkommt, nicht aber davon, in welchem Kontext es sich befindet, d. h. welche Zeichen links und/oder rechts davon stehen. Die Regeln sind also kontextfrei. Die kontextfreien Grammatiken sind identisch mit den Typ-2-Grammatiken der Chomsky-Hierarchie.},
  langid = {ngerman},
  annotation = {Page Version ID: 213960399}
}

@inreference{Kontrollfluss2021,
  title = {Kontrollfluss},
  booktitle = {Wikipedia},
  date = {2021-04-10T11:38:48Z},
  url = {https://de.wikipedia.org/w/index.php?title=Kontrollfluss&oldid=210777251},
  urldate = {2022-09-13},
  abstract = {Der Kontrollfluss oder Programmablauf bezeichnet in der Informatik die zeitliche Abfolge der einzelnen Befehle eines Computerprogramms. Der Kontrollfluss eines Programms ist gewöhnlich durch die Reihenfolge der Befehle innerhalb des Programms vorgegeben, jedoch erlauben Kontrollstrukturen von der sequenziellen Abarbeitung des Programms abzuweichen. Die Abarbeitungsreihenfolge der einzelnen Befehle, welche das Programm vorgibt, wird von Kontrollflussabhängigkeiten festgelegt: Ein einzelner Befehl wird entweder dann ausgeführt, wenn der unmittelbar vorhergehende Befehl abgearbeitet und der Programmzähler inkrementiert wurde oder wenn ein Sprungbefehl auf die entsprechende Stelle im Speicher zeigt und dem Programmzähler durch den Sprungbefehl ein neuer Wert zugewiesen wird. Beide Kontrollflussabhängigkeiten müssen bei der parallelen Ausführung von Befehlen des Programms berücksichtigt werden.},
  langid = {ngerman},
  annotation = {Page Version ID: 210777251},
  file = {/home/areo/Zotero/storage/RJYZK98V/Kontrollfluss.html}
}

@inreference{Kontrollflussgraph2022,
  title = {Kontrollflussgraph},
  booktitle = {Wikipedia},
  date = {2022-03-27T11:00:15Z},
  url = {https://de.wikipedia.org/w/index.php?title=Kontrollflussgraph&oldid=221536594},
  urldate = {2022-09-13},
  abstract = {Ein Kontrollflussgraph ist ein Begriff aus der Informatik und bezeichnet einen gerichteten Graphen, der dazu dient, den Kontrollfluss eines Computerprogramms zu beschreiben. Sie werden unter anderem zur Programmoptimierung eingesetzt.},
  langid = {ngerman},
  annotation = {Page Version ID: 221536594},
  file = {/home/areo/Zotero/storage/LEU2GLSD/Kontrollflussgraph.html}
}

@inreference{LabelProgrammierung2022,
  title = {Label (Programmierung)},
  booktitle = {Wikipedia},
  date = {2022-01-03T17:53:52Z},
  url = {https://de.wikipedia.org/w/index.php?title=Label_(Programmierung)&oldid=218756487},
  urldate = {2022-09-13},
  abstract = {Ein Label (zu Deutsch: Sprungmarke) in einem Quellcode eines Computerprogramms ist eine durch einen Bezeichner eindeutig gekennzeichnete Marke, die üblicherweise als Sprungziel dient.},
  langid = {ngerman},
  annotation = {Page Version ID: 218756487},
  file = {/home/areo/Zotero/storage/8QL2KGAV/Label_(Programmierung).html}
}

@software{LarkParsingToolkit2022,
  title = {Lark - a Parsing Toolkit for {{Python}}},
  date = {2022-04-26},
  url = {https://github.com/lark-parser/lark},
  urldate = {2022-04-28},
  abstract = {Lark is a parsing toolkit for Python, built with a focus on ergonomics, performance and modularity.},
  organization = {Lark - Parsing Library \& Toolkit},
  keywords = {cyk,earley,grammar,lalr,lark,parse,parser,parser-library,parsing-engine,parsing-library,python,tree}
}

@report{larsenRecommendationsTransportProtocolPort2011,
  type = {Request for Comments},
  title = {Recommendations for {{Transport-Protocol Port Randomization}}},
  author = {Larsen, Michael and Gont, Fernando},
  date = {2011-01},
  number = {RFC 6056},
  institution = {Internet Engineering Task Force},
  doi = {10.17487/RFC6056},
  url = {https://datatracker.ietf.org/doc/rfc6056},
  urldate = {2025-07-03},
  abstract = {During the last few years, awareness has been raised about a number of "blind" attacks that can be performed against the Transmission Control Protocol (TCP) and similar protocols. The consequences of these attacks range from throughput reduction to broken connections or data corruption. These attacks rely on the attacker's ability to guess or know the five-tuple (Protocol, Source Address, Destination Address, Source Port, Destination Port) that identifies the transport protocol instance to be attacked. This document describes a number of simple and efficient methods for the selection of the client port number, such that the possibility of an attacker guessing the exact value is reduced. While this is not a replacement for cryptographic methods for protecting the transport-protocol instance, the aforementioned port selection algorithms provide improved security with very little effort and without any key management overhead. The algorithms described in this document are local policies that may be incrementally deployed and that do not violate the specifications of any of the transport protocols that may benefit from them, such as TCP, UDP, UDP-lite, Stream Control Transmission Protocol (SCTP), Datagram Congestion Control Protocol (DCCP), and RTP (provided that the RTP application explicitly signals the RTP and RTCP port numbers). This memo documents an Internet Best Current Practice.},
  pagetotal = {29},
  file = {/home/areo/Zotero/storage/8YUVUEFJ/Larsen and Gont - 2011 - Recommendations for Transport-Protocol Port Random.pdf}
}

@online{Lecturenotes20212022,
  title = {Lecture-Notes-2021},
  date = {2022-01-20},
  url = {https://github.com/Compiler-Construction-Uni-Freiburg/lecture-notes-2021/blob/56300e6649e32f0594bbbd046a2e19351c57dd0c/material/lexical-analysis.pdf},
  urldate = {2022-04-28}
}

@book{lefeverArtExplanationMaking2012,
  title = {The Art of Explanation: Making your Ideas, Products, and Services Easier to Understand},
  shorttitle = {The Art of Explanation},
  author = {LeFever, Lee},
  date = {2012-11-20},
  edition = {1},
  publisher = {Wiley},
  langid = {Englisch}
}

@artwork{lesage,
  title = {Pinguin {{Tux}}},
  author = {LeSage and Budig, Simon and Garrett and Ewing, Larry},
  url = {https://commons.wikimedia.org/wiki/File:Tux.svg},
  urldate = {2024-05-22}
}

@artwork{lesageRusskiyIzobrazheniePingvina2022,
  title = {{{ECB Penguin}}},
  shorttitle = {Русский},
  author = {LeSage, Garrett, Larry Ewing},
  date = {2022-11-17},
  url = {https://commons.wikimedia.org/wiki/File:Tux_ECB.png},
  urldate = {2024-05-22}
}

@inreference{LexicalAnalysis2022,
  title = {Lexical Analysis},
  booktitle = {Wikipedia},
  date = {2022-08-16T20:38:19Z},
  url = {https://en.wikipedia.org/w/index.php?title=Lexical_analysis&oldid=1104772145},
  urldate = {2022-09-13},
  abstract = {In computer science, lexical analysis, lexing or tokenization is the process of converting a sequence of characters (such as in a computer program or web page) into a sequence of lexical tokens (strings with an assigned and thus identified meaning). A program that performs lexical analysis may be termed a lexer, tokenizer, or scanner, although scanner is also a term for the first stage of a lexer. A lexer is generally combined with a parser, which together analyze the syntax of programming languages, web pages, and so forth.},
  langid = {english},
  annotation = {Page Version ID: 1104772145},
  file = {/home/areo/Zotero/storage/AWPPTLGL/Lexical_analysis.html}
}

@inreference{LexikalischeAnalyse2022,
  title = {Lexikalische Analyse},
  booktitle = {Wikipedia},
  date = {2022-08-22T13:24:45Z},
  url = {https://de.wikipedia.org/w/index.php?title=Lexikalische_Analyse&oldid=225542512},
  urldate = {2022-09-13},
  abstract = {Lexikalische Analyse ist in der Informatik die Zerlegung einer Zeichenkette (z. B.  Quelltext) in eine Folge von logisch zusammengehörigen Einheiten, sogenannte Token. Ein Computerprogramm, das eine lexikalische Analyse durchführt, wird Lexer, Tokenizer oder lexikalischer Scanner genannt. Ein Lexer ist meist Teil eines Compilers und wird als erster Schritt in der Analysephase ausgeführt. Das Ergebnis des Lexers wird im nächsten Schritt von einem Parser weiterverarbeitet.},
  langid = {ngerman},
  annotation = {Page Version ID: 225542512},
  file = {/home/areo/Zotero/storage/FYYFGHRM/Lexikalische_Analyse.html}
}

@software{LibuvLibuv2024,
  title = {Libuv/Libuv},
  date = {2024-02-21T06:00:57Z},
  origdate = {2013-11-30T00:29:56Z},
  url = {https://github.com/libuv/libuv},
  urldate = {2024-02-21},
  abstract = {Cross-platform asynchronous I/O},
  organization = {libuv},
  keywords = {asynchronous,deep-io,io,networking,unicorns,unix,velociraptors,windows}
}

@online{LibuvLibuvCrossplatform,
  title = {Libuv/Libuv: {{Cross-platform}} Asynchronous {{I}}/{{O}}},
  url = {https://github.com/libuv/libuv},
  urldate = {2024-02-22},
  file = {/home/areo/Zotero/storage/ILZMU4ID/libuv.html}
}

@online{lindleyAnswerAssignArray2013,
  title = {Answer to "{{Assign}} Array to Array"},
  author = {Lindley, Benjamin},
  date = {2013-09-23},
  url = {https://stackoverflow.com/a/18962507},
  urldate = {2022-05-07}
}

@inreference{LinkerComputerprogramm2022,
  title = {Linker (Computerprogramm)},
  booktitle = {Wikipedia},
  date = {2022-08-04T10:27:28Z},
  url = {https://de.wikipedia.org/w/index.php?title=Linker_(Computerprogramm)&oldid=225065452},
  urldate = {2022-09-13},
  abstract = {Unter einem Linker oder Binder (auch: „Bindelader“) versteht man ein Computerprogramm, das einzelne Programmmodule zu einem ausführbaren Programm zusammenstellt (verbindet). Auf IBM-Großrechnersystemen wird der Linker linkage editor (englisch) genannt.Die meisten Programme enthalten Bestandteile oder Module, die in anderen Programmen Verwendung finden können. Mehrere kompilierte Module mit Funktionen (so genannte Objektdateien) können zu Funktionsbibliotheken (Programmbibliotheken) zusammengefasst werden. Der Code wird durch den Linker zum Hauptprogramm hinzugefügt, falls die entsprechende Funktion benötigt wird. Um ein Programmmodul in einem anderen Programm verwenden zu können, müssen die symbolischen Adressen der Funktionen und Variablen des Moduls in Speicheradressen umgewandelt werden. Diese Aufgabe übernimmt der Linker. Der Linkvorgang erfolgt nach der Kompilierung und ist meistens der letzte Arbeitsschritt zur Erstellung eines Programms. Man unterscheidet generell zwischen statischem und dynamischem Linken.},
  langid = {ngerman},
  annotation = {Page Version ID: 225065452},
  file = {/home/areo/Zotero/storage/AQR5YPYA/Linker_(Computerprogramm).html}
}

@online{LinuxConsoleKeyboard,
  title = {Linux Console/{{Keyboard}} Configuration - {{ArchWiki}}},
  url = {https://wiki.archlinux.org/title/Linux_console/Keyboard_configuration},
  urldate = {2023-11-05},
  file = {/home/areo/Zotero/storage/6J3UTTBM/Keyboard_configuration.html}
}

@online{LinuxConsoleKeyboarda,
  title = {Linux Console/{{Keyboard}} Configuration - {{ArchWiki}}},
  url = {https://wiki.archlinux.org/title/Linux_console/Keyboard_configuration},
  urldate = {2023-11-05},
  file = {/home/areo/Zotero/storage/4BD53ABS/Keyboard_configuration.html}
}

@article{liskov2008comments,
  title = {Comments on Xts-Aes},
  author = {Liskov, Moses and Minematsu, Kazuhiko},
  date = {2008},
  journaltitle = {Comments to NIST, available from their web page}
}

@article{liskov2011tweakable,
  title = {Tweakable Block Ciphers},
  author = {Liskov, Moses and Rivest, Ronald L and Wagner, David},
  date = {2011},
  journaltitle = {Journal of cryptology},
  volume = {24},
  pages = {588--613},
  publisher = {Springer}
}

@article{liskovTweakableBlockCiphers2011,
  title = {Tweakable {{Block Ciphers}}},
  author = {Liskov, Moses and Rivest, Ronald L. and Wagner, David},
  date = {2011-07},
  journaltitle = {Journal of Cryptology},
  shortjournal = {J Cryptol},
  volume = {24},
  number = {3},
  pages = {588--613},
  issn = {0933-2790, 1432-1378},
  doi = {10.1007/s00145-010-9073-y},
  url = {http://link.springer.com/10.1007/s00145-010-9073-y},
  urldate = {2024-05-30},
  abstract = {A common trend in applications of block ciphers over the past decades has been to employ block ciphers as one piece of a “mode of operation”—possibly, a way to make a secure symmetric-key cryptosystem, but more generally, any cryptographic application. Most of the time, these modes of operation use a wide variety of techniques to achieve a subgoal necessary for their main goal: instantiation of “essentially different” instances of the block cipher.},
  langid = {english},
  file = {/home/areo/Zotero/storage/8WA92MWN/Liskov et al. - 2011 - Tweakable Block Ciphers.pdf}
}

@article{liskovTweakableBlockCiphers2011a,
  title = {Tweakable {{Block Ciphers}}},
  author = {Liskov, Moses and Rivest, Ronald L. and Wagner, David},
  date = {2011-07-01},
  journaltitle = {Journal of Cryptology},
  shortjournal = {J Cryptol},
  volume = {24},
  number = {3},
  pages = {588--613},
  issn = {1432-1378},
  doi = {10.1007/s00145-010-9073-y},
  url = {https://doi.org/10.1007/s00145-010-9073-y},
  urldate = {2024-06-16},
  abstract = {A common trend in applications of block ciphers over the past decades has been to employ block ciphers as one piece of a “mode of operation”—possibly, a~way to make a secure symmetric-key cryptosystem, but more generally, any cryptographic application. Most of the time, these modes of operation use a wide variety of techniques to achieve a subgoal necessary for their main goal: instantiation of “essentially different” instances of the block cipher.},
  langid = {english},
  keywords = {Block ciphers,Initialization vector,Modes of operation,Pseudorandomness,Tweakable block ciphers},
  file = {/home/areo/Zotero/storage/NF5ED6TN/Liskov et al. - 2011 - Tweakable Block Ciphers.pdf}
}

@inreference{Literal2021,
  title = {Literal},
  booktitle = {Wikipedia},
  date = {2021-10-17T11:39:17Z},
  url = {https://de.wikipedia.org/w/index.php?title=Literal&oldid=216440695},
  urldate = {2022-09-13},
  abstract = {Ein Literal ist ein spezieller Bestandteil einer formalen Sprache.},
  langid = {ngerman},
  annotation = {Page Version ID: 216440695},
  file = {/home/areo/Zotero/storage/6PFHTBSI/Literal.html}
}

@online{ljohhuhWhatImmediateValue2018,
  title = {What Is an Immediate Value?},
  author = {{Ljohhuh}},
  date = {2018-04-04},
  url = {https://reverseengineering.stackexchange.com/q/17671},
  urldate = {2022-04-13},
  file = {/home/areo/Zotero/storage/HN866RIB/what-is-an-immediate-value.html;/home/areo/Zotero/storage/WKSVNG3G/what-is-an-immediate-value.html}
}

@inreference{LLGrammatik2015,
  title = {LL(k)-Grammatik},
  booktitle = {Wikipedia},
  date = {2015-07-07T18:05:56Z},
  url = {https://de.wikipedia.org/w/index.php?title=LL(k)-Grammatik&oldid=143824732},
  urldate = {2022-09-13},
  abstract = {Dieser Artikel setzt Vorkenntnisse im Bereich Theoretische Informatik und Compilerbau voraus. Eine LL(k)-Grammatik (im Gegensatz zu LF(k)-Grammatik auch schwache LL(k)-Grammatik) ist eine spezielle kontextfreie Grammatik, welche die Grundlage eines LL(k)-Parsers bildet. Eine kontextfreie Grammatik heißt LL(k)-Grammatik für eine natürliche Zahl k, wenn jeder Ableitungsschritt eindeutig durch die nächsten k Symbole der Eingabe (Lookahead) bestimmt ist. Das bedeutet, die Frage, welches Nichtterminalsymbol mit welcher Regel als Nächstes expandiert werden soll, kann eindeutig mit Hilfe der nächsten k Symbole der Eingabe bestimmt werden. Generell gilt, je größer k gewählt wird, umso mächtiger wird die Sprachklasse, wobei die Ausdrucksstärke von kontextfreien Grammatiken nie erreicht wird. Damit gibt es kontextfreie Sprachen, die für kein k von einer LL(k)-Grammatik erzeugt werden.                                                L                             (                    L           L                  (         1         )         )         ⊊                                 L                             (                    L           L                  (         2         )         )         ⊊         ⋯         ⊊                                 L                             (                    L           L                  (         k         )         )         ⊊                                 L                             (                    L           R                  (         1         )         )         =                                 L                             (                    D           P           D           A                  )                 \{\textbackslash displaystyle \{\textbackslash mathcal \{L\}\}(\textbackslash mathrm \{LL\} (1))\textbackslash subsetneq \{\textbackslash mathcal \{L\}\}(\textbackslash mathrm \{LL\} (2))\textbackslash subsetneq \textbackslash dots \textbackslash subsetneq \{\textbackslash mathcal \{L\}\}(\textbackslash mathrm \{LL\} (k))\textbackslash subsetneq \{\textbackslash mathcal \{L\}\}(\textbackslash mathrm \{LR\} (1))=\{\textbackslash mathcal \{L\}\}(\textbackslash mathrm \{DPDA\} )\}    Dabei steht DPDA für die deterministischen Kellerautomaten. Diese können genau die deterministisch kontextfreien Sprachen erkennen.},
  langid = {ngerman},
  annotation = {Page Version ID: 143824732},
  file = {/home/areo/Zotero/storage/R8YD8EN6/LL(k)-Grammatik.html}
}

@online{LogicIfVs,
  title = {The {{Logic}} of "{{If}}" vs. "{{Only}} If" (Article) | {{Khan Academy}}},
  url = {https://www.khanacademy.org/_render},
  urldate = {2023-10-28},
  langid = {english},
  file = {/home/areo/Zotero/storage/2YX4PXZH/logic-toolbox--if-and-only-if.html}
}

@online{LuvDocsMd,
  title = {Luv/Docs.Md at Master · Luvit/Luv},
  url = {https://github.com/luvit/luv/blob/master/docs.md},
  urldate = {2024-02-23},
  abstract = {Bare libuv bindings for lua. Contribute to luvit/luv development by creating an account on GitHub.},
  langid = {english},
  organization = {GitHub},
  file = {/home/areo/Zotero/storage/I5PHKBXT/docs.html}
}

@online{LuvitLuvBare,
  title = {Luvit/Luv: {{Bare}} Libuv Bindings for Lua},
  url = {https://github.com/luvit/luv},
  urldate = {2024-02-22}
}

@online{mahajanScalerTopics2022,
  title = {Scaler {{Topics}}},
  author = {Mahajan, Urvish},
  date = {2022-01-28},
  url = {https://www.scaler.com/topics/c/types-of-errors-in-c/},
  urldate = {2022-05-10},
  abstract = {This article by Scaler Topics explains errors \& their types in C, covering the explanation \& examples for each type of error in C Programming Language.},
  file = {/home/areo/Zotero/storage/CB27JXAK/types-of-errors-in-c.html;/home/areo/Zotero/storage/CLLE8Y7I/types-of-errors-in-c.html}
}

@online{malexmaveAnswerRegularCTR2016,
  title = {Answer to "{{Is}} Regular {{CTR}} Mode Vulnerable to Any Attacks?"},
  shorttitle = {Answer to "{{Is}} Regular {{CTR}} Mode Vulnerable to Any Attacks?},
  author = {{malexmave}},
  date = {2016-03-21},
  url = {https://crypto.stackexchange.com/a/33861},
  urldate = {2024-06-16},
  organization = {Cryptography Stack Exchange},
  file = {/home/areo/Zotero/storage/56UFVA5A/is-regular-ctr-mode-vulnerable-to-any-attacks.html}
}

@online{Manjaro2022,
  title = {Manjaro},
  date = {2022-01-28},
  url = {https://wallpapercave.com/w/wp9774690},
  urldate = {2022-01-28}
}

@online{mAnswerWhatDefinition2010,
  title = {Answer to "{{What}} Is the Definition of the \$\textbackslash uplus\$ Symbol?"},
  shorttitle = {Answer to "{{What}} Is the Definition of the \$\textbackslash uplus\$ Symbol?},
  author = {M, J.},
  date = {2010-04-17},
  url = {https://mathoverflow.net/a/21644},
  urldate = {2023-11-12},
  organization = {MathOverflow},
  file = {/home/areo/Zotero/storage/AQCH2UEN/what-is-the-definition-of-the-uplus-symbol.html}
}

@online{margusAnswerIteratingEvery2011,
  title = {Answer to "{{Iterating}} over Every Two Elements in a List"},
  author = {{Margus}},
  date = {2011-03-22},
  url = {https://stackoverflow.com/a/5389578},
  urldate = {2022-05-03}
}

@inreference{Maschinensprache2022,
  title = {Maschinensprache},
  booktitle = {Wikipedia},
  date = {2022-05-31T06:13:39Z},
  url = {https://de.wikipedia.org/w/index.php?title=Maschinensprache&oldid=223307867},
  urldate = {2022-09-13},
  abstract = {Eine Maschinensprache, wie sie bei Maschinencode bzw. nativem Code verwendet wird, ist eine Programmiersprache, bei der die Instruktionen, die vom Prozessor ausgeführt werden sollen, als formale Sprachelemente festgelegt sind. Aufgrund ihrer Nähe zur Hardware wird sie auch verallgemeinernd als die „Programmiersprache eines Computers“ bezeichnet. Umfang und Syntax der Maschinenbefehle sind im Befehlssatz definiert und abhängig vom Prozessortyp. Maschinensprache wird meistens als Binärcode oder vereinfacht mithilfe von Hexadezimalzahlen dargestellt. Ein Maschinenbefehl ist hierbei eine Anweisung an den Prozessor, eine Operation durchzuführen, beispielsweise eine Addition oder einen Wertevergleich. Jede funktionelle Leistung eines Prozessors ist daher Ergebnis der Ausführung von Maschinencode, eines in Maschinensprache vorliegenden Programms. Programme in Maschinensprache werden üblicherweise nicht vom Programmierer direkt erzeugt, sondern unter Nutzung einer höheren Programmiersprache oder einer Assemblersprache, wobei erst mithilfe eines Compilers bzw. Assemblers ausführbarer Maschinencode entsteht. Wird von „Programmierung in Maschinensprache“ gesprochen, ist damit manchmal fälschlicherweise die Programmierung in Assemblersprache gemeint. Bei der Ausführung durch Interpreter werden dagegen die Maschinenbefehle beim Programmstart oder während der Laufzeit erzeugt. Manchmal werden Ausdrücke wie „Maschinencode, Maschinensprache, Binärcode, nativer Code, Programmcode“ synonym verwendet. Sie können jedoch zwei unterschiedliche Bedeutungen haben: Für die typisierende Bezeichnung des verwendeten Codes als Syntaxbestimmung. Beispiel: „Quellcode (für die Programmiersprache XYZ)“ Für den Programmcode eines bestimmten Programms. Beispiel „Binärcode (für Programm ABC)“},
  langid = {ngerman},
  annotation = {Page Version ID: 223307867},
  file = {/home/areo/Zotero/storage/SYBR2DXU/Maschinensprache.html}
}

@inreference{MehrdeutigeGrammatik2013,
  title = {Mehrdeutige Grammatik},
  booktitle = {Wikipedia},
  date = {2013-03-27T03:11:30Z},
  url = {https://de.wikipedia.org/w/index.php?title=Mehrdeutige_Grammatik&oldid=115943783},
  urldate = {2022-09-13},
  abstract = {Existieren bzgl. einer formalen Grammatik für ein Wort mehrere Rechtsableitungen oder Linksableitungen, bzw. gibt es zu einem Wort der Grammatik zwei verschiedene Rechts- oder zwei verschiedene Linksableitungsbäume, die nicht isomorph zueinander sind, dann heißt diese Grammatik mehrdeutig.},
  langid = {ngerman},
  annotation = {Page Version ID: 115943783},
  file = {/home/areo/Zotero/storage/BUT94F4I/Mehrdeutige_Grammatik.html}
}

@inreference{Metasprache2020,
  title = {Metasprache},
  booktitle = {Wikipedia},
  date = {2020-07-26T13:22:35Z},
  url = {https://de.wikipedia.org/w/index.php?title=Metasprache&oldid=202231184},
  urldate = {2022-09-13},
  abstract = {Eine Metasprache ist eine „Sprache über Sprache“. Die Sprache, über die eine Metasprache spricht, ist die zugehörige Objektsprache.Meta kommt aus dem Griechischen (μετά) und bedeutet unter anderem so viel wie ‚hinter‘, ‚über‘.},
  langid = {ngerman},
  annotation = {Page Version ID: 202231184},
  file = {/home/areo/Zotero/storage/JCGC8IVD/Metasprache.html}
}

@inreference{Metasyntax2022,
  title = {Metasyntax},
  booktitle = {Wikipedia},
  date = {2022-04-16T06:49:55Z},
  url = {https://en.wikipedia.org/w/index.php?title=Metasyntax&oldid=1082973684},
  urldate = {2022-09-13},
  abstract = {In logic and computer science, a metasyntax describes the allowable structure and composition of phrases and sentences of a metalanguage, which is used to describe either a natural language or a computer programming language. Some of the widely used formal metalanguages for computer languages are Backus–Naur form (BNF), extended Backus–Naur form (EBNF), Wirth syntax notation (WSN), and augmented Backus–Naur form (ABNF). These metalanguages have their own metasyntax each composed of terminal symbols, nonterminal symbols, and metasymbols. A terminal symbol, such as a word or a token, is a stand-alone structure in a language being defined. A nonterminal symbol represents a syntactic category, which defines one or more valid phrasal or sentence structure consisted of an n-element subset. Metasymbols provide syntactic information for denotational purposes in a given metasyntax. Terminals, nonterminals, and metasymbols do not apply across all metalanguages. Typically, the metalanguage for token-level languages (formally called "regular languages") does not have nonterminals because nesting is not an issue in these regular languages. English, as a metalanguage for describing certain languages, does not contain metasymbols since all explanation could be done using English expression. There are only certain formal metalanguages used for describing recursive languages (formally called context-free languages) that have terminals, nonterminals, and metasymbols in their metasyntax.},
  langid = {english},
  annotation = {Page Version ID: 1082973684},
  file = {/home/areo/Zotero/storage/ZCEMV45C/Metasyntax.html}
}

@online{MethodComplements2023,
  title = {Method of Complements},
  date = {2023-03-29T10:06:07Z},
  url = {https://en.wikipedia.org/w/index.php?title=Method_of_complements&oldid=1147184194},
  urldate = {2023-06-08},
  abstract = {In mathematics and computing, the method of complements is a technique to encode a symmetric range of positive and negative integers in a way that they can use the same algorithm (hardware) for addition throughout the whole range. For a given number of places half of the possible representations of numbers encode the positive numbers, the other half represents their respective additive inverses. The pairs of mutually additive inverse numbers are called complements.  Thus subtraction of any number is implemented by adding its complement. Changing the sign of any number is encoded by generating its complement, which can be done by a very simple and efficient algorithm. This method was commonly used in mechanical calculators and is still used in modern computers. The generalized concept of the radix complement (as described below) is also valuable in number theory, such as in Midy's theorem. The nines' complement of a number given in decimal representation is formed by replacing each digit with nine minus that digit. To subtract a decimal number y (the subtrahend) from another number x (the minuend) two methods may be used: In the first method the nines' complement of x is added to y. Then the nines' complement of the result obtained is formed to produce the desired result. In the second method the nines' complement of y is added to x and one is added to the sum.  The leftmost digit '1' of the result is then discarded. Discarding the leftmost '1' is especially convenient on calculators or computers that use a fixed number of digits: there is nowhere for it to go so it is simply lost during the calculation. The nines' complement plus one is known as the ten's complement. The method of complements can be extended to other number bases (radices); in particular, it is used on most digital computers to perform subtraction, represent negative numbers in base 2 or binary arithmetic and test underflow and overflow in calculation.},
  langid = {english},
  organization = {Wikipedia},
  annotation = {Page Version ID: 1147184194},
  file = {/home/areo/Zotero/storage/NZ4U8KFU/Method_of_complements.html}
}

@online{MIMETypesIANA2023,
  title = {{{MIME}} Types ({{IANA}} Media Types) - {{HTTP}} | {{MDN}}},
  date = {2023-07-25},
  url = {https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types},
  urldate = {2023-11-05},
  abstract = {A media type (also known as a Multipurpose Internet Mail Extensions or MIME type) indicates the nature and format of a document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838.},
  langid = {american}
}

@online{mkarasekAnswerWhatDifference2010,
  title = {Answer to "{{What}}'s the Difference between Git Reset --Mixed, --Soft, and --Hard?"},
  shorttitle = {Answer to "{{What}}'s the Difference between Git Reset --Mixed, --Soft, and --Hard?},
  author = {{mkarasek}},
  date = {2010-08-20},
  url = {https://stackoverflow.com/a/3528483},
  urldate = {2023-11-21},
  organization = {Stack Overflow},
  file = {/home/areo/Zotero/storage/XRB74KFI/whats-the-difference-between-git-reset-mixed-soft-and-hard.html}
}

@online{mouhaMultiKeySecurityEvenMansour2015,
  title = {Multi-{{Key Security}}: {{The Even-Mansour Construction Revisited}}},
  shorttitle = {Multi-{{Key Security}}},
  author = {Mouha, Nicky and Luykx, Atul},
  date = {2015},
  number = {2015/101},
  url = {https://eprint.iacr.org/2015/101},
  urldate = {2024-06-16},
  abstract = {At ASIACRYPT 1991, Even and Mansour introduced a block cipher construction based on a single permutation. Their construction has since been lauded for its simplicity, yet also criticized for not providing the same security as other block ciphers against generic attacks. In this paper, we prove that if a small number of plaintexts are encrypted under multiple independent keys, the Even-Mansour construction surprisingly offers similar security as an ideal block cipher with the same block and key size. Note that this multi-key setting is of high practical relevance, as real-world implementations often allow frequent rekeying. We hope that the results in this paper will further encourage the use of the Even-Mansour construction, especially when the secure and efficient implementation of a key schedule would result in a significant overhead.},
  pubstate = {prepublished},
  keywords = {broadcast attack,Even-Mansour,multi-key setting,related-key setting},
  annotation = {Publication info: Published by the IACR in CRYPTO 2015},
  file = {/home/areo/Zotero/storage/F5WSB4MI/Mouha and Luykx - 2015 - Multi-Key Security The Even-Mansour Construction .pdf}
}

@online{MunifTanjimNuiNvim,
  title = {{{MunifTanjim}}/Nui.Nvim: {{UI Component Library}} for {{Neovim}}.},
  url = {https://github.com/MunifTanjim/nui.nvim},
  urldate = {2024-02-21},
  file = {/home/areo/Zotero/storage/VGSYW7TR/nui.html}
}

@online{mwhsAnswerWhyCBC2014,
  title = {Answer to "{{Why}} Is {{CBC}} with Predictable {{IV}} Considered Insecure against Chosen-Plaintext Attack?"},
  shorttitle = {Answer to "{{Why}} Is {{CBC}} with Predictable {{IV}} Considered Insecure against Chosen-Plaintext Attack?},
  author = {{mwhs}},
  date = {2014-07-31},
  url = {https://crypto.stackexchange.com/a/18401},
  urldate = {2024-06-16},
  organization = {Cryptography Stack Exchange},
  file = {/home/areo/Zotero/storage/37L2DS73/why-is-cbc-with-predictable-iv-considered-insecure-against-chosen-plaintext-atta.html}
}

@inreference{NamingConventionProgramming2022,
  title = {Naming Convention (Programming)},
  booktitle = {Wikipedia},
  date = {2022-07-24T02:02:57Z},
  url = {https://en.wikipedia.org/w/index.php?title=Naming_convention_(programming)&oldid=1100066005},
  urldate = {2022-07-30},
  abstract = {In computer programming, a naming convention is a set of rules for choosing the character sequence to be used for identifiers which denote variables, types, functions, and other entities in source code and documentation. Reasons for using a naming convention (as opposed to allowing programmers to choose any character sequence) include the following: To reduce the effort needed to read and understand source code; To enable code reviews to focus on issues more important than syntax and naming standards. To enable code quality review tools to focus their reporting mainly on significant issues other than syntax and style preferences.The choice of naming conventions can be an enormously controversial issue, with partisans of each holding theirs to be the best and others to be inferior. Colloquially, this is said to be a matter of dogma. Many companies have also established their own set of conventions.},
  langid = {english},
  annotation = {Page Version ID: 1100066005},
  file = {/home/areo/Zotero/storage/QG2XJGAC/Naming_convention_(programming).html}
}

@unpublished{nebelTheoretischeInformatik2020,
  type = {Vorlesung},
  title = {Theoretische Informatik},
  author = {Nebel, Bernhard},
  date = {2020},
  url = {http://gki.informatik.uni-freiburg.de/teaching/ss20/info3/index_de.html},
  urldate = {2022-07-09},
  langid = {ngerman},
  venue = {Universität Freiburg}
}

@online{neelamWhatDifferenceFunction2014,
  title = {What Is the Difference between Function Signature and Function Prototype?},
  author = {Neelam},
  date = {2014-06-22T15:33:17+00:00},
  url = {https://www.queryhome.com/tech/48466/difference-between-function-signature-function-prototype},
  urldate = {2022-07-18},
  abstract = {What is the difference between function signature and function prototype?},
  langid = {american},
  organization = {QueryHome},
  file = {/home/areo/Zotero/storage/BAKB4WP8/difference-between-function-signature-function-prototype.html}
}

@software{nemecCopyFileAnother2022,
  title = {Copy\_file\_to\_another\_repo\_action},
  author = {Nemec, Devin},
  date = {2022-07-27T21:31:16Z},
  origdate = {2020-08-24T19:25:58Z},
  url = {https://github.com/dmnemec/copy_file_to_another_repo_action},
  urldate = {2022-08-03},
  abstract = {This GitHub Action copies a file from the current repository to a location in another repository},
  keywords = {hacktoberfest}
}

@software{NeovimTreesitterPlayground2022,
  title = {Neovim {{Treesitter Playground}}},
  date = {2022-05-03},
  url = {https://github.com/nvim-treesitter/playground},
  urldate = {2022-05-03},
  abstract = {Treesitter playground integrated into Neovim},
  organization = {nvim-treesitter},
  keywords = {hacktoberfest,neovim,nvim-treesitter,tree-sitter}
}

@online{nevesAnswerWhatSecurity2022,
  title = {Answer to "{{What}} Is the Security of Multiple Encryption Using {{Even}}–{{Mansour}} Scheme ({{XEX}})?"},
  shorttitle = {Answer to "{{What}} Is the Security of Multiple Encryption Using {{Even}}–{{Mansour}} Scheme ({{XEX}})?},
  author = {Neves, Samuel},
  date = {2022-06-15},
  url = {https://crypto.stackexchange.com/a/100601},
  urldate = {2024-06-15},
  organization = {Cryptography Stack Exchange},
  file = {/home/areo/Zotero/storage/SYCZT2VH/what-is-the-security-of-multiple-encryption-using-even-mansour-scheme-xex.html}
}

@online{newbAnswerConditionalStatements2013,
  title = {Answer to "{{Conditional Statements}}: "Only If""},
  shorttitle = {Answer to "{{Conditional Statements}}},
  author = {Newb},
  date = {2013-12-24},
  url = {https://math.stackexchange.com/a/617569},
  urldate = {2023-10-28},
  organization = {Mathematics Stack Exchange},
  file = {/home/areo/Zotero/storage/JXIJ9EZI/conditional-statements-only-if.html}
}

@software{Nvimtreesitter2022,
  title = {Nvim-Treesitter},
  date = {2022-05-03},
  url = {https://github.com/nvim-treesitter/nvim-treesitter},
  urldate = {2022-05-03},
  abstract = {Nvim Treesitter configurations and abstraction layer},
  organization = {nvim-treesitter},
  keywords = {hacktoberfest,neovim,nvim-treesitter,tree-sitter}
}

@book{nystromParsingExpressionsCrafting2021,
  title = {Parsing {{Expressions}} · {{Crafting Interpreters}}},
  author = {Nystrom, Robert},
  date = {2021},
  publisher = {Genever Benning},
  url = {https://www.craftinginterpreters.com/parsing-expressions.html},
  urldate = {2022-07-09}
}

@inreference{Objektcode2019,
  title = {Objektcode},
  booktitle = {Wikipedia},
  date = {2019-11-27T15:00:17Z},
  url = {https://de.wikipedia.org/w/index.php?title=Objektcode&oldid=194427842},
  urldate = {2022-09-13},
  abstract = {Objektcode ist ein Zwischenergebnis eines Compiler- bzw. Übersetzungsvorgangs von einem Computerprogramm.  Einfache Compiler können diesen Schritt überspringen. Der Objektcode besteht hauptsächlich aus Maschinencode für die Architektur, für die das Programm übersetzt wurde. Er enthält üblicherweise kompakten und vorgeparsten Code und oft benutzte Programmbibliotheken, die dann mit anderen Objektdateien gebunden werden. Das Format eines Objektcodes ist abhängig von Programmiersprache, Compiler und der Maschine. Nach dem Erstellen von Objektcode erfolgt normalerweise das Linken, welches als Ergebnis das fertige, ausführbare Programm liefert.},
  langid = {ngerman},
  annotation = {Page Version ID: 194427842},
  file = {/home/areo/Zotero/storage/UVPVKL7H/Objektcode.html}
}

@online{OnlineRechnerBinarInversion,
  title = {Online-{{Rechner}}: {{Binär}}, {{Inversion}} Und {{Komplementcodes}}},
  url = {https://de.planetcalc.com/747/},
  urldate = {2023-06-08},
  file = {/home/areo/Zotero/storage/5E4N28AA/747.html}
}

@online{OnlineRechnerNumerischeKomplemente,
  title = {Online-{{Rechner}}: {{Numerische Komplemente}}},
  url = {https://de.planetcalc.com/8574/},
  urldate = {2023-06-08},
  file = {/home/areo/Zotero/storage/FQM2SGC7/8574.html}
}

@online{ooijenAnswerOneTwo2012,
  title = {Answer to "{{One}} or Two {{UART}} Stop Bits?"},
  shorttitle = {Answer to "{{One}} or Two {{UART}} Stop Bits?},
  author = {family=Ooijen, given=Wouter, prefix=van, useprefix=false},
  date = {2012-04-15},
  url = {https://electronics.stackexchange.com/a/29949},
  urldate = {2022-11-13},
  organization = {Electrical Engineering Stack Exchange},
  file = {/home/areo/Zotero/storage/SGMVPYYS/one-or-two-uart-stop-bits.html}
}

@online{OperatorPrecedenceCppreference,
  title = {C {{Operator Precedence}} - Cppreference.Com},
  url = {https://en.cppreference.com/w/c/language/operator_precedence},
  urldate = {2022-04-27},
  file = {/home/areo/Zotero/storage/6W5H2M4R/operator_precedence.html;/home/areo/Zotero/storage/KAN6J8BH/operator_precedence.html}
}

@inreference{Operatorrangfolge2022,
  title = {Operatorrangfolge},
  booktitle = {Wikipedia},
  date = {2022-05-25T15:01:39Z},
  url = {https://de.wikipedia.org/w/index.php?title=Operatorrangfolge&oldid=223157277},
  urldate = {2022-09-13},
  abstract = {Als Operatorrangfolge, -wertigkeit, -priorität oder -präzedenz bezeichnet man in Mathematik, Logik und Informatik eine definierte Halbordnung, in der die Operatoren eines in Infix-Schreibweise vorliegenden Ausdrucks auszuwerten sind. Die Operatorrangfolge ist keine Totalordnung, sondern eine Halbordnung, weil es keine strikte Reihenfolge zwischen allen Operatoren geben muss. Es können auch mehrere Operatoren auf demselben Rang stehen. Zum Beispiel ist in der Arithmetik der Rang von Multiplikation und Division gleich, aber höher als der Rang von Addition und Subtraktion („Punktrechnung vor Strichrechnung“). Eine Klammerung bietet die Möglichkeit der Bevorrangung eines Teilstücks einer Formel: Der eingeklammerte, also von einem Klammerpaar „( ... )“ eingeschlossene Bereich ist rechnerisch zuerst auszuführen und durch das entsprechende Teilergebnis zu ersetzen. Die Klammerung muss die Operatoren samt ihren nötigen Operanden enthalten. Wird also                         a         ⋅         (         b         +         c         )                 \{\textbackslash displaystyle a\textbackslash cdot (b+c)\}    notiert, ist zuerst der Klammerausdruck zu berechnen, also die Summe                         (         b         +         c         )                 \{\textbackslash displaystyle (b+c)\}    zu bilden, bevor                         a                 \{\textbackslash displaystyle a\}    mit dieser Summe multipliziert wird. Durch die Rangfolge kann man explizite Klammerungen sparen. So ist in der Arithmetik                         a         +         b         ⋅         c                 \{\textbackslash displaystyle a+b\textbackslash cdot c\}    gleichbedeutend mit                         a         +         (         b         ⋅         c         )                 \{\textbackslash displaystyle a+(b\textbackslash cdot c)\}   , weil der Multiplikationsoperator einen höheren Rang hat. Für andere Anwendungen dieser Operatorsymbole können jedoch andere Rangordnungen definiert sein. Bei nicht kommutativen Operatoren bedarf es noch zusätzlicher Konvention darüber, ob gleichrangige Teilausdrücke von links nach rechts oder rechts nach links auszuwerten sind, um die Rechenreihenfolge eindeutig festzulegen.},
  langid = {ngerman},
  annotation = {Page Version ID: 223157277},
  file = {/home/areo/Zotero/storage/C53528ND/Operatorrangfolge.html}
}

@inreference{Operatorrangfolge2022a,
  title = {Operatorrangfolge},
  booktitle = {Wikipedia},
  date = {2022-05-25T15:01:39Z},
  url = {https://de.wikipedia.org/w/index.php?title=Operatorrangfolge&oldid=223157277},
  urldate = {2022-09-13},
  abstract = {Als Operatorrangfolge, -wertigkeit, -priorität oder -präzedenz bezeichnet man in Mathematik, Logik und Informatik eine definierte Halbordnung, in der die Operatoren eines in Infix-Schreibweise vorliegenden Ausdrucks auszuwerten sind. Die Operatorrangfolge ist keine Totalordnung, sondern eine Halbordnung, weil es keine strikte Reihenfolge zwischen allen Operatoren geben muss. Es können auch mehrere Operatoren auf demselben Rang stehen. Zum Beispiel ist in der Arithmetik der Rang von Multiplikation und Division gleich, aber höher als der Rang von Addition und Subtraktion („Punktrechnung vor Strichrechnung“). Eine Klammerung bietet die Möglichkeit der Bevorrangung eines Teilstücks einer Formel: Der eingeklammerte, also von einem Klammerpaar „( ... )“ eingeschlossene Bereich ist rechnerisch zuerst auszuführen und durch das entsprechende Teilergebnis zu ersetzen. Die Klammerung muss die Operatoren samt ihren nötigen Operanden enthalten. Wird also                         a         ⋅         (         b         +         c         )                 \{\textbackslash displaystyle a\textbackslash cdot (b+c)\}    notiert, ist zuerst der Klammerausdruck zu berechnen, also die Summe                         (         b         +         c         )                 \{\textbackslash displaystyle (b+c)\}    zu bilden, bevor                         a                 \{\textbackslash displaystyle a\}    mit dieser Summe multipliziert wird. Durch die Rangfolge kann man explizite Klammerungen sparen. So ist in der Arithmetik                         a         +         b         ⋅         c                 \{\textbackslash displaystyle a+b\textbackslash cdot c\}    gleichbedeutend mit                         a         +         (         b         ⋅         c         )                 \{\textbackslash displaystyle a+(b\textbackslash cdot c)\}   , weil der Multiplikationsoperator einen höheren Rang hat. Für andere Anwendungen dieser Operatorsymbole können jedoch andere Rangordnungen definiert sein. Bei nicht kommutativen Operatoren bedarf es noch zusätzlicher Konvention darüber, ob gleichrangige Teilausdrücke von links nach rechts oder rechts nach links auszuwerten sind, um die Rechenreihenfolge eindeutig festzulegen.},
  langid = {ngerman},
  annotation = {Page Version ID: 223157277},
  file = {/home/areo/Zotero/storage/B78Y6N4N/Operatorrangfolge.html}
}

@online{otusAnswerWhyDoes2014,
  title = {Answer to "{{Why}} Does {{PBKDF2}} Xor the Iterations of the Hash Function Together?"},
  shorttitle = {Answer to "{{Why}} Does {{PBKDF2}} Xor the Iterations of the Hash Function Together?},
  author = {{otus}},
  date = {2014-06-10},
  url = {https://crypto.stackexchange.com/a/17644},
  urldate = {2024-05-25},
  organization = {Cryptography Stack Exchange},
  file = {/home/areo/Zotero/storage/C4DQG9IL/why-does-pbkdf2-xor-the-iterations-of-the-hash-function-together.html}
}

@online{palswimAnswerCreateCustom2019,
  title = {Answer to "{{Create}} a Custom {{URL Protocol Handler}}"},
  author = {{palswim}},
  date = {2019-01-28},
  url = {https://unix.stackexchange.com/a/497147},
  urldate = {2023-11-05},
  organization = {Unix \& Linux Stack Exchange}
}

@book{parrLanguageImplementationPatterns2009,
  title = {Language {{Implementation Patterns}}: {{Create Your Own Domain-Specific}} and {{General Programming Languages}}},
  shorttitle = {Language {{Implementation Patterns}}},
  author = {Parr, Terence},
  date = {2009-12-31},
  publisher = {Pragmatic Bookshelf},
  abstract = {Learn to build configuration file readers, data readers, model-driven code generators, source-to-source translators, source analyzers, and interpreters. You don't need a background in computer science–ANTLR creator Terence Parr demystifies language implementation by breaking it down into the most common design patterns. Pattern by pattern, you'll learn the key skills you need to implement your own computer languages.Knowing how to create domain-specific languages (DSLs) can give you a huge productivity boost. Instead of writing code in a general-purpose programming language, you can first build a custom language tailored to make you efficient in a particular domain.The key is understanding the common patterns found across language implementations. Language Design Patterns identifies and condenses the most common design patterns, providing sample implementations of each.The pattern implementations use Java, but the patterns themselves are completely general. Some of the implementations use the well-known ANTLR parser generator, so readers will find this book an excellent source of ANTLR examples as well. But this book will benefit anyone interested in implementing languages, regardless of their tool of choice. Other language implementation books focus on compilers, which you rarely need in your daily life. Instead, Language Design Patterns shows you patterns you can use for all kinds of language applications.You'll learn to create configuration file readers, data readers, model-driven code generators, source-to-source translators, source analyzers, and interpreters. Each chapter groups related design patterns and, in each pattern, you'll get hands-on experience by building a complete sample implementation. By the time you finish the book, you'll know how to solve most common language implementation problems.},
  isbn = {978-1-68050-374-6},
  pagetotal = {456},
  keywords = {Computers / General,Computers / Programming / Compilers,Computers / Programming / General,Computers / Software Development & Engineering / General}
}

@inreference{Parser2022,
  title = {Parser},
  booktitle = {Wikipedia},
  date = {2022-09-08T10:15:27Z},
  url = {https://de.wikipedia.org/w/index.php?title=Parser&oldid=225991691},
  urldate = {2022-09-13},
  abstract = {Ein Parser [ˈpɑːʁzɐ] (englisch to parse, „analysieren“, bzw. lateinisch pars, „Teil“; im Deutschen gelegentlich auch Zerteiler) ist ein Computerprogramm, das in der Informatik für die Zerlegung und Umwandlung einer Eingabe in ein für die Weiterverarbeitung geeigneteres Format zuständig ist. Häufig werden Parser eingesetzt, um im Anschluss an den Analysevorgang die Semantik der Eingabe zu erschließen und daraufhin Aktionen durchzuführen. Im Vergleich zu einem Recognizer, der die Eingabe analysiert und ausgibt, ob diese im Sinne der Vorgaben richtig oder falsch ist, gibt der Parser die Analyse einer Eingabe in einer gewünschten Form aus und erzeugt zusätzlich Strukturbeschreibungen. Die Syntaxanalyse (Parsing) findet auch außerhalb der Informatik Anwendung, z. B. bei der Untersuchung der Struktur von natürlichen Sprachen. In der Grammatik würde die Syntaxanalyse eines Satzes dem Zerlegen des Satzes in seine grammatikalischen Bestandteile (Syntax) entsprechen. Siehe dazu Linguistik.},
  langid = {ngerman},
  annotation = {Page Version ID: 225991691},
  file = {/home/areo/Zotero/storage/JWL9W3GV/Parser.html}
}

@online{ParsersLarkDocumentation,
  title = {Parsers — {{Lark}} Documentation},
  url = {https://lark-parser.readthedocs.io/en/latest/parsers.html},
  urldate = {2022-06-20},
  file = {/home/areo/Zotero/storage/7NQDT5BF/parsers.html}
}

@online{PasswordStrength,
  title = {Password {{Strength}}},
  url = {https://xkcd.com/936/},
  urldate = {2024-06-19},
  organization = {xkcd},
  file = {/home/areo/Zotero/storage/2BXI4ZUV/936.html}
}

@online{PEP20Zen,
  title = {{{PEP}} 20 – {{The Zen}} of {{Python}} \textbackslash textbar Peps.Python.Org},
  url = {https://peps.python.org/pep-0020/#id3},
  urldate = {2022-04-13},
  file = {/home/areo/Zotero/storage/56SF22DD/pep-0020.html}
}

@online{PEP20Zena,
  title = {{{PEP}} 20 – {{The Zen}} of {{Python}} \textbackslash textbackslashtextbar Peps.Python.Org},
  url = {https://peps.python.org/pep-0020/#id3},
  urldate = {2022-04-13},
  file = {/home/areo/Zotero/storage/I27S9G7L/pep-0020.html}
}

@misc{percival2009stronger,
  title = {Stronger Key Derivation via Sequential Memory-Hard Functions},
  author = {Percival, Colin},
  date = {2009},
  organization = {BSDCan}
}

@online{peregrinusAnswerAESXTS2019,
  title = {Answer to "{{Is AES}} in {{XTS}} Mode Insecure for Data Stream Encryption?"},
  shorttitle = {Answer to "{{Is AES}} in {{XTS}} Mode Insecure for Data Stream Encryption?},
  author = {Peregrinus, S. A. I.},
  date = {2019-09-17},
  url = {https://crypto.stackexchange.com/a/74353},
  urldate = {2024-05-30},
  organization = {Cryptography Stack Exchange},
  file = {/home/areo/Zotero/storage/HZLCXNJ4/is-aes-in-xts-mode-insecure-for-data-stream-encryption.html}
}

@inreference{PipesUndFilter2021,
  title = {Pipes und Filter},
  booktitle = {Wikipedia},
  date = {2021-06-18T19:11:59Z},
  url = {https://de.wikipedia.org/w/index.php?title=Pipes_und_Filter&oldid=213086457},
  urldate = {2022-09-04},
  abstract = {Pipes und Filter (engl. pipes-and-filters, auch Datenfluss-System) ist ein Architekturmuster aus dem Bereich der Softwareentwicklung. Es beschreibt die Struktur für Systeme, die Datenströme verarbeiten.},
  langid = {ngerman},
  annotation = {Page Version ID: 213086457}
}

@inreference{PipesUndFilter2021a,
  title = {Pipes und Filter},
  booktitle = {Wikipedia},
  date = {2021-06-18T19:11:59Z},
  url = {https://de.wikipedia.org/w/index.php?title=Pipes_und_Filter&oldid=213086457},
  urldate = {2022-09-13},
  abstract = {Pipes und Filter (engl. pipes-and-filters, auch Datenfluss-System) ist ein Architekturmuster aus dem Bereich der Softwareentwicklung. Es beschreibt die Struktur für Systeme, die Datenströme verarbeiten.},
  langid = {ngerman},
  annotation = {Page Version ID: 213086457},
  file = {/home/areo/Zotero/storage/UKX32EXP/Pipes_und_Filter.html}
}

@online{pixelomoAnswerHowCan2018,
  title = {Answer to "{{How}} Can {{I}} Switch Word Wrap on and off in {{Visual Studio Code}}?"},
  shorttitle = {Answer to "{{How}} Can {{I}} Switch Word Wrap on and off in {{Visual Studio Code}}?},
  author = {Pixelomo},
  date = {2018-03-01},
  url = {https://stackoverflow.com/a/49042031},
  urldate = {2024-01-01},
  organization = {Stack Overflow},
  file = {/home/areo/Zotero/storage/2KMTTGV4/how-can-i-switch-word-wrap-on-and-off-in-visual-studio-code.html}
}

@online{PlocateMuchFaster,
  title = {Plocate, a Much Faster Locate},
  url = {https://plocate.sesse.net/},
  urldate = {2023-11-15},
  file = {/home/areo/Zotero/storage/JK5ZCBMP/plocate.sesse.net.html}
}

@online{portellaConfiguringVSCodeWork2020,
  title = {Configuring {{VSCode}} to Work with {{Minted}} ({{LaTeX}})},
  author = {Portella, Leticia},
  date = {2020-09-15},
  url = {https://leportella.com/minted-vscode/},
  urldate = {2024-01-01},
  abstract = {I was handling some LaTeX files and I needed code coloring. I found the package minted and it seemed perfect, but it required a couple of things that made my life a bit more complicated on VSCode.},
  langid = {english},
  file = {/home/areo/Zotero/storage/CXZQ3L5I/minted-vscode.html}
}

@inreference{ProzeduraleProgrammierung2021,
  title = {Prozedurale Programmierung},
  booktitle = {Wikipedia},
  date = {2021-07-19T15:14:16Z},
  url = {https://de.wikipedia.org/w/index.php?title=Prozedurale_Programmierung&oldid=214023278},
  urldate = {2022-09-13},
  abstract = {Prozedurale Programmierung ist ein Programmierparadigma, nach dem Computerprogramme entwickelt werden können. Die Bezeichnung ist nicht eindeutig; in der Literatur wird sie für verschiedene Bedeutungen verwendet: als Erweiterung des imperativen Paradigmas um den Ansatz, Algorithmen in überschaubare Teile zu zerlegen, die anhand einer definierten Schnittstelle aufrufbar sind. innerhalb des imperativen Paradigmas als Gegenstück zur objektorientierten ProgrammierungVereinzelt wird prozedurale Programmierung auch als Synonym zur imperativen Programmierung an sich oder zur strukturierten Programmierung verstanden.},
  langid = {ngerman},
  annotation = {Page Version ID: 214023278},
  file = {/home/areo/Zotero/storage/3TI9BRLI/Prozedurale_Programmierung.html}
}

@online{Pseudocode2023,
  title = {Pseudocode},
  date = {2023-05-30T21:14:02Z},
  origdate = {2016-03-09T05:32:33Z},
  url = {https://github.com/aimacode/aima-pseudocode},
  urldate = {2023-06-04},
  abstract = {Pseudocode descriptions of the algorithms from Russell And Norvig's "Artificial Intelligence - A Modern Approach"}
}

@article{PublicCommentsXTSAES,
  title = {Public {{Comments}} on the {{XTS-AES Mode}}},
  langid = {english},
  file = {/home/areo/Zotero/storage/SDTQKUX8/Public Comments on the XTS-AES Mode.pdf}
}

@online{PubliclyAvailableStandards,
  title = {Publicly {{Available Standards}}},
  url = {https://standards.iso.org/ittf/PubliclyAvailableStandards/},
  urldate = {2022-07-31},
  file = {/home/areo/Zotero/storage/T5PD2E7F/PubliclyAvailableStandards.html}
}

@online{pulpspyAnswerWhyMixColumns2011,
  title = {Answer to "{{Why}} Is {{MixColumns}} Omitted from the Last Round of {{AES}}?"},
  shorttitle = {Answer to "{{Why}} Is {{MixColumns}} Omitted from the Last Round of {{AES}}?},
  author = {PulpSpy},
  date = {2011-11-29},
  url = {https://crypto.stackexchange.com/a/1359},
  urldate = {2023-11-03},
  organization = {Cryptography Stack Exchange},
  file = {/home/areo/Zotero/storage/HPK9ZTRT/why-is-mixcolumns-omitted-from-the-last-round-of-aes.html}
}

@software{PyInstallerOverview2022,
  title = {{{PyInstaller Overview}}},
  date = {2022-01-28},
  url = {https://github.com/pyinstaller/pyinstaller},
  urldate = {2022-01-28},
  abstract = {Freeze (package) Python programs into stand-alone executables},
  organization = {PyInstaller},
  keywords = {bundle,package,py2app,py2exe,pyinstaller,python,python-3,python-to-exe}
}

@online{QualifiersSizeSign2020,
  title = {Qualifiers in {{C}} [ {{Size}}, {{Sign}} and {{Type Qualifiers}} in {{Detail}} ]},
  date = {2020-05-18},
  url = {https://learnprogramo.com/qualifiers-in-c-9/},
  urldate = {2022-04-13},
  abstract = {Qualifiers in C. The Qualifiers are the keywords which are applied to the data types. There are three types of qualifiers in C. 1.Type Qualifiers 2.Size Qua},
  file = {/home/areo/Zotero/storage/9HMPRTT2/qualifiers-in-c-9.html;/home/areo/Zotero/storage/P2SCX2H7/qualifiers-in-c-9.html}
}

@online{rankinAnswerHowDelete2010,
  title = {Answer to "{{How}} Do {{I}} Delete a {{Git}} Branch Locally and Remotely?"},
  shorttitle = {Answer to "{{How}} Do {{I}} Delete a {{Git}} Branch Locally and Remotely?},
  author = {Rankin, Matthew},
  date = {2010-01-05},
  url = {https://stackoverflow.com/a/2003515},
  urldate = {2023-11-21},
  organization = {Stack Overflow},
  file = {/home/areo/Zotero/storage/FI8AGBDS/how-do-i-delete-a-git-branch-locally-and-remotely.html}
}

@online{rankinAnswerHowDelete2010a,
  title = {Answer to "{{How}} Do {{I}} Delete a {{Git}} Branch Locally and Remotely?"},
  shorttitle = {Answer to "{{How}} Do {{I}} Delete a {{Git}} Branch Locally and Remotely?},
  author = {Rankin, Matthew},
  date = {2010-01-05},
  url = {https://stackoverflow.com/a/2003515},
  urldate = {2023-11-21},
  organization = {Stack Overflow},
  file = {/home/areo/Zotero/storage/CL666T8F/how-do-i-delete-a-git-branch-locally-and-remotely.html}
}

@online{rankinAnswerHowDelete2010b,
  title = {Answer to "{{How}} Do {{I}} Delete a {{Git}} Branch Locally and Remotely?"},
  shorttitle = {Answer to "{{How}} Do {{I}} Delete a {{Git}} Branch Locally and Remotely?},
  author = {Rankin, Matthew},
  date = {2010-01-05},
  url = {https://stackoverflow.com/a/2003515},
  urldate = {2023-11-21},
  organization = {Stack Overflow},
  file = {/home/areo/Zotero/storage/VVVZEJC6/how-do-i-delete-a-git-branch-locally-and-remotely.html}
}

@online{ravskyAnswerRelationIndependent2017,
  title = {Answer to "{{Relation}} between Independent Sets and Covers"},
  author = {Ravsky, Alex},
  date = {2017-11-24},
  url = {https://math.stackexchange.com/a/2534793},
  urldate = {2023-09-06},
  organization = {Mathematics Stack Exchange},
  file = {/home/areo/Zotero/storage/5FELBNM9/relation-between-independent-sets-and-covers.html}
}

@inreference{Recognizer2021,
  title = {Recognizer},
  booktitle = {Wikipedia},
  date = {2021-10-17T08:51:42Z},
  url = {https://de.wikipedia.org/w/index.php?title=Recognizer&oldid=216435306},
  urldate = {2022-09-13},
  abstract = {Ein Recognizer (engl. to recognize: „erkennen“), auch Erkenner, ist in der Informatik ein bestimmtes abstraktes Maschinenmodell, ein sogenannter Automat. Dieser Automat stellt auf Grundlage einer formalen Grammatik fest, ob ein konkretes Wort Element einer formalen Sprache ist oder nicht. Die Sprache wird dabei durch die zugrundegelegte formale Grammatik definiert bzw. erzeugt. Der Recognizer entscheidet nur, ob ein Eingabetext hinsichtlich der Vorgaben „richtig“ oder „falsch“ ist; das unterscheidet ihn von einem Parser, der zusätzlich die analysierte grammatikalische Struktur beschreiben und ausgeben kann. Ein typisches Beispiel für einen Recognizer in der Automatentheorie ist der Kellerautomat.},
  langid = {ngerman},
  annotation = {Page Version ID: 216435306},
  file = {/home/areo/Zotero/storage/S2HXFXBE/Recognizer.html}
}

@inreference{RegisterAllocation2022,
  title = {Register Allocation},
  booktitle = {Wikipedia},
  date = {2022-08-16T21:22:05Z},
  url = {https://en.wikipedia.org/w/index.php?title=Register_allocation&oldid=1104778380},
  urldate = {2022-09-13},
  abstract = {In compiler optimization, register allocation is the process of assigning local automatic variables and expression results to a limited number of processor registers. Register allocation can happen over a basic block (local register allocation), over a whole function/procedure (global register allocation), or across function boundaries traversed via call-graph (interprocedural register allocation). When done per function/procedure the calling convention may require insertion of save/restore around each call-site.},
  langid = {english},
  annotation = {Page Version ID: 1104778380},
  file = {/home/areo/Zotero/storage/F3FD5DMZ/Register_allocation.html}
}

@online{RegisteredCategories,
  title = {A.~{{Registered Categories}}},
  url = {https://specifications.freedesktop.org/menu-spec/latest/apa.html},
  urldate = {2023-11-05},
  file = {/home/areo/Zotero/storage/TE3EL4KX/apa.html}
}

@inreference{RegulaereGrammatik2021,
  title = {Reguläre Grammatik},
  booktitle = {Wikipedia},
  date = {2021-04-03T13:39:14Z},
  url = {https://de.wikipedia.org/w/index.php?title=Regul%C3%A4re_Grammatik&oldid=210508085},
  urldate = {2022-09-13},
  abstract = {Eine reguläre Grammatik ist in der Informatik eine formale Grammatik vom Typ 3 der Chomsky-Hierarchie. Die von solchen Grammatiken erzeugten Sprachen heißen reguläre Sprachen.},
  langid = {ngerman},
  annotation = {Page Version ID: 210508085}
}

@software{reinhartJonathonReinhartStaticx2022,
  title = {{{JonathonReinhart}}/Staticx},
  author = {Reinhart, Jonathon},
  date = {2022-01-23},
  url = {https://github.com/JonathonReinhart/staticx},
  urldate = {2022-01-28},
  abstract = {Create static executable from dynamic executable}
}

@inreference{RekursiverAbstieg2021,
  title = {Rekursiver Abstieg},
  booktitle = {Wikipedia},
  date = {2021-11-08T16:36:18Z},
  url = {https://de.wikipedia.org/w/index.php?title=Rekursiver_Abstieg&oldid=217102237},
  urldate = {2022-09-13},
  abstract = {Rekursiver Abstieg (englisch: recursive descent) ist eine Technik aus dem Compilerbau, die auf direkte Weise (d. h. ohne Tabelle) einen Top-Down-Parser implementiert. Sie zeichnet sich durch geringe Komplexität aus, das Verwenden eines Parsergenerators ist nicht nötig. Bei diesem Verfahren kommt jedem Nichtterminalsymbol eine Prozedur zu, welche die Produktionsregel zu diesem Symbol charakterisiert. Erlauben die Produktionsregeln eine Rekursion, dann rufen sich daher auch diese Prozeduren wechselseitig rekursiv auf. Ein rekursiver Abstieg kann Backtracking enthalten. Ein Verzicht darauf ist jedoch garantiert, wenn eine LL(k)-Grammatik für die zu parsende Sprache gegeben ist. Im Folgenden wird der häufige Fall                         k         =         1                 \{\textbackslash displaystyle k=1\}    angenommen.},
  langid = {ngerman},
  annotation = {Page Version ID: 217102237},
  file = {/home/areo/Zotero/storage/2R84VDHK/Rekursiver_Abstieg.html}
}

@online{ReleasesJgraphDrawiodesktop2022,
  title = {Releases · Jgraph/Drawio-Desktop},
  date = {2022-01-28},
  url = {https://github.com/jgraph/drawio-desktop/releases},
  urldate = {2022-01-28},
  abstract = {Official electron build of diagrams.net. Contribute to jgraph/drawio-desktop development by creating an account on GitHub.}
}

@incollection{rogawayEfficientInstantiationsTweakable2004,
  title = {Efficient {{Instantiations}} of {{Tweakable Blockciphers}} and {{Refinements}} to {{Modes OCB}} and {{PMAC}}},
  booktitle = {Advances in {{Cryptology}} - {{ASIACRYPT}} 2004},
  author = {Rogaway, Phillip},
  editor = {Lee, Pil Joong},
  editora = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard},
  editoratype = {redactor},
  date = {2004},
  volume = {3329},
  pages = {16--31},
  publisher = {Springer Berlin Heidelberg},
  location = {Berlin, Heidelberg},
  doi = {10.1007/978-3-540-30539-2_2},
  url = {http://link.springer.com/10.1007/978-3-540-30539-2_2},
  urldate = {2024-05-30},
  abstract = {We describe highly efficient constructions, XE and XEX, that turn a blockcipher E: K × \{0, 1\}n → \{0, 1\}n into a tweakable blockcipher E: K × T × \{0, 1\}n → \{0, 1\}n having tweak space T = \{0, 1\}n × I where I is a set of tuples of integers such as I = [1 .. 2n/2] × [0 .. 10]. When tweak T is obtained from tweak S by incrementing one if its numerical components, the cost to compute EKT (M ) having already computed some EKS (M ) is one blockcipher call plus a small and constant number of elementary machine operations. Our constructions work by associating to the ith coordinate of I an element αi ∈ F∗2n and multiplying by αi when one increments that component of the tweak. We illustrate the use of this approach by refining the authenticatedencryption scheme OCB and the message authentication code PMAC, yielding variants of these algorithms that are simpler and faster than the original schemes, and yet have simpler proofs. Our results bolster the thesis of Liskov, Rivest, and Wagner [11] that a desirable approach for designing modes of operation is to start from a tweakable blockcipher. We elaborate on their idea, suggesting the kind of tweak space, usage-discipline, and blockcipher-based instantiations that give rise to simple and efficient modes.},
  isbn = {978-3-540-23975-8 978-3-540-30539-2},
  langid = {english},
  file = {/home/areo/Zotero/storage/PUSSIHYQ/Rogaway - 2004 - Efficient Instantiations of Tweakable Blockciphers.pdf}
}

@incollection{rogawayEfficientInstantiationsTweakable2004a,
  title = {Efficient {{Instantiations}} of {{Tweakable Blockciphers}} and {{Refinements}} to {{Modes OCB}} and {{PMAC}}},
  booktitle = {Advances in {{Cryptology}} - {{ASIACRYPT}} 2004},
  author = {Rogaway, Phillip},
  editor = {Lee, Pil Joong},
  editora = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard},
  editoratype = {redactor},
  date = {2004},
  volume = {3329},
  pages = {16--31},
  publisher = {Springer Berlin Heidelberg},
  location = {Berlin, Heidelberg},
  doi = {10.1007/978-3-540-30539-2_2},
  url = {http://link.springer.com/10.1007/978-3-540-30539-2_2},
  urldate = {2024-05-30},
  abstract = {We describe highly efficient constructions, XE and XEX, that turn a blockcipher E: K × \{0, 1\}n → \{0, 1\}n into a tweakable blockcipher E: K × T × \{0, 1\}n → \{0, 1\}n having tweak space T = \{0, 1\}n × I where I is a set of tuples of integers such as I = [1 .. 2n/2] × [0 .. 10]. When tweak T is obtained from tweak S by incrementing one if its numerical components, the cost to compute EKT (M ) having already computed some EKS (M ) is one blockcipher call plus a small and constant number of elementary machine operations. Our constructions work by associating to the ith coordinate of I an element αi ∈ F∗2n and multiplying by αi when one increments that component of the tweak. We illustrate the use of this approach by refining the authenticatedencryption scheme OCB and the message authentication code PMAC, yielding variants of these algorithms that are simpler and faster than the original schemes, and yet have simpler proofs. Our results bolster the thesis of Liskov, Rivest, and Wagner [11] that a desirable approach for designing modes of operation is to start from a tweakable blockcipher. We elaborate on their idea, suggesting the kind of tweak space, usage-discipline, and blockcipher-based instantiations that give rise to simple and efficient modes.},
  isbn = {978-3-540-23975-8 978-3-540-30539-2},
  langid = {english},
  file = {/home/areo/Zotero/storage/W9SVRZ2N/Rogaway - 2004 - Efficient Instantiations of Tweakable Blockciphers.pdf}
}

@incollection{rogawayEfficientInstantiationsTweakable2004b,
  title = {Efficient {{Instantiations}} of {{Tweakable Blockciphers}} and {{Refinements}} to {{Modes OCB}} and {{PMAC}}},
  booktitle = {Advances in {{Cryptology}} - {{ASIACRYPT}} 2004},
  author = {Rogaway, Phillip},
  editor = {Lee, Pil Joong},
  editora = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard},
  editoratype = {redactor},
  date = {2004},
  volume = {3329},
  pages = {16--31},
  publisher = {Springer Berlin Heidelberg},
  location = {Berlin, Heidelberg},
  doi = {10.1007/978-3-540-30539-2_2},
  url = {http://link.springer.com/10.1007/978-3-540-30539-2_2},
  urldate = {2024-06-26},
  abstract = {We describe highly efficient constructions, XE and XEX, that turn a blockcipher E: K × \{0, 1\}n → \{0, 1\}n into a tweakable blockcipher E: K × T × \{0, 1\}n → \{0, 1\}n having tweak space T = \{0, 1\}n × I where I is a set of tuples of integers such as I = [1 .. 2n/2] × [0 .. 10]. When tweak T is obtained from tweak S by incrementing one if its numerical components, the cost to compute EKT (M ) having already computed some EKS (M ) is one blockcipher call plus a small and constant number of elementary machine operations. Our constructions work by associating to the ith coordinate of I an element αi ∈ F∗2n and multiplying by αi when one increments that component of the tweak. We illustrate the use of this approach by refining the authenticatedencryption scheme OCB and the message authentication code PMAC, yielding variants of these algorithms that are simpler and faster than the original schemes, and yet have simpler proofs. Our results bolster the thesis of Liskov, Rivest, and Wagner [11] that a desirable approach for designing modes of operation is to start from a tweakable blockcipher. We elaborate on their idea, suggesting the kind of tweak space, usage-discipline, and blockcipher-based instantiations that give rise to simple and efficient modes.},
  isbn = {978-3-540-23975-8 978-3-540-30539-2},
  langid = {english},
  file = {/home/areo/Zotero/storage/JEQ4P9D2/Rogaway - 2004 - Efficient Instantiations of Tweakable Blockciphers.pdf}
}

@article{rogawayEvaluationBlockcipherModes,
  title = {Evaluation of {{Some Blockcipher Modes}} of {{Operation}}},
  author = {Rogaway, Phillip},
  langid = {english},
  file = {/home/areo/Zotero/storage/33C33X8K/Rogaway - Evaluation of Some Blockcipher Modes of Operation.pdf}
}

@incollection{rogawaySecurityCiphertextStealing2012,
  title = {The {{Security}} of {{Ciphertext Stealing}}},
  booktitle = {Fast {{Software Encryption}}},
  author = {Rogaway, Phillip and Wooding, Mark and Zhang, Haibin},
  editor = {Canteaut, Anne},
  date = {2012},
  volume = {7549},
  pages = {180--195},
  publisher = {Springer Berlin Heidelberg},
  location = {Berlin, Heidelberg},
  doi = {10.1007/978-3-642-34047-5_11},
  url = {http://link.springer.com/10.1007/978-3-642-34047-5_11},
  urldate = {2024-05-30},
  isbn = {978-3-642-34046-8 978-3-642-34047-5},
  langid = {english},
  file = {/home/areo/Zotero/storage/N68DBXC3/Rogaway et al. - 2012 - The Security of Ciphertext Stealing.pdf}
}

@artwork{rootofalllightEnglishIlluminati2022,
  title = {English:  {{Illuminati}}},
  shorttitle = {English},
  author = {{RootOfAllLight}},
  date = {2022-03-09},
  url = {https://commons.wikimedia.org/wiki/File:Illuminati-Logo.svg},
  urldate = {2024-05-26},
  file = {/home/areo/Zotero/storage/B3XD3E5X/FileIlluminati-Logo.html}
}

@artwork{rumpelstilzchen666RusskiyPrimerKak2022,
  title = {Random {{Penguin}}},
  shorttitle = {Русский},
  author = {{Rumpelstilzchen 666}},
  date = {2022-11-17},
  url = {https://commons.wikimedia.org/wiki/File:Tux_secure.png},
  urldate = {2024-05-22}
}

@online{RunningBashScript2020,
  title = {Running a Bash Script - {{Code}} to {{Cloud}} / {{GitHub Actions}}},
  date = {2020-11-04},
  url = {https://github.community/t/running-a-bash-script/141584/2},
  urldate = {2022-04-11},
  abstract = {With that setup the path to the script is relative to the root of your repository, so if your script is .github/script.sh that’s all that’s needed in the run step. Remember that the file must be marked as executable, or you need to explicitly call bash with the script as parameter.},
  file = {/home/areo/Zotero/storage/H466UYLR/2.html;/home/areo/Zotero/storage/X9VD8GKM/2.html}
}

@book{russell2010artificial,
  title = {Artificial Intelligence a Modern Approach},
  author = {Russell, Stuart J},
  date = {2010},
  publisher = {Pearson Education, Inc.}
}

@unpublished{schollBetriebssysteme2020,
  type = {Vorlesung},
  title = {Betriebssysteme},
  author = {Scholl, Christoph},
  date = {2020},
  url = {https://abs.informatik.uni-freiburg.de/src/teach_main.php?id=157},
  urldate = {2022-07-09},
  langid = {ngerman},
  venue = {Universität Freiburg}
}

@unpublished{schollEinfuhrungEmbeddedSystems2021,
  type = {Vorlesung},
  title = {Einführung in Embedded Systems},
  author = {Scholl, Philipp},
  date = {2021},
  url = {https://earth.informatik.uni-freiburg.de/uploads/es-2122/},
  urldate = {2022-07-09},
  langid = {Englisch},
  venue = {Universität Freiburg}
}

@unpublished{schollTechnischeInformatik2022,
  type = {Vorlesung},
  title = {Technische Informatik},
  author = {Scholl, Christoph},
  date = {2022-03-08},
  langid = {ngerman},
  venue = {Universität Freiburg}
}

@online{securityAnswerXTSMode2018,
  title = {Answer to "{{XTS}} Mode with the Tweak Key as the Sole Secret"},
  author = {Security, Future},
  date = {2018-06-27},
  url = {https://crypto.stackexchange.com/a/60345},
  urldate = {2024-06-15},
  organization = {Cryptography Stack Exchange},
  file = {/home/areo/Zotero/storage/HQREBQKZ/xts-mode-with-the-tweak-key-as-the-sole-secret.html}
}

@online{sejpmAnswerWhyDoes2020,
  title = {Answer to "{{Why}} Does {{PBKDF2}} Use {{HMAC}}?"},
  shorttitle = {Answer to "{{Why}} Does {{PBKDF2}} Use {{HMAC}}?},
  author = {SEJPM},
  date = {2020-09-25},
  url = {https://crypto.stackexchange.com/a/84163},
  urldate = {2024-06-30},
  organization = {Cryptography Stack Exchange},
  file = {/home/areo/Zotero/storage/I8R5FC9Q/why-does-pbkdf2-use-hmac.html}
}

@online{sejpmAnswerWhyDoes2020a,
  title = {Answer to "{{Why}} Does {{PBKDF2}} Use {{HMAC}}?"},
  shorttitle = {Answer to "{{Why}} Does {{PBKDF2}} Use {{HMAC}}?},
  author = {SEJPM},
  date = {2020-09-25},
  url = {https://crypto.stackexchange.com/a/84163},
  urldate = {2024-06-30},
  organization = {Cryptography Stack Exchange},
  file = {/home/areo/Zotero/storage/44NL6JLD/why-does-pbkdf2-use-hmac.html}
}

@inreference{Semantik2022,
  title = {Semantik},
  booktitle = {Wikipedia},
  date = {2022-08-18T08:31:25Z},
  url = {https://de.wikipedia.org/w/index.php?title=Semantik&oldid=225429979},
  urldate = {2022-09-13},
  abstract = {Semantik (von altgriechisch σημαίνειν sēmaínein, deutsch ‚bezeichnen, ein Zeichen geben‘), auch Bedeutungslehre, ist eine der drei Disziplinen der Semiotik, der wissenschaftlichen Betrachtung von Zeichen. Die Semantik behandelt die verschiedenen Beziehungen zwischen Zeichen und Bezeichnetem, vor allem für sprachliche Zeichen. Mit dieser Einschränkung ist sie Teil der Linguistik, aber sie kann sich auch mit Zeichen und Symbolen aller Art, etwa auch von Artefakten oder Kunstwerken befassen. Innerhalb der Semiotik hat abgrenzend die Syntaktik die interne Struktur sprachlicher und anderer Zeichensysteme zum Gegenstand und die Pragmatik ist die Theorie der Zeichenverwendung. Eine klaren Abgrenzung ist aus verschiedenen Gründen umstritten. Allgemein ist die Semantik die Wissenschaft der Bedeutung. Die exakte Fixierung einer Bedeutung insbesondere von Sätzen, Satzteilen, Wörtern oder Wortteilen natürlicher oder formaler Sprachen ist Gegenstand der formalen Semantik.},
  langid = {ngerman},
  annotation = {Page Version ID: 225429979},
  file = {/home/areo/Zotero/storage/CCLDFT3I/Semantik.html}
}

@online{sequeiraAttackAESOmission,
  title = {Attack on {{AES}}: {{Omission}} of {{MixColumns}}},
  shorttitle = {Attack on {{AES}}},
  author = {Sequeira, Luis},
  url = {https://www.telecomsharing.com/en/laboratory/results/item/68-attack-on-aes-omission-of-mixcolumns},
  urldate = {2023-11-03},
  abstract = {A recent study by Orr Dunkelman and Nathan Keller shows that security can be compromised by the omission of such transformation. The results show that in the case of the analysis by omitting MixColumns, the algorithm complexity is reduced by a factor of 2\textasciicircum 16.},
  langid = {british},
  file = {/home/areo/Zotero/storage/2NUKU6AX/68-attack-on-aes-omission-of-mixcolumns.html}
}

@online{sethAnswerWhatBenefit2015,
  title = {Answer to "{{What}} Is the Benefit of Applying the Tweak a Second Time Using {{XTS}}?"},
  shorttitle = {Answer to "{{What}} Is the Benefit of Applying the Tweak a Second Time Using {{XTS}}?},
  author = {Seth},
  date = {2015-03-14},
  url = {https://crypto.stackexchange.com/a/24434},
  urldate = {2024-06-15},
  organization = {Cryptography Stack Exchange},
  file = {/home/areo/Zotero/storage/PSYWRFCN/what-is-the-benefit-of-applying-the-tweak-a-second-time-using-xts.html}
}

@online{sethAnswerWhatBenefit2015a,
  title = {Answer to "{{What}} Is the Benefit of Applying the Tweak a Second Time Using {{XTS}}?"},
  shorttitle = {Answer to "{{What}} Is the Benefit of Applying the Tweak a Second Time Using {{XTS}}?},
  author = {Seth},
  date = {2015-03-14},
  url = {https://crypto.stackexchange.com/a/24434},
  urldate = {2024-06-30},
  organization = {Cryptography Stack Exchange},
  file = {/home/areo/Zotero/storage/94ANIZ9G/what-is-the-benefit-of-applying-the-tweak-a-second-time-using-xts.html}
}

@software{shinanLarkModernParsing,
  title = {Lark: A Modern Parsing Library},
  shorttitle = {Lark},
  author = {Shinan, Erez},
  url = {https://github.com/lark-parser/lark},
  urldate = {2022-07-31},
  version = {1.1.2},
  keywords = {ast,Earley,LALR,parser,parsing,Software Development - Libraries - Python Modules,Text Processing - General,Text Processing - Linguistic}
}

@online{simicSudoVsSu2020,
  title = {Sudo {{Vs Su}}: {{The Difference Between}} Sudo and Su {{Explained}}},
  shorttitle = {Sudo {{Vs Su}}},
  author = {Simic, Sofija},
  date = {2020-08-03T15:57:20+00:00},
  url = {https://phoenixnap.com/kb/sudo-vs-su-differences},
  urldate = {2023-11-14},
  abstract = {SU vs. SUDO. What is the difference between su and sudo? Learn how to distinguish between the su and sudo command and when to use one over the other.},
  langid = {american},
  organization = {Knowledge Base by phoenixNAP},
  file = {/home/areo/Zotero/storage/RDFRYNYG/sudo-vs-su-differences.html}
}

@online{skochinskyAnswerWhatImmediate2018,
  title = {Answer to "{{What}} Is an Immediate Value?"},
  shorttitle = {Answer to "{{What}} Is an Immediate Value?},
  author = {Skochinsky, Igor},
  date = {2018-03-13},
  url = {https://reverseengineering.stackexchange.com/a/17678},
  urldate = {2022-04-13},
  file = {/home/areo/Zotero/storage/IK8DZHCG/what-is-an-immediate-value.html;/home/areo/Zotero/storage/XUSS6BHA/what-is-an-immediate-value.html}
}

@online{skochinskyAnswerWhatImmediate2018a,
  title = {Answer to "{{What}} Is an Immediate Value?"},
  shorttitle = {Answer to "{{What}} Is an Immediate Value?},
  author = {Skochinsky, Igor},
  date = {2018-03-13},
  url = {https://reverseengineering.stackexchange.com/a/17678},
  urldate = {2022-06-28},
  organization = {Reverse Engineering Stack Exchange}
}

@article{standard-enc,
  title = {Standard for {{Cryptographic Protection}} of {{Data}} on {{Block-Oriented Storage Devices}}},
  author = {Security in Storage Working Group},
  date = {2007-05},
  journaltitle = {IEEE Computer Society Committee},
  url = {https://crossbowerbt.github.io/docs/crypto/pdf00086.pdf}
}

@software{StarshipStarship2023,
  title = {Starship/Starship},
  date = {2023-11-14T17:05:34Z},
  origdate = {2019-04-02T03:23:12Z},
  url = {https://github.com/starship/starship},
  urldate = {2023-11-14},
  abstract = {☄🌌️  The minimal, blazing-fast, and infinitely customizable prompt for any shell!},
  organization = {Starship Command},
  keywords = {bash,fish,fish-prompt,fish-theme,oh-my-zsh,powershell,rust,shell-prompt,starship,zsh,zsh-prompt,zsh-theme}
}

@inreference{StrukturierteProgrammierung2021,
  title = {Strukturierte Programmierung},
  booktitle = {Wikipedia},
  date = {2021-06-15T13:59:11Z},
  url = {https://de.wikipedia.org/w/index.php?title=Strukturierte_Programmierung&oldid=212983400},
  urldate = {2022-09-13},
  abstract = {Strukturierte Programmierung ist ein programmiersprachenübergreifendes Programmierparadigma, aus den 1960er Jahren, also noch vor der Softwarekrise. Es beinhaltet zum einen die baumartige Zerlegung eines Programms in Teilprogramme (Prozeduren) und enthält somit das Paradigma der prozeduralen Programmierung. Zudem verlangt die strukturierte Programmierung auf der untersten Ebene die Beschränkung auf lediglich drei Kontrollstrukturen: Sequenz (hintereinander auszuführende Programmanweisungen) Auswahl/Selektion (Verzweigung) Wiederholung/Iteration (Schleifen)Die bekannteste Konsequenz dieses Prinzips ist die Vermeidung oder – abhängig von der Programmiersprache – der eingeschränkte und standardisierte Einsatz der Sprunganweisung, des GOTO. Das Ergebnis der häufigen Verwendung dieser Anweisungen wird häufig abfällig als Spaghetticode bezeichnet.  Durch die konsequente Implementierung von Teilprogrammen mit lokaler Sichtbarkeit von Identifikatoren und Kontrollstrukturen vermeiden strukturierte Programme Codewiederholungen, was Vorteile bei der Suche von Programmfehlern mit sich bringt, die Programme kürzer und übersichtlicher macht und daher die Wartung von Software vereinfacht. Strukturierte Programmierung ist heute in fast allen Bereichen, in denen professionell Software entwickelt wird, eine Selbstverständlichkeit. Die neueren Programmierparadigmen wie generative Programmierung, aspektorientierte Programmierung oder objektorientierte Programmierung bauen auf der strukturierten Programmierung auf und erweitern oder ergänzen diese.},
  langid = {ngerman},
  annotation = {Page Version ID: 212983400},
  file = {/home/areo/Zotero/storage/EYA2CJJM/Strukturierte_Programmierung.html}
}

@inreference{Symboltabelle2013,
  title = {Symboltabelle},
  booktitle = {Wikipedia},
  date = {2013-05-07T19:42:28Z},
  url = {https://de.wikipedia.org/w/index.php?title=Symboltabelle&oldid=118290830},
  urldate = {2022-09-13},
  abstract = {In der Informatik ist eine Symboltabelle eine von Übersetzerprogrammen wie Compiler oder Interpreter verwendete Datenstruktur, die jedem Symbol im Quellcode Angaben wie die Stelle des Auftretens, den Datentyp oder einen Zeiger auf eine Struktur im Speicher zuordnet. Der Begriff Symbol wird in diesem Zusammenhang im Sinne von Bezeichner verwendet. Meist wird eine Symboltabelle durch eine Hashtabelle implementiert. Sie kann entweder nur temporär während der Übersetzung aufgebaut werden oder auch länger vorgehalten werden, um eine spätere Fehlersuche etwa mit einem Debugger zu erleichtern. In Programmiersprachen wie Lisp spielt die Symboltabelle eine darüber hinausgehende Rolle, weil sie auch die zentrale Datenstruktur des Laufzeitsystems darstellt.},
  langid = {ngerman},
  annotation = {Page Version ID: 118290830},
  file = {/home/areo/Zotero/storage/6HLJBWFP/Symboltabelle.html}
}

@inreference{Syntax2022,
  title = {Syntax},
  booktitle = {Wiktionary},
  date = {2022-06-07T12:19:24Z},
  url = {https://de.wiktionary.org/w/index.php?title=Syntax&oldid=9196998},
  urldate = {2022-07-31},
  langid = {ngerman},
  annotation = {Page Version ID: 9196998}
}

@inreference{Syntax2022a,
  title = {Syntax},
  booktitle = {Wikipedia},
  date = {2022-03-26T15:03:34Z},
  url = {https://de.wikipedia.org/w/index.php?title=Syntax&oldid=221516032},
  urldate = {2022-09-13},
  abstract = {Unter Syntax (altgriechisch σύνταξις syntaxis, von σύν syn ‚zusammen‘ und τάξις taxis ‚Ordnung, Reihenfolge‘) versteht man allgemein ein Regelsystem zur Kombination elementarer Zeichen zu zusammengesetzten Zeichen in natürlichen oder künstlichen Zeichensystemen. Die Zusammenfügungsregeln der Syntax stehen hierbei den Interpretationsregeln der Semantik gegenüber. Insbesondere versteht man unter Syntax die Satzlehre, ein Teilgebiet der Grammatik natürlicher Sprachen, das die Zusammenfügung von Wörtern bzw. Wortgruppen zu Sätzen (Satzbau) auf Basis grammatikalischer Gesetzmäßigkeiten (etwa einer bestimmten vorgeschriebenen Satzstellung) behandelt bzw. den Sätzen zugrunde liegende regelmäßige Muster (Satzstruktur) beschreibt. Die Syntax wird in der Regel unterschieden von der linguistischen Morphologie, die den inneren Aufbau der Wörter behandelt, obwohl die Übergänge zwischen beiden Bereichen fließend sein können. Der Ausdruck Syntax wird für natürliche und formale Sprachen verwendet. Das Verhältnis zwischen natürlicher und formaler Syntax wird unterschiedlich gesehen. Für den Logiker Richard Montague (Universal Grammar, 1970) bestand kein prinzipieller Unterschied. Ebenso wie der Begriff Grammatik kann sich der Begriff Syntax auf die Struktureigenschaften von Zeichensystemen selbst oder auf die theoretisch-wissenschaftliche Beschreibung dieser Struktureigenschaften beziehen.},
  langid = {ngerman},
  annotation = {Page Version ID: 221516032}
}

@inreference{Syntaxbaum2022,
  title = {Syntaxbaum},
  booktitle = {Wikipedia},
  date = {2022-05-18T12:27:03Z},
  url = {https://de.wikipedia.org/w/index.php?title=Syntaxbaum&oldid=222977877},
  urldate = {2022-09-13},
  abstract = {Ein Syntax-, Ableitungs- oder Parsebaum ist ein Begriff aus der theoretischen Informatik und der Linguistik. Er bezeichnet eine hierarchische Darstellung der Zergliederung eines Textes.  Syntaxbäume werden sowohl als Hilfsmittel zur graphischen Visualisierung der Zerlegung eingesetzt als auch, in Form einer Datenstruktur, zur Darstellung dieser Zergliederung für die maschinelle Weiterverarbeitung z. B. in einem Compiler oder Übersetzer. Die verschiedenen Bezeichnungen werden in der Literatur nicht einheitlich verwendet. Formal präzise definiert ist nur der Terminus Ableitungsbaum, der sich auf den Begriff der Ableitung stützt. Andere Bezeichnungen für verschiedenartige Bäume können dann, wie unten beschrieben, bei Bedarf technisch näher definiert werden. Anders als in der Informatik, in der Sprachen auch den technischen Möglichkeiten folgend definiert werden können, findet die Linguistik bei der Behandlung natürlicher Sprachen schwierigere Voraussetzungen vor, vor allem weil die Reihenfolge der Bestandteile in einem Satz variieren kann.},
  langid = {ngerman},
  annotation = {Page Version ID: 222977877},
  file = {/home/areo/Zotero/storage/V448AQ9J/Syntaxbaum.html}
}

@software{tanjimMunifTanjimNuiNvim2024,
  title = {{{MunifTanjim}}/Nui.Nvim},
  author = {Tanjim, Munif},
  date = {2024-02-21T20:19:06Z},
  origdate = {2021-07-09T16:13:46Z},
  url = {https://github.com/MunifTanjim/nui.nvim},
  urldate = {2024-02-22},
  abstract = {UI Component Library for Neovim.},
  keywords = {lua,neovim,neovim-plugin,neovim-ui,nvim,ui-components}
}

@unpublished{thiemannCompilerbau2021,
  type = {Vorlesung},
  title = {Compilerbau},
  author = {Thiemann, Peter},
  date = {2021},
  url = {http://proglang.informatik.uni-freiburg.de/teaching/compilerbau/2021ws/},
  urldate = {2022-07-09},
  langid = {Englisch},
  venue = {Universität Freiburg}
}

@unpublished{thiemannEinfuehrungProgrammierung2018,
  type = {Vorlesung},
  title = {Einführung in die Programmierung},
  author = {Thiemann, Peter},
  date = {2018},
  url = {http://proglang.informatik.uni-freiburg.de/teaching/info1/2018/},
  urldate = {2022-07-09},
  langid = {ngerman},
  venue = {Universität Freiburg}
}

@online{tinoAnswerHowGet2020,
  title = {Answer to "{{How}} to Get a Hyperlink on a Web Page to Open a File in a Text Editor ({{Sublime Text}})"},
  author = {{tino}},
  date = {2020-05-30},
  url = {https://stackoverflow.com/a/62099549},
  urldate = {2023-11-05},
  organization = {Stack Overflow}
}

@software{TldrpagesTldr2023,
  title = {Tldr-Pages/Tldr},
  date = {2023-11-14T15:07:41Z},
  origdate = {2013-12-08T07:34:43Z},
  url = {https://github.com/tldr-pages/tldr},
  urldate = {2023-11-14},
  abstract = {📚 Collaborative cheatsheets for console commands},
  organization = {tldr pages},
  keywords = {command-line,console,documentation,examples,hacktoberfest,help,man-page,manpages,manual,shell,terminal,tldr}
}

@inreference{TokenUebersetzerbau2014,
  title = {Token (Übersetzerbau)},
  booktitle = {Wikipedia},
  date = {2014-09-06T18:08:37Z},
  url = {https://de.wikipedia.org/w/index.php?title=Token_(%C3%9Cbersetzerbau)&oldid=133785837},
  urldate = {2022-09-13},
  abstract = {Ein Token (Art.: „das“; Pl.: ‚Tokens‘) ist eine Zeichenkette, der von einer formalen Grammatik ein Typ zugewiesen wird. Das Token bildet die lexikalische Grundeinheit für den Parser. Ein Token entspricht in der Grammatik des Parsers einem Terminalsymbol. Im trivialen Fall sind Tokens die Zeichen der ursprünglichen Eingabe: Zum Beispiel der Buchstabe A wird als Token vom Typ A erkannt. Mehrere Zeichen können im Zuge einer lexikalischen Analyse zu Tokens zusammengefasst werden. Die einem Token zu Grunde liegende Zeichenkette heißt Lexem. Beispiele:},
  langid = {ngerman},
  annotation = {Page Version ID: 133785837},
  file = {/home/areo/Zotero/storage/QC63UBQQ/Token_(Übersetzerbau).html}
}

@inreference{TotalOrder2023,
  title = {Total Order},
  booktitle = {Wikipedia},
  date = {2023-07-25T21:05:09Z},
  url = {https://en.wikipedia.org/w/index.php?title=Total_order&oldid=1167123253},
  urldate = {2024-01-10},
  abstract = {In mathematics, a total order or linear order is a partial order in which any two elements are comparable.  That is, a total order is a binary relation                         ≤                 \{\textbackslash displaystyle \textbackslash leq \}    on some set                         X                 \{\textbackslash displaystyle X\}   , which satisfies the following for all                         a         ,         b                 \{\textbackslash displaystyle a,b\}    and                         c                 \{\textbackslash displaystyle c\}    in                         X                 \{\textbackslash displaystyle X\}   :                        a         ≤         a                 \{\textbackslash displaystyle a\textbackslash leq a\}    (reflexive). If                         a         ≤         b                 \{\textbackslash displaystyle a\textbackslash leq b\}    and                         b         ≤         c                 \{\textbackslash displaystyle b\textbackslash leq c\}    then                         a         ≤         c                 \{\textbackslash displaystyle a\textbackslash leq c\}    (transitive). If                         a         ≤         b                 \{\textbackslash displaystyle a\textbackslash leq b\}    and                         b         ≤         a                 \{\textbackslash displaystyle b\textbackslash leq a\}    then                         a         =         b                 \{\textbackslash displaystyle a=b\}    (antisymmetric).                        a         ≤         b                 \{\textbackslash displaystyle a\textbackslash leq b\}    or                         b         ≤         a                 \{\textbackslash displaystyle b\textbackslash leq a\}    (strongly connected, formerly called total).Reflexivity (1.) already follows from connectedness (4.), but is required explicitly by many authors nevertheless, to indicate the kinship to partial orders. Total orders are sometimes also called simple, connex, or full orders.A set equipped with a total order is a totally ordered set; the terms simply ordered set, linearly ordered set, and loset are also used. The term chain is sometimes defined as a synonym of totally ordered set, but refers generally to some sort of totally ordered subsets of a given partially ordered set. An extension of a given partial order to a total order is called a linear extension of that partial order.},
  langid = {english},
  annotation = {Page Version ID: 1167123253},
  file = {/home/areo/Zotero/storage/VV2JHZBD/Total_order.html}
}

@online{TransformersVisitorsLark,
  title = {Transformers \& {{Visitors}} — {{Lark}} Documentation},
  url = {https://lark-parser.readthedocs.io/en/latest/visitors.html},
  urldate = {2022-07-09},
  file = {/home/areo/Zotero/storage/T8WPRTLG/visitors.html}
}

@online{TrueCrypt,
  title = {{{TrueCrypt}}},
  url = {https://truecrypt.sourceforge.net/},
  urldate = {2024-05-30},
  file = {/home/areo/Zotero/storage/4422LGW8/truecrypt.sourceforge.net.html}
}

@online{TweakingTweakableAES,
  title = {Tweaking {{Tweakable AES XTS}} Mode},
  url = {https://crossbowerbt.github.io/xts_mode_tweaking.html},
  urldate = {2024-06-15},
  file = {/home/areo/Zotero/storage/RJHIHPME/xts_mode_tweaking.html}
}

@software{uedaMakefileLaTeX2022,
  title = {Makefile for {{LaTeX}}},
  author = {Ueda, Takahiro},
  date = {2022-05-10T23:11:46Z},
  origdate = {2018-07-06T15:01:24Z},
  url = {https://github.com/tueda/makefile4latex},
  urldate = {2022-08-03},
  abstract = {A GNU Makefile for typesetting LaTeX documents.}
}

@online{underhillAnswerHowRemove2010,
  title = {Answer to "{{How}} to Remove a File from the Staging Area (= Index = Cache) in {{Git}}?"},
  shorttitle = {Answer to "{{How}} to Remove a File from the Staging Area (= Index = Cache) in {{Git}}?},
  author = {Underhill, David},
  date = {2010-02-08},
  url = {https://stackoverflow.com/a/2223321},
  urldate = {2023-11-21},
  organization = {Stack Overflow},
  file = {/home/areo/Zotero/storage/VDDS52N6/how-to-remove-a-file-from-the-staging-area-index-cache-in-git.html}
}

@online{URIsURLsURNs,
  title = {{{URIs}}, {{URLs}}, and {{URNs}}: {{Clarifications}} and {{Recommendations}} 1.0},
  url = {https://www.w3.org/TR/uri-clarification/},
  urldate = {2023-11-05},
  file = {/home/areo/Zotero/storage/IBAUL3JE/uri-clarification.html}
}

@online{VariablenUndDeklaration,
  title = {Variablen in {{C}} Und {{C}}++, {{Deklaration}} Und {{Definition}} | {{Coder-Welten}}.De},
  url = {https://www.coder-welten.de/einstieg/variablen-in-c-3.html},
  urldate = {2022-08-11},
  file = {/home/areo/Zotero/storage/3NIPZUPZ/variablen-in-c-3.html}
}

@inreference{VariableProgrammierung2022,
  title = {Variable (Programmierung)},
  booktitle = {Wikipedia},
  date = {2022-08-24T07:55:16Z},
  url = {https://de.wikipedia.org/w/index.php?title=Variable_(Programmierung)&oldid=225592766},
  urldate = {2022-09-13},
  abstract = {In der Programmierung ist eine Variable ein abstrakter Behälter für einen Wert, der bei der Ausführung eines Computerprogramm auftritt. Im Normalfall wird eine Variable im Quelltext durch einen Namen bezeichnet und hat eine Adresse im Speicher des Computers. Der durch eine Variable repräsentierte Wert und gegebenenfalls auch die Größe kann – im Unterschied zu einer Konstante – zur Laufzeit des Rechenprozesses verändert werden.},
  langid = {ngerman},
  annotation = {Page Version ID: 225592766},
  file = {/home/areo/Zotero/storage/C9YBDF5D/Variable_(Programmierung).html}
}

@online{vineetnayak28AnswerWhatDifference2016,
  title = {Answer to "{{What}}'s the Difference between Uniform-Cost Search and {{Dijkstra}}'s Algorithm?"},
  shorttitle = {Answer to "{{What}}'s the Difference between Uniform-Cost Search and {{Dijkstra}}'s Algorithm?},
  author = {VineetNayak28},
  date = {2016-09-08},
  url = {https://stackoverflow.com/a/39396812},
  urldate = {2023-06-05},
  organization = {Stack Overflow},
  file = {/home/areo/Zotero/storage/LD7FL7MQ/whats-the-difference-between-uniform-cost-search-and-dijkstras-algorithm.html}
}

@online{VisualWhereCan,
  title = {Visual C++ - {{Where}} Can {{I}} Get a List of All Errors \& Warnings? - {{Stack Overflow}}},
  url = {https://stackoverflow.com/questions/1392855/where-can-i-get-a-list-of-all-errors-warnings},
  urldate = {2022-05-10},
  file = {/home/areo/Zotero/storage/3A8CQ72W/where-can-i-get-a-list-of-all-errors-warnings.html;/home/areo/Zotero/storage/RNQABVXT/where-can-i-get-a-list-of-all-errors-warnings.html}
}

@online{voncAnswerWhatDifference2012,
  title = {Answer to "{{What}} Is the Difference between a Commit and a Revision in {{Git}}?"},
  shorttitle = {Answer to "{{What}} Is the Difference between a Commit and a Revision in {{Git}}?},
  author = {VonC},
  date = {2012-08-03},
  url = {https://stackoverflow.com/a/11792712},
  urldate = {2023-11-21},
  organization = {Stack Overflow},
  file = {/home/areo/Zotero/storage/SXZVSYLI/what-is-the-difference-between-a-commit-and-a-revision-in-git.html}
}

@online{VorrangregelnUndAssoziativitat,
  title = {2.1.7 {{Vorrangregeln}} Und {{Assoziativität}}},
  url = {https://www.tu-chemnitz.de/urz/archiv/kursunterlagen/C/kap2/vorrang.htm},
  urldate = {2022-09-05},
  file = {/home/areo/Zotero/storage/KDJYEHAR/vorrang.html}
}

@online{VorrangregelnUndAssoziativitata,
  title = {2.1.7 {{Vorrangregeln}} Und {{Assoziativität}}},
  url = {https://www.tu-chemnitz.de/urz/archiv/kursunterlagen/C/kap2/vorrang.htm},
  urldate = {2022-09-13},
  file = {/home/areo/Zotero/storage/L75NJ9YC/vorrang.html}
}

@artwork{w:user:smilerptEnglishMessageAuthentication2008,
  title = {English:  {{Message}} Authentication Code, Based on   {{MAC}}.Gif},
  shorttitle = {English},
  author = {{w:User:Smilerpt}, based on diagram by, Twisp},
  date = {2008-01-17},
  url = {https://commons.wikimedia.org/wiki/File:MAC.svg},
  urldate = {2024-05-26},
  file = {/home/areo/Zotero/storage/CECBB8BR/FileMAC.html}
}

@inproceedings{wang2016high,
  title = {High Throughput and Resource Efficient {{AES}} Encryption/Decryption for {{SANs}}},
  booktitle = {2016 {{IEEE}} International Symposium on Circuits and Systems ({{ISCAS}})},
  author = {Wang, Yi and Ha, Yajun},
  date = {2016},
  pages = {1166--1169},
  publisher = {IEEE}
}

@article{warfordCalculationalDeductiveSystem2021,
  title = {A {{Calculational Deductive System}} for {{Linear Temporal Logic}}},
  author = {Warford, J. Stanley and Vega, David and Staley, Scott M.},
  date = {2021-05-31},
  journaltitle = {ACM Computing Surveys},
  shortjournal = {ACM Comput. Surv.},
  volume = {53},
  number = {3},
  pages = {1--38},
  issn = {0360-0300, 1557-7341},
  doi = {10.1145/3387109},
  url = {https://dl.acm.org/doi/10.1145/3387109},
  urldate = {2024-01-30},
  abstract = {This article surveys the linear temporal logic (LTL) literature and presents all the LTL theorems from the survey, plus many new ones, in a calculational deductive system. Calculational deductive systems, developed by Dijkstra and Scholten and extended by Gries and Schneider, are based on only four inference rules—Substitution, Leibniz, Equanimity, and Transitivity. Inference rules in the older Hilbert-style systems, notably modus ponens, appear as theorems in this calculational deductive system. This article extends the calculational deductive system of Gries and Schneider to LTL, using only the same four inference rules. Although space limitations preclude giving a proof of every theorem in this article, every theorem has been proved with calculational logic.},
  langid = {english},
  file = {/home/areo/Zotero/storage/RIVS5AS5/Warford et al. - 2021 - A Calculational Deductive System for Linear Tempor.pdf}
}

@article{warfordCalculationalDeductiveSystem2021a,
  title = {A {{Calculational Deductive System}} for {{Linear Temporal Logic}}},
  author = {Warford, J. Stanley and Vega, David and Staley, Scott M.},
  date = {2021-05-31},
  journaltitle = {ACM Computing Surveys},
  shortjournal = {ACM Comput. Surv.},
  volume = {53},
  number = {3},
  pages = {1--38},
  issn = {0360-0300, 1557-7341},
  doi = {10.1145/3387109},
  url = {https://dl.acm.org/doi/10.1145/3387109},
  urldate = {2024-01-30},
  abstract = {This article surveys the linear temporal logic (LTL) literature and presents all the LTL theorems from the survey, plus many new ones, in a calculational deductive system. Calculational deductive systems, developed by Dijkstra and Scholten and extended by Gries and Schneider, are based on only four inference rules—Substitution, Leibniz, Equanimity, and Transitivity. Inference rules in the older Hilbert-style systems, notably modus ponens, appear as theorems in this calculational deductive system. This article extends the calculational deductive system of Gries and Schneider to LTL, using only the same four inference rules. Although space limitations preclude giving a proof of every theorem in this article, every theorem has been proved with calculational logic.},
  langid = {english}
}

@online{WelcomeLarkDocumentation,
  title = {Welcome to {{Lark}}’s Documentation! — {{Lark}} Documentation},
  url = {https://lark-parser.readthedocs.io/en/latest/},
  urldate = {2022-07-31},
  file = {/home/areo/Zotero/storage/7V4MTB3F/latest.html}
}

@unpublished{westphalSoftwaretechnik2021,
  type = {Vorlesung},
  title = {Softwaretechnik},
  author = {Westphal, Dr. Bernd},
  date = {2021},
  url = {https://swt.informatik.uni-freiburg.de/teaching/SS2021/swtvl},
  urldate = {2022-07-19},
  langid = {Englisch},
  venue = {Universität Freiburg}
}

@online{WhatBootstrapDefinition,
  title = {What Is a {{Bootstrap}}? - {{Definition}} from {{Techopedia}}},
  shorttitle = {What Is a {{Bootstrap}}?},
  url = {http://www.techopedia.com/definition/3328/bootstrap},
  urldate = {2022-06-27},
  abstract = {This definition explains the meaning of Bootstrap and why it matters.},
  langid = {english},
  organization = {Techopedia.com}
}

@online{WhatBottomupParsing,
  title = {What Is {{Bottom-up Parsing}}?},
  url = {https://www.tutorialspoint.com/what-is-bottom-up-parsing},
  urldate = {2022-06-22},
  file = {/home/areo/Zotero/storage/YBQ7BSM4/what-is-bottom-up-parsing.html}
}

@online{WhatDifferenceFunction,
  title = {What Is the Difference between Function Prototype and Function Signature?},
  url = {https://www.sololearn.com/Discuss/171026/what-is-the-difference-between-function-prototype-and-function-signature/},
  urldate = {2022-07-18},
  abstract = {Check out what Vaibhav kumar has posted on SoloLearn},
  langid = {english},
  organization = {SoloLearn},
  file = {/home/areo/Zotero/storage/YJRVHBA5/what-is-the-difference-between-function-prototype-and-function-signature.html}
}

@online{WhatDifferenceToken,
  title = {What Is the Difference between a Token and a Lexeme?},
  url = {http://newbedev.com/what-is-the-difference-between-a-token-and-a-lexeme},
  urldate = {2022-06-17},
  abstract = {Using "Compilers Principles, Techniques, \& Tools, 2nd Ed." (WorldCat) by Aho, Lam, Sethi and Ullman, AKA the Purple Dragon Book, Lexeme pg. 111 A lexeme is a se},
  langid = {american},
  organization = {NewbeDEV},
  file = {/home/areo/Zotero/storage/RXBCRNFP/what-is-the-difference-between-a-token-and-a-lexeme.html;/home/areo/Zotero/storage/YY34L9DQ/what-is-the-difference-between-a-token-and-a-lexeme.html}
}

@online{WhatPurposeTwo,
  title = {What Is the Purpose of Two Slashes (// )after Http ?},
  url = {https://www.quora.com/What-is-the-purpose-of-two-slashes-after-http},
  urldate = {2023-11-05},
  abstract = {Answer: The same as we have rules to drive on a public road, the internet is full of them so different machines and operating systems can communicate between each other in an “understandable” way. The propose of the double-forward-slash in an URL is specified in a document in RFC 3986 (Uniform R...},
  langid = {english},
  organization = {Quora},
  file = {/home/areo/Zotero/storage/6EBIGFNW/What-is-the-purpose-of-two-slashes-after-http.html}
}

@online{WhatSpilling2021,
  title = {What Is {{Spilling}}},
  date = {2021-08-01T20:33:24+00:00},
  url = {https://www.geeksforgeeks.org/what-is-spilling/},
  urldate = {2022-08-07},
  abstract = {A Computer Science portal for geeks. It contains well written, well thought and well explained computer science and programming articles, quizzes and practice/competitive programming/company interview Questions.},
  langid = {american},
  organization = {GeeksforGeeks},
  file = {/home/areo/Zotero/storage/NKPMLZSK/what-is-spilling.html}
}

@online{WhatTopDownParsing,
  title = {What Is {{Top-Down Parsing}}?},
  url = {https://www.tutorialspoint.com/what-is-top-down-parsing},
  urldate = {2022-06-22},
  file = {/home/areo/Zotero/storage/6IU27G9Y/what-is-top-down-parsing.html}
}

@online{WhatXTSXEXbased2024,
  title = {What {{Is XTS}} ({{XEX-based Tweaked-codebook Mode With Ciphertext Stealing}})? - {{ITU Online}}},
  shorttitle = {What {{Is XTS}} ({{XEX-based Tweaked-codebook Mode With Ciphertext Stealing}})?},
  date = {2024-06-08T19:44:57-04:00},
  url = {https://www.ituonline.com/tech-definitions/what-is-xts-xex-based-tweaked-codebook-mode-with-ciphertext-stealing/},
  urldate = {2024-07-02},
  abstract = {XTS, which stands for XEX-based Tweaked-codebook mode with ciphertext Stealing, is an encryption mode used primarily in the encryption of data on storage},
  langid = {american},
  file = {/home/areo/Zotero/storage/MCKBZL37/what-is-xts-xex-based-tweaked-codebook-mode-with-ciphertext-stealing.html}
}

@artwork{whitetimberwolfEnglishDecryptionUsing2013,
  title = {English:  {{Decryption}} Using the {{Electronic Codebook}} ({{ECB}}) Mode.},
  shorttitle = {English},
  author = {{WhiteTimberwolf}},
  year = {1 June 2013, 03:45:39},
  url = {https://commons.wikimedia.org/wiki/File:ECB_decryption.svg},
  urldate = {2024-05-22}
}

@artwork{whitetimberwolfEnglishDecryptionUsing2013a,
  title = {English:  {{Decryption}} Using the {{Cipher Block Chaining}} ({{CBC}}) Mode.},
  shorttitle = {English},
  author = {{WhiteTimberwolf}},
  year = {1 June 2013, 03:45:39},
  url = {https://commons.wikimedia.org/wiki/File:CBC_decryption.svg},
  urldate = {2024-05-22}
}

@artwork{whitetimberwolfEnglishDecryptionUsing2013b,
  title = {English:  {{Decryption}} Using the {{Output Feedback}} ({{OFB}}) Mode.},
  shorttitle = {English},
  author = {{WhiteTimberwolf}},
  year = {1 June 2013, 03:45:39},
  url = {https://commons.wikimedia.org/wiki/File:OFB_decryption.svg},
  urldate = {2024-05-22}
}

@artwork{whitetimberwolfEnglishEncryptionUsing2013,
  title = {English:  {{Encryption}} Using the {{Electronic Code Block}} ({{ECB}}) Mode.},
  shorttitle = {English},
  author = {{WhiteTimberwolf}},
  year = {1 June 2013, 03:45:39},
  url = {https://commons.wikimedia.org/wiki/File:ECB_encryption.svg},
  urldate = {2024-05-22},
  file = {/home/areo/Zotero/storage/ZZ78MQZE/FileECB_encryption.html}
}

@artwork{whitetimberwolfEnglishEncryptionUsing2013a,
  title = {English:  {{Encryption}} Using the {{Cipher Block Chaining}} ({{CBC}}) Mode.},
  shorttitle = {English},
  author = {{WhiteTimberwolf}},
  year = {1 June 2013, 03:45:39},
  url = {https://commons.wikimedia.org/wiki/File:CBC_encryption.svg},
  urldate = {2024-05-22}
}

@artwork{whitetimberwolfEnglishEncryptionUsing2013b,
  title = {English:  {{Encryption}} Using the {{Output Feedback}} ({{OFB}}) Mode.},
  shorttitle = {English},
  author = {{WhiteTimberwolf}},
  year = {1 June 2013, 03:45:39},
  url = {https://commons.wikimedia.org/wiki/File:OFB_encryption.svg},
  urldate = {2024-05-22}
}

@artwork{whitetimberwolfEnglishEncryptionUsing2013c,
  title = {English:  {{Encryption}} Using the {{Counter}} ({{CTR}}) Mode.},
  shorttitle = {English},
  author = {{WhiteTimberwolf}},
  year = {1 June 2013, 03:45:39},
  url = {https://commons.wikimedia.org/wiki/File:CTR_encryption_2.svg},
  urldate = {2024-05-22}
}

@inreference{WortproblemBerechenbarkeitstheorie2022,
  title = {Wortproblem (Berechenbarkeitstheorie)},
  booktitle = {Wikipedia},
  date = {2022-02-28T18:14:14Z},
  url = {https://de.wikipedia.org/w/index.php?title=Wortproblem_(Berechenbarkeitstheorie)&oldid=220669412},
  urldate = {2022-09-13},
  langid = {ngerman},
  annotation = {Page Version ID: 220669412},
  file = {/home/areo/Zotero/storage/2U9R2QX7/Wortproblem_(Berechenbarkeitstheorie).html}
}

@online{XkeyboardconfigArchManual,
  title = {Xkeyboard-Config(7) — {{Arch}} Manual Pages},
  url = {https://man.archlinux.org/man/xkeyboard-config.7},
  urldate = {2023-11-05},
  file = {/home/areo/Zotero/storage/7YR99EUI/xkeyboard-config.html}
}

@online{XorgKeyboardConfiguration,
  title = {Xorg/{{Keyboard}} Configuration - {{ArchWiki}}},
  url = {https://wiki.archlinux.org/title/Xorg/Keyboard_configuration},
  urldate = {2023-11-05},
  file = {/home/areo/Zotero/storage/X3ZTFYUJ/Keyboard_configuration.html}
}

@article{XTSAESTweakableBlock2008,
  title = {The {{XTS-AES Tweakable Block Cipher}}  - {{An Extract}} from {{IEEE Std}} 1619-2007},
  date = {2008},
  langid = {english},
  file = {/home/areo/Zotero/storage/FEP8MBVU/2008 - The XTS-AES Tweakable Block Cipher  - An Extract f.pdf}
}

@online{YouDonWant,
  title = {You {{Don}}'t {{Want XTS}} — {{Quarrelsome}}},
  url = {https://sockpuppet.org/blog/2014/04/30/you-dont-want-xts/},
  urldate = {2024-05-30},
  file = {/home/areo/Zotero/storage/RPVEWBT8/you-dont-want-xts.html}
}

@online{ZahlendarstellungZurBasis,
  title = {Zahlendarstellung Zur {{Basis}}},
  url = {https://www.inf.hs-flensburg.de/lang/informatik/zahlendarstellung.htm},
  urldate = {2023-05-26},
  file = {/home/areo/Zotero/storage/WSWSRARI/zahlendarstellung.html}
}

@online{ziggystarAnswerWhatDifference2013,
  title = {Answer to "{{What}} Is the Difference between Graph Search and Tree Search?"},
  shorttitle = {Answer to "{{What}} Is the Difference between Graph Search and Tree Search?},
  author = {{ziggystar}},
  date = {2013-03-07},
  url = {https://stackoverflow.com/a/15281447},
  urldate = {2023-06-05},
  organization = {Stack Overflow},
  file = {/home/areo/Zotero/storage/SR2ALPD7/what-is-the-difference-between-graph-search-and-tree-search.html}
}

@article{zotero-609,
  type = {article}
}

@book{zotero-611,
  type = {book}
}

@article{zotero-655,
  type = {article}
}

@online{ZoteroTextbackslashtextbarYour2022,
  title = {Zotero \textbackslash textbackslashtextbar {{Your}} Personal Research Assistant},
  date = {2022-01-28},
  url = {https://www.zotero.org/},
  urldate = {2022-01-28}
}

@online{ZoteroTextbarYour2022,
  title = {Zotero \textbackslash textbar {{Your}} Personal Research Assistant},
  date = {2022-01-28},
  url = {https://www.zotero.org/},
  urldate = {2022-01-28}
}
