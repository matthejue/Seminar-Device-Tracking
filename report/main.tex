\documentclass[twocolumn]{report}

\input{./content/packages}
\input{./content/declarations}
\input{./content/desgin}

\newtoggle{longversion}
\toggletrue{longversion}

% \togglefalse{longversion}

\begin{document}

\fontsize{7pt}{8pt}\selectfont
\newgeometry{margin=1cm, bottom=2cm, top=1cm}

\input{./content/titlepage}

\clearpage
\pagenumbering{gobble}
\tableofcontents
\clearpage
\clearpage

\pagenumbering{arabic}
\pagestyle{plain}
\clearpage

\section{Introduction}
\label{sec:introduction}

In 2018, the \alert{Meltdown} and \alert{Spectre} attacks caused widespread concern by revealing how modern CPUs’ performance features could be exploited to read sensitive data from memory that should have remained inaccessible to user processes.

These attacks demonstrated a broader principle: that subtle side effects in complex systems can leak internal information not intended to be observable.

In a similar spirit, researchers Moshe Kol, Amit Klein, and Yossi Gilad from the Hebrew University of Jerusalem discovered an attack that exploits Linux’s \alert{TCP source port selection algorithm} to track devices.

Like Meltdown, this attack targets \alert{security} and compromises confidentiality, but not by directly revealing secret data, but by exploiting side effects of \alert{hash collisions} that manifest as observable patterns in how \alert{TCP source ports} are incremented across connections. These patterns allow an attacker to infer a fingerprint uniquely tied to a \alert{secret device-specific key}.

\subsection{About this report}
\label{sec:goal_of_this_report}

The goal of this report is to provide insight into a specific browser-based device tracking technique described in the paper~\cite{kol2022devicetrackinglinuxsnew}. This report explains what this tracking method exploits and how it operates, describes the different phases of the attack, and discusses possible countermeasures to mitigate the vulnerability.

This report mainly aims to present the \alert{summarize} of the original paper in a \alert{shorter}, \alert{easier-to-understand}, and \alert{more intuitively differently structured way}, since the original paper requires additional technical knowledge to be fully understood and has the key information most readers are interested in scattered across various sections.

Readers are encouraged to first consult Section~\ref{sec:terminology and conventions} for an \alert{overview of terminology and conventions} used throughout this report.

\alert{It should be emphasized that this is purely a report explaining and summarizing the result of other researchers' work, without presenting original research or claiming the findings as the author's own.}

\iftoggle{longversion}{
\subsection{Browser-based Device tracking}
\label{sec:Online browser-based device tracking}

\alert{Browser-based device tracking} is a widespread practice in which websites or advertisers use information collected through the user’s web browser to identify devices across sessions and different websites.

  Traditionally, cross-site tracking relied on \alert{third-party cookies}, but growing privacy concerns and technical defenses like privacy modes and cookie blocking have pushed trackers to seek new methods that work across browsers and networks.

A major \alert{privacy risk} of device tracking is linking a user’s identities across different contexts like networks, browsers, or privacy modes without their awareness or consent.

Device tracking techniques, particularly browser-based tracking, face challenges in reliably identifying devices under changing conditions such as switching browsers, networks, or privacy modes. One important problem is the \alert{golden image challenge}, where many identical devices with the same hardware and software configuration need to be distinguished from each other.

Device tracking techniques can be broadly categorized into the following two groups:

\begin{itemize}
	\item \aalert{Tagging techniques:} These techniques insert an ID directly into the device, usually at the browser level. Examples include caching resources in the browser or storing data in mechanisms like cookies. However, tagging techniques are often ineffective when users switch to privacy modes or clear stored data.
	\item \aalert{Fingerprinting techniques:} These techniques measure characteristics of the system or browser to distinguish devices. Examples include differences in fonts, hardware details, or system language. However, fingerprinting techniques often struggle to solve the golden image challenge, as identical devices may produce identical fingerprints.
\end{itemize}

The attack described in the paper is a \alert{fingerprinting technique}, as it derives a device-specific identifier from the behavior of the operating system’s TCP source port selection rather than storing data in the browser. Unlike typical fingerprinting methods, it can successfully solve the \alert{golden image challenge}, because the identifier it produces depends on a per-device secret key generated at system boot. This allows it to distinguish between devices even when they share identical hardware and software configurations, and it remains effective across different browsers, privacy modes, networks, persisting until the device restarts.
}{}

\subsection{Source Port Selection}
\label{sec:source port selection}

Source port selection is a mechanism used by the TCP/IP stack of operating systems to choose a TCP source port number for outbound TCP connections. It is required because a TCP connection between two endpoints is uniquely identified by the \alert{4-tuple}, consisting of:
\begin{itemize}
	\item the \aalert{source IP} address,
	\item the \aalert{source port},
	\item the \aalert{destination IP} address, and
	\item the \aalert{destination port}.
\end{itemize}

\iftoggle{longversion}{
\alert{Ports} exist so that multiple simultaneous network connections can operate on the same device, even to the same destination IP address and destination port. For example, a single machine might want to establish several independent TCP connections to the same remote server, and different source ports allow the operating system to distinguish these connections.
}{}

A straightforward way to select source ports would be simply to choose the next available free port in sequence. But this approach is problematic because it fails to achieve two important goals that are also described in the paper:

\begin{itemize}
	\item \aalert{Security:} Predictable source port numbers make it easier for attackers to perform off-path attacks, such as blind reset or data injection attacks, as they have to guess key connection details like the TCP 4-tuple (source and destination IP addresses and ports) and sequence numbers.
	\item \aalert{Functionality:} Quickly reusing the same source port can cause failures because earlier connections might still be active or in the \texttt{TIME\_WAIT} state on the server side. Reusing the same 4-tuple too soon can lead to errors or dropped connections.
\end{itemize}

\subsubsection{Double-Hash Port Selection Algorithm (DHPS)}
\label{sec:double-hash port selection algorithm}

To address these goals, several algorithms for TCP source port selection have been defined, including the \alert{Double-Hash Port Selection (DHPS)} algorithm, described in RFC 6056\cite{larsenRecommendationsTransportProtocolPort2011}.

\iftoggle{longversion}{
TCP source ports are divided into different ranges, each serving distinct purposes:
\begin{itemize}
	\item \aalert{Well-known ports} (typically ports 0–1023) are reserved for specific services such as HTTP (port 80) or HTTPS (port 443).
	\item \aalert{Registered ports} (typically ports 1024–49151) are assigned to user applications or services but are not ephemeral.
	\item \aalert{Ephemeral ports} (typically in the higher range, e.g. 32768–60999 in Linux) are dynamically allocated by the operating system for short-lived client-side connections.
\end{itemize}

For the DHPS algorithm, the \alert{ephemeral port} range is particularly relevant because it represents the pool from which source ports are selected for outbound connections.

DHPS selects a TCP \alert{source port} for outbound TCP connections from the ephemeral range based on a given \alert{3-tuple}, consisting of:
\begin{itemize}
	\item the \alert{source IP} address,
	\item the \alert{destination IP} address, and
	\item the \alert{destination port}
\end{itemize}
and by this completes the connection’s \alert{4-tuple}. To perform this selection, it uses two \alert{cryptographic keyed-hash functions} with separate, independent keys:
\begin{itemize}
	\item \( F_{K_1} \), which maps its inputs to a large range of integers, using the key \( K_1 \),
	\item \( G_{K_2} \), which maps its inputs to a range corresponding to the size of the \alert{perturbation table} \texttt{table}, using the key \( K_2 \).
\end{itemize}

The \alert{perturbation table} in the DHPS algorithm is a fixed-size array of integer counters used to add randomness and unpredictability to TCP source port selection. In Linux, it consists of $T = 256$ entries, all initially set to zero. Each time a connection uses a specific table entry, the counter at that index is incremented, so the table evolves over time as more connections are made. This mechanism ensures that successive connections to the same destination do not repeatedly use the same source port, thus improving security and preventing collisions of TCP 4-tuples.
}{}

The algorithm operates as described in Algorithm~\hyperref[1]{alg:dhps_port_selection}:
\begin{itemize}
	\item It calculates an \texttt{offset} by applying the keyed hash function \( F_{K_1} \) to the 3-tuple.
	\item It calculates an \texttt{index} into the perturbation table by applying the keyed hash function \( G_{K_2} \) to the 3-tuple.
	\item It computes a candidate port number using:
	\begin{equation*}
		\begin{split}
			\texttt{candidate\_port}
			 & = \texttt{min\_ephemeral}      \\
			 & \quad + \bigl((\texttt{offset}
			+ \text{table[{\texttt{index}}]})
			\bmod \texttt{num\_ephemeral}\bigr)
		\end{split}
	\end{equation*}
	where \texttt{min\_ephemeral} and \texttt{num\_ephemeral} define the allowed range of ephemeral ports.
	\item It checks whether the candidate port is suitable. If the port is already in use or otherwise unsuitable, the algorithm increments the entry in the perturbation \texttt{table} at the calculated \texttt{index}. As a consequence, the next time this same table entry is used, the computed port number is also \alert{incremented by 1}, unless the port is already at the end of the ephemeral range, in which case it wraps around to the beginning of the range.
	\item This process \alert{repeats until} a free port is found or no ports remain. This loop is controlled by the variable \texttt{count}, which is decremented on each attempt and terminates the algorithm when it reaches zero.
\end{itemize}

\vspace{0.2cm}
\input{./share/dhps_algorithm.tex}

\section{Attack}
\label{sec:attack}

In the attack, two main parties are involved:

\begin{itemize}
	\item \aalert{Tracking server}: This server is controlled by the \alert{attacker} and receives the TCP connection attempts initiated from the client device. It analyzes the observed TCP source ports in order to calculate a device ID and track the victim.%across networks and browsing sessions.

	\item \aalert{Client device}: This is the \alert{victim’s} (Linux-based) device, which runs a browser that renders a web page containing a \alert{tracking snippet}, a small piece of HTML and JavaScript code that operates within the browser’s JavaScript sandbox. When the browser renders the tracking snippet and executes the JavaScript code, the code causes the browser to initiate a series of TCP connection attempts to the \alert{tracking server}, interleaved with TCP connection attempts to a \alert{localhost address}.
\end{itemize}

Two \alert{types of 3-tuples} are distinguished in the attack:

\begin{itemize}
	\item \aalert{Attacker 3-tuples:} These have the form
	\begin{equation*}
		(\mathrm{IP_{Src}}_{\text{Internet-facing}}, \mathrm{IP_{Dst}}_{\text{tracking server}}, \mathrm{Port_{Dst}})
	\end{equation*}
	where the source IP address is the Internet-facing address of the device, and the destination IP address belongs to the tracking server.

	\item \aalert{Loopback 3-tuples:} These have the form
	\begin{equation*}
		(\mathrm{IP_{Src}} = 127.0.0.1, \mathrm{IP_{Dst}} = 127.1.2.3, \mathrm{Port_{Dst}})
	\end{equation*}
	where both source and destination IP addresses are loopback addresses on the device. \alert{Loopback addresses} refer to the local machine itself and are used for internal communication within the device. Only the \alert{destination port} varies among loopback 3-tuples.
\end{itemize}

We will see later why distinguishing these two types of 3-tuples is important.

The fingerprint mentioned in the introduction Section~\ref{sec:introduction} of this report is the \alert{device ID} that is built by indirectly observing the structure formed by \alert{collisions of loopback 3-tuples} inside the perturbation table. Such a collision occurs if two loopback 3-tuples differing only in their destination port numbers $x$ and $y$ satisfy
% \begin{equation*}
% 	G_{K_{2}}\bigl(\mathrm{IP}_{\mathrm{Src}} = 127.0.0.1,\; \mathrm{IP}_{\mathrm{Dst}} = 127.1.2.3,\; \mathrm{Port}_{\mathrm{Dst}} = x \bigr)
% 	=
% 	G_{K_{2}}\bigl(\mathrm{IP}_{\mathrm{Src}} = 127.0.0.1,\; \mathrm{IP}_{\mathrm{Dst}} = 127.1.2.3,\; \mathrm{Port}_{\mathrm{Dst}} = y \bigr)
% \end{equation*}
\begin{equation*}
	\begin{split}
		G_{K_{2}}\bigl(
		\mathrm{IP}_{\mathrm{Src}} = 127.0.0.1,\;
		\mathrm{IP}_{\mathrm{Dst}} = 127.1.2.3,\;
		\mathrm{Port}_{\mathrm{Dst}} = x
		\bigr)
		= \\
		G_{K_{2}}\bigl(
		\mathrm{IP}_{\mathrm{Src}} = 127.0.0.1,\;
		\mathrm{IP}_{\mathrm{Dst}} = 127.1.2.3,\;
		\mathrm{Port}_{\mathrm{Dst}} = y
		\bigr)
	\end{split}
\end{equation*}
\vspace{-0.5cm}

meaning that both tuples hash to the same cell in the perturbation table under the function $\mathrm{G_{K_2}}$. These collisions depend solely on the kernel’s \alert{secret key} $K_2$, which is the same secret key mentioned in the introduction Section~\ref{sec:introduction}. This key is randomly generated each time the \alert{system starts} and remains constant as long as the device stays powered on. Consequently, the device ID is directly tied to $K_2$ and persists across browser sessions, private browsing modes, and network changes.

The device ID consists of the set of all such colliding pairs:

\vspace{-0.2cm}
\begin{minipage}{\columnwidth}
\[
	\left\{ \bigl(x_i, y_i\bigr) \;\middle|\; i = 1, \ldots, n \right\}
\]
\end{minipage}

where each pair $(x_i, y_i)$ represents \alert{two destination ports} whose corresponding loopback 3-tuples collide into the same perturbation table cell. These pairs are chosen to be \alert{\hypertarget{independant}{independant}}, meaning that each one captures a distinct piece of evidence about how the secret key $K_2$ maps destination ports into perturbation table cells. Specifically, if $k$ loopback 3-tuples fall into the same cell, there are $\binom{k}{2}$ possible pairs, but only $k-1$ of these are independent. The independent pairs are chosen as:

\vspace{-0.2cm}
\begin{minipage}{\columnwidth}
\[
	(x_1, x_2),\; \ldots,\; (x_1, x_k),
\]
\end{minipage}

where $x_1, x_2, \ldots, x_k$ are the destination ports of the colliding loopback 3-tuples. This means that for each group of colliding loopback tuples, the first discovered tuple $x_1$ is paired with every other tuple in that group, as further detailed in Phase 2 of the attack. Pairs beyond these $k-1$ would be \alert{dependent} because their collisions are fully implied by the existing pairs\footnote{For example, knowing that both $(x_1, x_2)$ and $(x_1, x_3)$ collide makes it redundant to additionally record $(x_2, x_3)$.}. This is crucial for the probability analysis in the paper, where the probability that a random device produces the same set of collisions depends solely on the number of independent pairs observed.

A device ID based on collisions of \alert{attacker 3-tuples} would not remain consistent across networks because the source IP address visible to external servers typically changes whenever the device connects to a different network. In contrast, \alert{loopback 3-tuples} with loopback addresses such as $127.x.x.x$ are internal to the device and remain stable across networks, making them suitable for deriving a consistent device ID.

The nature of the attack resembles the principle of a \alert{particle accelerator}, where tiny particles cannot be observed directly and must instead be studied through the side effects they produce. Similarly, because there is no direct access to kernel internals such as the perturbation table, collisions of loopback 3-tuples (used to build the device ID) within the perturbation table \alert{cannot be observed directly}. Instead, such collisions must be inferred indirectly by analyzing the side effects that appear as observable patterns in how TCP source ports are incremented across connections by DHPS.

These observable patterns arise because, in the DHPS algorithm, each cell in the perturbation table maintains a counter that is incremented by 1 in a predictable manner every time it is used to generate a candidate source port, as shown in Algorithm~\hyperref[1]{alg:dhps_port_selection}, line~9:

\begin{minipage}{\columnwidth}
\[
	\texttt{table[index]} \leftarrow \texttt{table[index]} + 1.
\]
\end{minipage}

A technique that exploits these predictable TCP source port increments to detect collisions of 3-tuples (attacker or loopback) is known as \alert{sandwiching}. The general principle of sandwiching is that there is a \alert{wrapper} and a \alert{filling}, as visualized in the following schema:

\begin{center}
	\begin{adjustbox}{max width=0.95\columnwidth}
		\begin{tblr}{
			colspec={|c|Q[l]|},
			row{1}={bg=PrimaryColor,fg=white,font=\bfseries},
			row{2}={bg=PrimaryColorDimmed},
			row{3}={bg=SecondaryColorDimmed},
			row{4}={bg=PrimaryColorDimmed},
			hlines
			}
			\textbf{Step} & \textbf{Calculation} \\

			Wrapper       &
			\(
			\begin{aligned}
				 & i = G_{K_2}(\text{IP}_{\text{Src},X}, \text{IP}_{\text{Dst},X}, \text{Port}_{\text{Dst},X})                                   \\
				 & \text{offset}_X = F_{K_1}(\text{IP}_{\text{Src},X}, \text{IP}_{\text{Dst},X}, \text{Port}_{\text{Dst},X})                     \\
				 & \text{Port}_{\text{Src},1} = \text{min\_ephemeral} + \bigl(\text{offset}_X + \text{table}[i]\bigr)\bmod \text{num\_ephemeral} \\
				 & \text{table}[i] = \text{table}[i] + 1
			\end{aligned}
			\)                                   \\

			Filling       &
			\(
			\begin{aligned}
				 & j = G_{K_2}(\text{IP}_{\text{Src},Y}, \text{IP}_{\text{Dst},Y}, \text{Port}_{\text{Dst},Y})                                   \\
				 & \text{offset}_Y = F_{K_1}(\text{IP}_{\text{Src},Y}, \text{IP}_{\text{Dst},Y}, \text{Port}_{\text{Dst},Y})                     \\
				 & \text{Port}_{\text{Src},2} = \text{min\_ephemeral} + \bigl(\text{offset}_Y + \text{table}[j]\bigr)\bmod \text{num\_ephemeral} \\
				 & \text{table}[j] = \text{table}[j] + 1
			\end{aligned}
			\)                                   \\

			Wrapper       &
			\(
			\begin{aligned}
				 & i = G_{K_2}(\text{IP}_{\text{Src},X}, \text{IP}_{\text{Dst},X}, \text{Port}_{\text{Dst},X})                                             \\
				 & \text{offset}_X = F_{K_1}(\text{IP}_{\text{Src},X}, \text{IP}_{\text{Dst},X}, \text{Port}_{\text{Dst},X})                               \\
				 & \text{Port}_{\text{Src},3} = \text{min\_ephemeral} + \bigl(\text{offset}_X + \text{table}[i] + \delta \bigr)\bmod \text{num\_ephemeral} \\
				 & \text{table}[i] = \text{table}[i] + 1
			\end{aligned}
			\)                                   \\
		\end{tblr}
	\end{adjustbox}
\end{center}
where
\vspace{-1cm}
\begin{center}
  \begin{adjustbox}{max width=\columnwidth}
    \begin{minipage}[t]{0.4\textwidth}
\[
	\delta =
	\begin{cases}
    1, & \text{if } i \neq j,\ \text{meaning perturbation table cell } i \text{ was not used,} \\
		2, & \text{if } i = j,\ \text{meaning perturbation table cell } i \text{ was used}
	\end{cases}
\]
    \end{minipage}
  \end{adjustbox}\footnote{Used or not used in the filling step.}
\end{center}
\begin{itemize}
	\item In the \aalert{first wrapper step}, DHPS calculates \(\text{Port}_{\text{Src},1}\) for the 3-tuple \( X \), based on the current value in cell \( i \) of the perturbation table. Afterwards, \(\text{table}[i]\) is incremented by 1.
	\item In the \aalert{filling step}, a different 3-tuple \( Y \) is used, producing \(\text{Port}_{\text{Src},2}\) based on cell \( j \). If \( j = i \), then \(\text{table}[i]\) is incremented again.
	\item In the \aalert{second wrapper step}, DHPS calculates \(\text{Port}_{\text{Src},3}\) for the same 3-tuple \( X \). If \( j \neq i \), then \(\text{Port}_{\text{Src},3} = \text{Port}_{\text{Src},1} + 1\). Otherwise, if \( j = i \), then \(\text{Port}_{\text{Src},3} = \text{Port}_{\text{Src},1} + 2\). \textit{A collision between 3-tuples \( X \) and \( Y \) is detected precisely when \(\text{Port}_{\text{Src},3}\) is greater than \(\text{Port}_{\text{Src},1} + 1\), indicating that both 3-tuples map to the same perturbation table cell \( i \)}.
\end{itemize}

% \begin{sidenote}
The second increment of \(\text{table}[i]\) in the second wrapper step does \alert{not provide any further relevant information} about the 3-tuple \( X \) or about any tuples \( Y \) colliding with it in the filling step, because \(\text{Port}_{\text{Src},3}\) has already been calculated by then. Instead, this increment is only relevant for any other 3-tuple in the wrapper steps that might later map to the same perturbation table cell \( i \).
% \end{sidenote}

The explanation above illustrates only the \alert{core idea of sandwiching} in a simplified example. In practice, several additional factors must be taken into account:

\begin{itemize}
	\item \aalert{Background noise:} In real-world scenarios, there is also \alert{noise} caused by other TCP connection attempts from unrelated processes on the client device. These connections occur alongside the TCP connection attempts of the tracking snippet and can also increment the perturbation table cell \( i \).
	\item \aalert{Multiple connection attempts:} Typically, multiple \alert{bursts of TCP connection attempts} (TCP SYN packets) are established both in the wrapper and the filling steps, each using several different 3-tuples. After applying the sandwiching technique, one knows which 3-tuples produced which source port values at specific points in time, because the \alert{TCP SYN packet headers} include the full attacker 4-tuple. This information can be easily transformed into a mapping from each attacker 3-tuple to its corresponding source port:
	\[
		(\mathrm{IP_{Src}}, \mathrm{IP_{Dst}}, \mathrm{Port_{Dst}}) \;\mapsto\; \mathrm{Port_{Src}}\;\text{.}
	\]
	\ditem{limitations}{Limitations for loopback 3-tuples} Unfortunately, the attack does not work with arbitrary 3-tuples. The tracking snippet cannot directly access the TCP source ports that DHPS generates for 3-tuples, because these ports are read from TCP SYN packet headers, and JavaScript in the \alert{browser’s sandbox} operates at a higher level than the TCP layer. Consequently, there is no way to access TCP SYN packets for \alert{loopback 3-tuples} on the client device, since their destination IP address is the machine itself and these connections remain internal. In contrast, \alert{attacker 3-tuples} target the tracking server’s IP address, allowing the \alert{tracking server} to observe their TCP SYN packets and read the source ports. Therefore, attacker 3-tuples are used as the wrapper in the sandwiching technique to make collisions with loopback 3-tuples observable.
\end{itemize}

The consequence of what is explained in \hyperlink{limitations}{Limitations for loopback 3-tuples} is that, in order to detect which loopback 3-tuples collide with each other, one must observe \alert{collisions between loopback 3-tuples and attacker 3-tuples} using the sandwiching method. By transitivity, if two loopback 3-tuples each collide with the same attacker 3-tuple, then they also collide with each other:
\vspace{-0.6cm}
\begin{center}
	\begin{adjustbox}{max width=\columnwidth}
		\begin{minipage}{0.85\textwidth}
			\[
				\begin{aligned}
					 &
					\begin{aligned}
						 & \begin{array}{c}
							   G_{K_2}\bigl(\text{IP}_{\text{Src}} = 127.0.0.1,\ \text{IP}_{\text{Dst}} = 127.1.2.3,\ \text{Port}_{\text{Dest}} = x_1 \bigr) \\[0.3em]
							   =                                                                                                                             \\[0.3em]
							   G_{K_2}\bigl(\text{IP}_{\text{Src}} = D,\ \text{IP}_{\text{Dst}} = A,\ \text{Port}_{\text{Dest}} = y \bigr)
						   \end{array}
						\\[1em]
						 & \begin{array}{c}
							   G_{K_2}\bigl(\text{IP}_{\text{Src}} = 127.0.0.1,\ \text{IP}_{\text{Dst}} = 127.1.2.3,\ \text{Port}_{\text{Dest}} = x_2 \bigr) \\[0.3em]
							   =                                                                                                                             \\[0.3em]
							   G_{K_2}\bigl(\text{IP}_{\text{Src}} = D,\ \text{IP}_{\text{Dst}} = A,\ \text{Port}_{\text{Dest}} = y \bigr)
						   \end{array}
					\end{aligned}
					\quad \Longrightarrow \quad
					\begin{aligned}
						 & \begin{array}{c}
							   G_{K_2}\bigl(\text{IP}_{\text{Src}} = 127.0.0.1,\ \text{IP}_{\text{Dst}} = 127.1.2.3,\ \text{Port}_{\text{Dest}} = x_1 \bigr) \\[0.3em]
							   =                                                                                                                             \\[0.3em]
							   G_{K_2}\bigl(\text{IP}_{\text{Src}} = 127.0.0.1,\ \text{IP}_{\text{Dst}} = 127.1.2.3,\ \text{Port}_{\text{Dest}} = x_2 \bigr)
						   \end{array}
					\end{aligned}
				\end{aligned}
			\]
		\end{minipage}
	\end{adjustbox}
\end{center}

In phase 2 \ref{sec:phase 2} of the attack, the sandwiching method is used to detect collisions between loopback 3-tuples indirectly, by checking whether they collide with the same attacker 3-tuples. To enable this, it is necessary to have a set of attacker 3-tuples that collectively cover all cells of the perturbation table, ensuring that every cell can be tested for potential collisions. These so-called \alert{unique attacker 3-tuples} have to be first determined in phase 1 \ref{sec:phase 1}, also via the sandwiching method.

\subsection{Phase 1}
\label{sec:phase 1}

The Phase 1 algorithm is depicted in algorithm~\hyperref[alg:phase1]{2}. In each iteration $i$, the attacker generates a new set $S_i$ of \alert{candidate attacker 3-tuples}. These candidate attacker 3-tuples are distinct from those used in previous iterations.

The algorithm utilizes the \alert{sandwiching technique}, introduced earlier in Section~\ref{sec:attack}. In every iteration, the browser performs two bursts of TCP connection attempts in the wrapper and one burst in the filling, as follows:
\begin{itemize}
	\item The \alert{filling} consists of all \alert{unique attacker 3-tuples} discovered so far, all of which are included in the second burst of TCP connection attempts.
	\begin{itemize}
		\item In the first iteration, since no unique attacker 3-tuples have been found yet, this burst is \alert{empty}. However, just because of that, it does not mean that all candidate attacker 3-tuples in $S_i$ necessarily become unique attacker 3-tuples. Candidate attacker 3-tuples \alert{can collide with each other} if they map to the same cell in the perturbation table.
		\item In later iterations, this burst consists of connections to the set $S'_{i-1}$, which contains \alert{all unique attacker 3-tuples discovered so far}.
	\end{itemize}
	\item The \alert{wrapper} comprises new candidate attacker 3-tuples that might be unique and are probed in the first and third bursts of TCP connection attempts. Connections are attempted to all 3-tuples in $S_i$.
\end{itemize}

After performing the sandwiching technique, each attacker 3-tuple \( x \) in the wrapper is determined to be \alert{unique} if it fulfills the following \alert{condition}:

\vspace{-0.2cm}
\begin{minipage}{\columnwidth}
\begin{equation*}
	P'(x) - P(x) = 1 
  	\quad \text{when sandwiching } S'_i \text{ as filling.}
\end{equation*}
\end{minipage}

where \(P(x)\) and \(P'(x)\) are partial functions that map \alert{candidate attacker 3-tuples \( x \) to} the observed \alert{TCP source port} numbers assigned during the first and third bursts of TCP connection attempts probing the wrapper, respectively. These functions are defined only for the set of attacker 3-tuples probed in the corresponding bursts.

This \alert{condition implies} that those attacker 3-tuples in the wrapper, whose source port has incremented by exactly $1$, are the first to map to a perturbation table cell that none of the unique attacker 3-tuples discovered so far in the filling has already been mapped to (cf.\ Figure~\ref{<your_illustration_label>}). Consequently, they do not collide with any of the previously discovered unique attacker 3-tuples and are thereby confirmed as new \alert{unique attacker 3-tuples}, which form the \alert{output} of Phase~1 of the attack algorithm.

\alert{Noise} occurring between the first and second TCP connection attempts using the same attacker 3-tuple in the first and second wrapper steps can increase the value of \texttt{table[i]}, where $i$ is the index of the perturbation table cell associated with that 3-tuple. This \alert{can hide} unique attacker 3-tuples by making their observed increment larger than one. However, this isn’t a problem, because noise can hide a unique mapping, but it \alert{can’t fabricate} one. The only problem is that Phase 1 may require more iterations to find unique attacker 3-tuples for all perturbation table cells, but it does not compromise the correctness of the mapping once established.

The algorithm continues iterating until a unique attacker 3-tuple has been found for every cell of the perturbation table. Formally, it \alert{terminates} as soon as the number of unique attacker 3-tuples found, i.e.\ $\lvert S'_i \rvert$, equals $T$, where $T$ is the number of cells in the perturbation table.

\vspace{0.2cm}
\input{./share/phase1.tex}

% \begin{center}
% 	\begin{minipage}[t]{0.49\textwidth}
% 		\vspace{0cm}
%
% 		\input{./share/phase1.tex}
% 	\end{minipage}
% 	\begin{minipage}[t]{0.49\textwidth}
% 		\vspace{0cm}
%
% 		\input{./share/phase2.tex}
% 	\end{minipage}
% \end{center}

\subsection{Phase 2}
\label{sec:phase 2}

The Phase 2 algorithm is depicted in Algorithm~\hyperref[alg:phase2]{3}. It begins by initializing an empty set $C$ to store \alert{independent pairs of loopback 3-tuples} that collide in the same perturbation table cell, a counter $n \leftarrow 0$ for the \alert{number of independent pairs found}, and an \alert{iteration counter} $i \leftarrow 0$.

In each iteration, the iteration counter is incremented, \(i \leftarrow i+1\). Let \(w\) denote the attacker 3-tuple identified as colliding with the current loopback 3-tuple \(L_i\). A mapping data structure \(B\), implemented as a \alert{dictionary} with attacker 3-tuples as keys, is used to record the first loopback 3-tuple observed for each attacker 3-tuple \(w\). \alert{If a collision is found} and there is already a loopback 3-tuple \(B[w]\) previously mapped to cell \(w\), the pair \((L_i, B[w])\) is added to the set \(C\) as an independent pair, and the counter is incremented, \(n \leftarrow n+1\). \alert{Otherwise}, \(B[w]\) is set to \(L_i\) to remember the first loopback 3-tuple associated with the attacker 3-tuple \(w\).

This algorithm utilizes the sandwiching technique introduced earlier in Section~\ref{sec:attack}. In every iteration, this technique operates as follows:
\begin{itemize}
  \item The \aalert{filling} consists of a burst of several TCP connection attempts to the current loopback 3-tuple $L_i$. Only one loopback 3-tuple is tested at a time because testing multiple loopback 3-tuples simultaneously, without additional design, would prevent determining which loopback 3-tuple caused an increment in which attacker 3-tuple.
  \item The \aalert{wrapper} consists of a burst of TCP connection attempts to all unique attacker 3-tuples from Phase 1~\ref{sec:phase 1}, and recording their assigned source ports $P(x)$.
\end{itemize}

An \alert{unique attacker 2-tuple \(w\)} is said to collide with a \alert{loopback 3-tuple \(L_i\)} if the following \alert{condition} holds:

\begin{minipage}{\columnwidth}
\begin{equation*}
	\bigl(P'(w) - P(w)\bigr) > \varepsilon
	\quad \text{when sandwiching } L_i \text{ as filling.}
\end{equation*}
\end{minipage}

Here, \(P(w)\) and \(P'(w)\) denote the observed \alert{source ports assigned to} the \alert{unique attacker 2-tuple \(w\)} during the first and second wrapper bursts, respectively, when the loopback 3-tuple \(L_i\) is inserted into the filling.

This means that the unique attacker 3-tuple \(w\) shares the same perturbation table cell as the loopback 3-tuple \(L_i\). Since \alert{only one} loopback 3-tuple \(L_i\) repeatedly establishes TCP connections during the filling, only one unique attacker 3-tuple \(w\) exhibits a \alert{significant increment} greater than \(\varepsilon\), while all other unique attacker 3-tuples do not. Because each unique attacker 3-tuple \(w\) represents a distinct perturbation table cell (even if the exact cell is unknown), it becomes possible to identify which loopback 3-tuples \(L_i\) collide with which perturbation table cells represented by unique attacker 3-tuples, by knowing the unique attacker 3-tuples \(w\) for which a loopback 3-tuple \(L_i\) causes a significant increment.

Thus, it is possible to determine a \alert{structure} of loopback 3-tuples that collide in same perturbation table cells and use this structure as a \alert{device ID}. This is achieved by collecting a set of \alert{independent pairs} (explained \hyperlink{independant}{here}) of loopback destination ports. The \alert{output} of this process is a device ID composed of independent pairs of destination ports of loopback 3-tuples, which represent the structure of collisions within perturbation table cells.

A significant increment greater than \(\varepsilon\) is required to reliably detect collisions despite \alert{noise}. The same unique attacker 3-tuple \(x\) is contacted \alert{multiple times} to produce a detectable increment in its perturbation table cell, ensuring that any increments caused by unrelated TCP connections on the device (noise) are outweighed.

% The algorithm \alert{terminates} as soon as the following condition is satisfied: 
% \[
%   n \ge n^*[i],
% \]
% where $n^*[i]$ denotes the required number of independent pairs after $i$ iterations to ensure that the probability $P^l_D(n)$ of a random device yielding the same device ID is below the target threshold $p^*$.
%
% This termination condition is expressed in terms of the number $n$ of independent pairs rather than inserted directly into the probability function because $P^l_D(n)$ depends only on $n$ and not on the specific collision structure. Thus, by checking $n \ge n^*[i]$, the attacker ensures that the probability of a device ID collision with another device remains below $p^*$ without repeatedly calculating the exact probability.

The algorithm \alert{terminates} as soon as the following condition is satisfied:

\vspace{-0.2cm}
\begin{minipage}{\columnwidth}
\[
  n \ge n^*[i],
\]
\end{minipage}

where \( n^*[i] \) denotes the required \alert{number of independent pairs} after \( i \) \alert{iterations} to ensure that the \alert{probability} \( P^l_D(n) \) of a random device yielding the same device ID remains below the target threshold \( p^* \).

This condition guarantees:
\vspace{-0.8cm}
\begin{center}
  \begin{adjustbox}{max width=\columnwidth}
    \begin{minipage}[t]{0.6\textwidth}
\[
  \underbrace{P^l_D(n) 
  = 1 - \left(1 - \frac{1}{T}\right)^n}_{\text{probability that a random device yields same device ID}}
  \;<\;
  \underbrace{\frac{p_{\text{dev}}}{N_D} = p^*}_{\text{target threshold per device}},
\]
    \end{minipage}
  \end{adjustbox}
\end{center}
where \( T \) is the \alert{size of the perturbation table}, \( N_D \) is the \alert{total number of devices} under consideration, and \( p_{\text{dev}} \) is the \alert{acceptable probability} that any device collides with the target device ID.

The required value \( n^*[i] \) is determined as:

\begin{minipage}{\columnwidth}
\[
  n^*[i] 
  = \min \left\{ n \;\middle|\; 1 - \left(1 - \frac{1}{T}\right)^n < p^* \right\}.
\]
\end{minipage}

Values of \( n^*[i] \) are \alert{precomputed} and stored in a table to avoid repeated evaluation of \( P^l_D(n) \) during the attack. The termination condition is expressed in terms of \( n \) rather than inserted directly into the probability function because \( P^l_D(n) \) depends only on \( n \) and \alert{not on the specific collision structure}. By checking \( n \ge n^*[i] \), the attacker ensures that the probability of a device ID collision with another device remains below \( p^* \) \alert{without recomputing probabilities} each time.

\vspace{0.2cm}
\input{./share/phase2.tex}

\section{Countermeasures}
\label{sec:countermeasures}

\iftoggle{longversion}{
The \alert{root cause} of the attack described in the paper is that the Double-Hash Port Selection algorithm (DHPS) generates TCP source ports deterministically, allowing attackers to detect hash collisions in shared perturbation table entries and derive stable device-specific patterns.

An \alert{ideal solution} would be to create a private perturbation table for each network namespace and interface, preventing attackers from observing stable collisions. However, this is impractical due to high memory consumption when many containers or interfaces exist.
}{}

In \alert{general}, \alert{countermeasures} to prevent this attack focus on making hash collisions less frequent or making it much more difficult for attackers to detect them. The paper proposes several modifications to DHPS, and these were incorporated into the Linux kernel through a security patch. The main countermeasures are:
%
\begin{itemize}
	\item \aalert{Increase table size $T$:}
	A larger perturbation table reduces hash collisions and increases attack cost.
	\textit{The concrete change made in the Linux kernel was to increase the table size to $T = 64K$.}

	\item \aalert{Periodic re-keying:}
	Changing DHPS’s secret key periodically invalidates previously discovered collisions, though it risks reusing ports for the same 3-tuple too soon.
	\textit{The concrete change made in the Linux kernel was to perform re-keying every 10 seconds.}

	\item \aalert{Introduce more noise:}
	Adding randomness to perturbation table increments makes collisions harder to detect.
	\textit{The concrete change made in the Linux kernel was to randomize increments uniformly between 1 and 8.}
\end{itemize}

\iftoggle{longversion}{
These countermeasures were integrated into Linux versions 5.18 and 5.19, making the attack significantly harder or infeasible.
}{}

\newpage
\section{Appendix}
\label{sec:appendix}
\pagenumbering{Alph}

\subsection{Terminology and Conventions}
\label{sec:terminology and conventions}

Throughout this report, the following terminology and conventions are used:
\begin{itemize}
	\item Clickable hyperlinks look like \hyperref[sec:terminology and conventions]{this}, and normal highlighted text looks like \alert{this}.
	\item All sorts of captions like titles of captions or headwords are written like this \aalert{Caption} and all sorts of just highlighted words that are neither of what has just been mentioned are written like \alert{this}.
	\ditem{unique}{Unique attacker 3-tuples} An attacker 3-tuples where each uniquely covers one cell of the perturbation table.
	\ditem{collision}{Collision of 3-tuples} Actually means collision of (attacker / loopback) 3-tuples in the same perturbation table cell but the last part is omitted for brevity.
	\ditem{candidate}{Candidate attacker 3-tuples} Possible candidates that could become unique attacker 3-tuples if they do not collide with any of the already found unique attacker 3-tuples.
	\ditem{increment}{Increment source port by x} When it is stated that an attacker 3-tuple had a source port incremented by x, it means the difference between the source ports generated by DHCP for the same attacker 3-tuple (as read from the TCP SYN packet) when establishing a TCP connection at the beginning and end of the sandwich method.
\end{itemize}
%
\vspace{0.5cm}
\section{Bibliography}
\label{sec:bibliography}

\printbibliography[heading=none]

\end{document}
