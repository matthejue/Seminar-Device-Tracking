\documentclass{report}

\input{./content/packages}
\input{./content/declarations}
\input{./content/desgin}

\begin{document}

\fontsize{8pt}{9pt}\selectfont
\newgeometry{margin=2cm, bottom=2cm, top=2cm}

\input{./content/titlepage}

\tableofcontents
\thispagestyle{empty}
\clearpage
\pagestyle{plain}
\pagenumbering{Roman}

\listoffigures

\clearpage
\fancypagestyle{plain}{%
	\fancyhf{}
	\fancyfootoffset{0.5cm}
	\fancyheadoffset{0.5cm}
	\fancyhead[L]{\color{PrimaryColor}\small\leftmark}
	\fancyhead[R]{\color{PrimaryColor}\small\rightmark}
	\renewcommand{\headrulewidth}{0.4mm}
	\renewcommand{\headrule}{\hbox to\headwidth{\color{PrimaryColor}\leaders\hrule height \headrulewidth\hfill}}
	\fancyfoot[C]{\thepage}
}
\pagenumbering{arabic}
\pagestyle{default}

\chapter{Introduction}
\label{sec:introduction}

In 2018, the \alert{Meltdown} and \alert{Spectre} attacks caused widespread concern by revealing how modern CPUs’ performance features could be exploited to read sensitive data from memory that should have remained inaccessible to user processes.

These attacks demonstrated a broader principle: that subtle side effects in complex systems can leak internal information not intended to be observable.

In a similar spirit, researchers Moshe Kol, Amit Klein, and Yossi Gilad from the Hebrew University of Jerusalem discovered an attack that exploits Linux’s \alert{TCP source port selection algorithm} to track devices.

Like Meltdown, this attack targets \alert{security} and compromises confidentiality, but not by directly revealing secret data, but by exploiting side effects of \alert{hash collisions} that manifest as observable patterns in how \alert{TCP source ports} are incremented across connections. These patterns allow an attacker to infer a fingerprint uniquely tied to a \alert{secret device-specific key}.

\section{About this report}
\label{sec:goal_of_this_report}

The goal of this report is to provide insight into a specific browser-based device tracking technique described in the paper~\cite{kol2022devicetrackinglinuxsnew}. This report explains what this tracking method exploits and how it operates, describes the different phases of the attack, and discusses possible countermeasures to mitigate the vulnerability.

This report mainly aims to present the contents of the original paper in a shorter, easier-to-understand, and differently structured way, since the original paper requires additional technical knowledge to be fully understood and has the key information scattered across various sections.

Readers are encouraged to first consult Section~\ref{sec:terminology and conventions} for an overview of terminology and conventions used throughout this report.

\alert{It should be emphasized that this is purely a report explaining and summarizing the result of other researchers' work, without presenting original research or claiming the findings as the author's own.}

\section{Browser-based Device tracking}
\label{sec:Online browser-based device tracking}

\alert{Browser-based device tracking} is a widespread practice in which websites or advertisers use information collected through the user’s web browser to identify devices across sessions and different websites.

Traditionally, cross-site tracking relied on \alert{third-party cookies}, but growing privacy concerns and technical defenses like privacy modes and cookie blocking have pushed trackers to seek new methods that work across browsers and networks.

A major \alert{privacy risk} of device tracking is linking a user’s identities across different contexts like networks, browsers, or privacy modes without their awareness or consent.


Device tracking techniques, particularly browser-based tracking, face challenges in reliably identifying devices under changing conditions such as switching browsers, networks, or privacy modes. One important problem is the \alert{golden image challenge}, where many identical devices with the same hardware and software configuration need to be distinguished from each other.

Device tracking techniques can be broadly categorized into the following two groups:

\begin{itemize}
	\item \aalert{Tagging techniques:} These techniques insert an ID directly into the device, usually at the browser level. Examples include caching resources in the browser or storing data in mechanisms like cookies. However, tagging techniques are often ineffective when users switch to privacy modes or clear stored data.
	\item \aalert{Fingerprinting techniques:} These techniques measure characteristics of the system or browser to distinguish devices. Examples include differences in fonts, hardware details, or system language. However, fingerprinting techniques often struggle to solve the golden image challenge, as identical devices may produce identical fingerprints.
\end{itemize}

The attack described in the paper is a \alert{fingerprinting technique}, as it derives a device-specific identifier from the behavior of the operating system’s TCP source port selection rather than storing data in the browser. Unlike typical fingerprinting methods, it can successfully solve the \alert{golden image challenge}, because the identifier it produces depends on a per-device secret key generated at system boot. This allows it to distinguish between devices even when they share identical hardware and software configurations, and it remains effective across different browsers, privacy modes, networks, persisting until the device restarts.
% , and some VPNs

\section{Source Port Selection}
\label{sec:source port selection}

Source port selection is a mechanism used by the TCP/IP stack of operating systems to choose a TCP source port number for outbound TCP connections. It is required because a TCP connection between two endpoints is uniquely identified by the \alert{4-tuple}, consisting of:
\begin{itemize}
	\item the \aalert{source IP} address,
	\item the \aalert{source port},
	\item the \aalert{destination IP} address, and
	\item the \aalert{destination port}.
\end{itemize}

\alert{Ports} exist so that multiple simultaneous network connections can operate on the same device, even to the same destination IP address and destination port. For example, a single machine might want to establish several independent TCP connections to the same remote server, and different source ports allow the operating system to distinguish these connections.

A straightforward way to select source ports would be simply to choose the next available free port in sequence. But this approach is problematic because it fails to achieve two important goals that are also described in the paper:

\begin{itemize}
	\item \aalert{Security:} Predictable source port numbers make it easier for attackers to perform off-path attacks, such as blind reset or data injection attacks, as they have to guess key connection details like the TCP 4-tuple (source and destination IP addresses and ports) and sequence numbers.
	\item \aalert{Functionality:} Quickly reusing the same source port can cause failures because earlier connections might still be active or in the \texttt{TIME\_WAIT} state on the server side. Reusing the same 4-tuple too soon can lead to errors or dropped connections.
\end{itemize}

\subsection{Double-Hash Port Selection Algorithm (DHPS)}
\label{sec:double-hash port selection algorithm}

To address these goals, several algorithms for TCP source port selection have been defined, including the \alert{Double-Hash Port Selection (DHPS)} algorithm, described in RFC 6056\cite{larsenRecommendationsTransportProtocolPort2011}.

TCP source ports are divided into different ranges, each serving distinct purposes:
\begin{itemize}
	\item \aalert{Well-known ports} (typically ports 0–1023) are reserved for specific services such as HTTP (port 80) or HTTPS (port 443).
	\item \aalert{Registered ports} (typically ports 1024–49151) are assigned to user applications or services but are not ephemeral.
	\item \aalert{Ephemeral ports} (typically in the higher range, e.g. 32768–60999 in Linux) are dynamically allocated by the operating system for short-lived client-side connections.
\end{itemize}

For the DHPS algorithm, the \alert{ephemeral port} range is particularly relevant because it represents the pool from which source ports are selected for outbound connections.

DHPS selects a TCP \alert{source port} for outbound TCP connections from the ephemeral range based on a given \alert{3-tuple}, consisting of:
\begin{itemize}
	\item the \alert{source IP} address,
	\item the \alert{destination IP} address, and
	\item the \alert{destination port}
\end{itemize}
and by this completes the connection’s \alert{4-tuple}. To perform this selection, it uses two \alert{cryptographic keyed-hash functions} with separate, independent keys:
\begin{itemize}
	\item \( F_{K_1} \), which maps its inputs to a large range of integers, using the key \( K_1 \),
	\item \( G_{K_2} \), which maps its inputs to a range corresponding to the size of the \alert{perturbation table} \texttt{table}, using the key \( K_2 \).
\end{itemize}

The \alert{perturbation table} in the DHPS algorithm is a fixed-size array of integer counters used to add randomness and unpredictability to TCP source port selection. In Linux, it consists of $T = 256$ entries, all initially set to zero. Each time a connection uses a specific table entry, the counter at that index is incremented, so the table evolves over time as more connections are made. This mechanism ensures that successive connections to the same destination do not repeatedly use the same source port, thus improving security and preventing collisions of TCP 4-tuples.

The algorithm operates as described in Algorithm~\ref{alg:dhps_port_selection}:
\begin{itemize}
	\item It calculates an \texttt{offset} by applying the keyed hash function \( F_{K_1} \) to the 3-tuple.
	\item It calculates an \texttt{index} into the perturbation table by applying the keyed hash function \( G_{K_2} \) to the 3-tuple.
	\item It computes a candidate port number using:
	\[
		\texttt{candidate\_port} = \texttt{min\_ephemeral} + \bigl((\texttt{offset} + \text{table[\texttt{index}]}) \bmod \texttt{num\_ephemeral}\bigr)
	\]
	where \texttt{min\_ephemeral} and \texttt{num\_ephemeral} define the allowed range of ephemeral ports.
	\item It checks whether the candidate port is suitable. If the port is already in use or otherwise unsuitable, the algorithm increments the entry in the perturbation \texttt{table} at the calculated \texttt{index}. As a consequence, the next time this same table entry is used, the computed port number is also incremented by 1, unless the port is already at the end of the ephemeral range, in which case it wraps around to the beginning of the range.
	\item This process repeats until a free port is found or no ports remain. This loop is controlled by the variable \texttt{count}, which is decremented on each attempt and terminates the algorithm when it reaches zero.
\end{itemize}

\begin{center}
	% \begin{adjustbox}{scale=1}
	\begin{minipage}[t]{0.5\textwidth}
		\vspace{0cm}

		\input{./share/dhps_algorithm.tex}
	\end{minipage}
	% \end{adjustbox}
\end{center}


\vspace{0.5cm}
\chapter{Attack}
\label{sec:attack}

In the attack, two main parties are involved:

\begin{itemize}
    \item \aalert{Tracking server}: This server is controlled by the \alert{attacker} and receives the TCP connection attempts initiated from the client device. It analyzes the observed TCP source ports in order to calculate a device ID and track the victim.%across networks and browsing sessions.
    
    \item \aalert{Client device}: This is the \alert{victim’s} (Linux-based) device, which runs a browser that renders a web page containing a \alert{tracking snippet}, a small piece of HTML and JavaScript code that operates within the browser’s JavaScript sandbox. When the browser renders the tracking snippet and executes the JavaScript code, the code causes the browser to initiate a series of TCP connection attempts to the \alert{tracking server}, interleaved with TCP connection attempts to a \alert{localhost address}.
\end{itemize}

Two types of 3-tuples are distinguished in the attack:

\begin{itemize}
	\item \aalert{Attacker 3-tuples:} These have the form
	\begin{equation*}
		(\mathrm{IP_{Src}}_{\text{Internet-facing}}, \mathrm{IP_{Dst}}_{\text{tracking server}}, \mathrm{Port_{Dst}})
	\end{equation*}
	where the source IP address is the Internet-facing address of the device, and the destination IP address belongs to the tracking server.

	\item \aalert{Loopback 3-tuples:} These have the form
	\begin{equation*}
		(\mathrm{IP_{Src}} = 127.0.0.1, \mathrm{IP_{Dst}} = 127.1.2.3, \mathrm{Port_{Dst}})
	\end{equation*}
	where both source and destination IP addresses are loopback addresses on the device. \alert{Loopback addresses} refer to the local machine itself and are used for internal communication within the device. Only the \alert{destination port} varies among loopback 3-tuples.
\end{itemize}

We will see later why distinguishing these two types of 3-tuples is important.

The fingerprint mentioned in the introduction Section~\ref{sec:introduction} of this report is the \alert{device ID} that is built by indirectly observing the structure formed by \alert{collisions of loopback 3-tuples} inside the perturbation table. Such a collision occurs if two loopback 3-tuples differing only in their destination port numbers $x$ and $y$ satisfy

\begin{equation*}
	G_{K_{2}}\bigl(\mathrm{IP}_{\mathrm{Src}} = 127.0.0.1,\; \mathrm{IP}_{\mathrm{Dst}} = 127.1.2.3,\; \mathrm{Port}_{\mathrm{Dst}} = x \bigr)
	=
	G_{K_{2}}\bigl(\mathrm{IP}_{\mathrm{Src}} = 127.0.0.1,\; \mathrm{IP}_{\mathrm{Dst}} = 127.1.2.3,\; \mathrm{Port}_{\mathrm{Dst}} = y \bigr)
\end{equation*}

meaning that both tuples hash to the same cell in the perturbation table under the function $\mathrm{G_{K_2}}$. These collisions depend solely on the kernel’s \alert{secret key} $K_2$, which is the same secret key mentioned in the introduction Section~\ref{sec:introduction}. This key is randomly generated each time the \alert{system starts} and remains constant as long as the device stays powered on. Consequently, the device ID is directly tied to $K_2$ and persists across browser sessions, private browsing modes, and network changes.

The device ID consists of the set of all such colliding pairs:

\[
	\left\{ \bigl(x_i, y_i\bigr) \;\middle|\; i = 1, \ldots, n \right\}
\]

where each pair $(x_i, y_i)$ represents \alert{two destination ports} whose corresponding loopback 3-tuples collide into the same perturbation table cell. These pairs are chosen to be \alert{independent}, meaning that each one captures a distinct piece of evidence about how the secret key $K_2$ maps destination ports into perturbation table cells. Specifically, if $k$ loopback 3-tuples fall into the same cell, there are $\binom{k}{2}$ possible pairs, but only $k-1$ of these are independent. The independent pairs are chosen as

\[
	(x_1, x_2),\; \ldots,\; (x_1, x_k),
\]

where $x_1, x_2, \ldots, x_k$ are the destination ports of the colliding loopback 3-tuples. This means that for each group of colliding loopback tuples, the first discovered tuple $x_1$ is paired with every other tuple in that group, as further detailed in Phase 2 of the attack. Pairs beyond these $k-1$ would be \alert{dependent} because their collisions are fully implied by the existing pairs\footnote{For example, knowing that both $(x_1, x_2)$ and $(x_1, x_3)$ collide makes it redundant to additionally record $(x_2, x_3)$.}. This is crucial for the probability analysis in the paper, where the probability that a random device produces the same set of collisions depends solely on the number of independent pairs observed.

A device ID based on collisions of \alert{attacker 3-tuples} would not remain consistent across networks because the source IP address visible to external servers typically changes whenever the device connects to a different network. In contrast, \alert{loopback 3-tuples} with loopback addresses such as $127.x.x.x$ are internal to the device and remain stable across networks, making them suitable for deriving a consistent device ID.

The nature of the attack resembles the principle of a \alert{particle accelerator}, where tiny particles cannot be observed directly and must instead be studied through the side effects they produce. Similarly, because there is no direct access to kernel internals such as the perturbation table, collisions of loopback 3-tuples (used to build the device ID) within the perturbation table \alert{cannot be observed directly}. Instead, such collisions must be inferred indirectly by analyzing the side effects that appear as observable patterns in how TCP source ports are incremented across connections by DHPS.

These observable patterns arise because, in the DHPS algorithm, each cell in the perturbation table maintains a counter that is incremented by 1 in a predictable manner every time it is used to generate a candidate source port, as shown in Algorithm~\ref{alg:dhps_port_selection}, line~9:
\[
\texttt{table[index]} \leftarrow \texttt{table[index]} + 1.
\]
A technique that exploits these predictable TCP source port increments to detect collisions of 3-tuples (attacker or loopback) is known as \alert{sandwiching}. The general principle of sandwiching is that there is a \alert{wrapper} and a \alert{filling}, as visualized in the following schema:

\begin{center}
\begin{tblr}{
  colspec={|c|Q[l]|},
  row{1}={bg=PrimaryColor,fg=white,font=\bfseries},
  row{2}={bg=PrimaryColorDimmed},
  row{3}={bg=SecondaryColorDimmed},
  row{4}={bg=PrimaryColorDimmed},
  hlines
}
\textbf{Step} & \textbf{Calculation} \\ 

Wrapper & 
\(
\begin{aligned}
&i = G_{K_2}(\text{IP}_{\text{Src},X}, \text{IP}_{\text{Dst},X}, \text{Port}_{\text{Dst},X}) \\
&\text{offset}_X = F_{K_1}(\text{IP}_{\text{Src},X}, \text{IP}_{\text{Dst},X}, \text{Port}_{\text{Dst},X}) \\
&\text{Port}_{\text{Src},1} = \text{min\_ephemeral} + \bigl(\text{offset}_X + \text{table}[i]\bigr)\bmod \text{num\_ephemeral} \\
&\text{table}[i] = \text{table}[i] + 1
\end{aligned}
\) \\

Filling & 
\(
\begin{aligned}
&j = G_{K_2}(\text{IP}_{\text{Src},Y}, \text{IP}_{\text{Dst},Y}, \text{Port}_{\text{Dst},Y}) \\
&\text{offset}_Y = F_{K_1}(\text{IP}_{\text{Src},Y}, \text{IP}_{\text{Dst},Y}, \text{Port}_{\text{Dst},Y}) \\
&\text{Port}_{\text{Src},2} = \text{min\_ephemeral} + \bigl(\text{offset}_Y + \text{table}[j]\bigr)\bmod \text{num\_ephemeral} \\
&\text{table}[j] = \text{table}[j] + 1
\end{aligned}
\) \\

Wrapper & 
\(
\begin{aligned}
&i = G_{K_2}(\text{IP}_{\text{Src},X}, \text{IP}_{\text{Dst},X}, \text{Port}_{\text{Dst},X}) \\
&\text{offset}_X = F_{K_1}(\text{IP}_{\text{Src},X}, \text{IP}_{\text{Dst},X}, \text{Port}_{\text{Dst},X}) \\
&\text{Port}_{\text{Src},3} = \text{min\_ephemeral} + \bigl(\text{offset}_X + \text{table}[i] + \delta \bigr)\bmod \text{num\_ephemeral} \\
&\text{table}[i] = \text{table}[i] + 1
\end{aligned}
\) \\
\end{tblr}
\end{center}

\vspace{0.5em}

where
\[
\delta =
\begin{cases}
1, & \text{if } i \neq j,\ \text{meaning that perturbation table cell } i \text{ was not used in the filling step,} \\
2, & \text{if } i = j,\ \text{meaning that perturbation table cell } i \text{ was used in the filling step.}
\end{cases}
\]

\begin{itemize}
    \item In the \aalert{first wrapper step}, DHPS calculates \(\text{Port}_{\text{Src},1}\) for the 3-tuple \( X \), based on the current value in cell \( i \) of the perturbation table. Afterwards, \(\text{table}[i]\) is incremented by 1.
    \item In the \aalert{filling step}, a different 3-tuple \( Y \) is used, producing \(\text{Port}_{\text{Src},2}\) based on cell \( j \). If \( j = i \), then \(\text{table}[i]\) is incremented again.
    \item In the \aalert{second wrapper step}, DHPS calculates \(\text{Port}_{\text{Src},3}\) for the same 3-tuple \( X \). If \( j \neq i \), then \(\text{Port}_{\text{Src},3} = \text{Port}_{\text{Src},1} + 1\). Otherwise, if \( j = i \), then \(\text{Port}_{\text{Src},3} = \text{Port}_{\text{Src},1} + 2\). \textit{A collision between 3-tuples \( X \) and \( Y \) is detected precisely when \(\text{Port}_{\text{Src},3}\) is greater than \(\text{Port}_{\text{Src},1} + 1\), indicating that both 3-tuples map to the same perturbation table cell \( i \)}.
\end{itemize}

\begin{sidenote}
  The second increment of \(\text{table}[i]\) in the second wrapper step does \alert{not provide any further relevant information} about the 3-tuple \( X \) or about any tuples \( Y \) colliding with it in the filling step, because \(\text{Port}_{\text{Src},3}\) has already been calculated by then. Instead, this increment is only relevant for any other 3-tuple in the wrapper steps that might later map to the same perturbation table cell \( i \).
\end{sidenote}

The explanation above illustrates only the \alert{core idea of sandwiching} in a simplified example. In practice, several additional factors must be taken into account:

\begin{itemize}
    \item \aalert{Background noise:} In real-world scenarios, there is also \alert{noise} caused by other TCP connection attempts from unrelated processes on the client device. These connections occur alongside the TCP connection attempts of the tracking snippet and can also increment the perturbation table cell \( i \).
    \item \aalert{Multiple connection attempts:} Typically, multiple \emph{bursts of TCP connection attempts (TCP SYN packets)} are established both in the wrapper and the filling steps, each using several different 3-tuples. After applying the sandwiching technique, one knows which 3-tuples produced which source port values at specific points in time, because the \alert{TCP SYN packet headers} include the full attacker 4-tuple. This information can be easily transformed into a mapping from each attacker 3-tuple to its corresponding source port:
      \[
        (\mathrm{IP_{Src}}, \mathrm{IP_{Dst}}, \mathrm{Port_{Dst}}) \;\mapsto\; \mathrm{Port_{Src}}\;\text{.}
      \]
    \ditem{limitations}{Limitations for loopback 3-tuples} Unfortunately, the attack does not work with arbitrary 3-tuples. The tracking snippet cannot directly access the TCP source ports that DHPS generates for 3-tuples, because these ports are read from TCP SYN packet headers, and JavaScript in the \alert{browser’s sandbox} operates at a higher level than the TCP layer. Consequently, there is no way to access TCP SYN packets for \alert{loopback 3-tuples} on the client device, since their destination IP address is the machine itself and these connections remain internal. In contrast, \alert{attacker 3-tuples} target the tracking server’s IP address, allowing the \alert{tracking server} to observe their TCP SYN packets and read the source ports. Therefore, attacker 3-tuples are used as the wrapper in the sandwiching technique to make collisions with loopback 3-tuples observable.
\end{itemize}

The consequence of what is explained in \hyperlink{limitations}{Limitations for loopback 3-tuples} is that, in order to detect which loopback 3-tuples collide with each other, one must observe \alert{collisions between loopback 3-tuples and attacker 3-tuples} using the sandwiching method. By transitivity, if two loopback 3-tuples each collide with the same attacker 3-tuple, then they also collide with each other:

\begin{center}
\begin{adjustbox}{scale=0.9}
  \begin{minipage}{1.1\textwidth}
    \[
\begin{aligned}
&
\begin{aligned}
& \begin{array}{c}
G_{K_2}\bigl(\text{IP}_{\text{Src}} = 127.0.0.1,\ \text{IP}_{\text{Dst}} = 127.1.2.3,\ \text{Port}_{\text{Dest}} = x_1 \bigr) \\[0.3em]
= \\[0.3em]
G_{K_2}\bigl(\text{IP}_{\text{Src}} = D,\ \text{IP}_{\text{Dst}} = A,\ \text{Port}_{\text{Dest}} = y \bigr)
\end{array}
\\[1em]
& \begin{array}{c}
G_{K_2}\bigl(\text{IP}_{\text{Src}} = 127.0.0.1,\ \text{IP}_{\text{Dst}} = 127.1.2.3,\ \text{Port}_{\text{Dest}} = x_2 \bigr) \\[0.3em]
= \\[0.3em]
G_{K_2}\bigl(\text{IP}_{\text{Src}} = D,\ \text{IP}_{\text{Dst}} = A,\ \text{Port}_{\text{Dest}} = y \bigr)
\end{array}
\end{aligned}
\quad \Longrightarrow \quad
\begin{aligned}
& \begin{array}{c}
G_{K_2}\bigl(\text{IP}_{\text{Src}} = 127.0.0.1,\ \text{IP}_{\text{Dst}} = 127.1.2.3,\ \text{Port}_{\text{Dest}} = x_1 \bigr) \\[0.3em]
= \\[0.3em]
G_{K_2}\bigl(\text{IP}_{\text{Src}} = 127.0.0.1,\ \text{IP}_{\text{Dst}} = 127.1.2.3,\ \text{Port}_{\text{Dest}} = x_2 \bigr)
\end{array}
\end{aligned}
\end{aligned}
\]
  \end{minipage}
\end{adjustbox}
\end{center}

In phase 2 \ref{sec:phase 2} of the attack, the sandwiching method is used to detect collisions between loopback 3-tuples indirectly, by checking whether they collide with the same attacker 3-tuples. To enable this, it is necessary to have a set of attacker 3-tuples that collectively cover all cells of the perturbation table, ensuring that every cell can be tested for potential collisions. These so-called \alert{unique attacker 3-tuples} have to be first determined in phase 1 \ref{sec:phase 1}, also via the sandwiching method.

\section{Phase 1}
\label{sec:phase 1}

The algorithm utilizes the \alert{sandwiching technique}, introduced earlier in Section~\ref{sec:attack}. The technique operates as follows:

\begin{itemize}
    \item The \alert{filling} consists of all \alert{unique attacker 3-tuples} discovered so far, all of which are included in the second burst of TCP connection attempts.
    \item The \alert{wrapper} comprises new candidate attacker 3-tuples that might be unique and are probed in the first and third bursts of TCP connection attempts.
\end{itemize}

After performing the sandwiching technique, each attacker 3-tuple \( x \) in the wrapper is determined to be \alert{unique} if it fulfills the following \alert{condition}:
\begin{equation}
    P'(x) - P(x) = 1,
\end{equation}
where \(P(x)\) and \(P'(x)\) are partial functions that map \alert{attacker 3-tuples \( x \) to} the observed \alert{TCP source port} numbers assigned during the first and third bursts of TCP connection attempts probing the wrapper, respectively. These functions are defined only for the set of attacker 3-tuples probed in the corresponding bursts.

This \alert{condition implies} that those attacker 3-tuples in the wrapper, whose source port has incremented by exactly $1$, are the first to map to a perturbation table cell that none of the unique attacker 3-tuples discovered so far in the filling has already been mapped to (cf.\ Figure~\ref{<your_illustration_label>}). Consequently, they do not collide with any of the previously discovered unique attacker 3-tuples and are thereby confirmed as new \alert{unique attacker 3-tuples}, which form the \alert{output} of Phase~1 of the attack algorithm.

\alert{Noise} occurring between the first and second TCP connection attempts using the same attacker 3-tuple in the first and second wrapper steps can increase the value of \texttt{table[i]}, where $i$ is the index of the perturbation table cell associated with that 3-tuple. This \alert{can hide} unique attacker 3-tuples by making their observed increment larger than one. However, this isn’t a problem, because noise can hide a unique mapping, but it \alert{can’t fabricate} one. The only problem is that Phase 1 may require more iterations to find unique attacker 3-tuples for all perturbation table cells, but it does not compromise the correctness of the mapping once established.

More precisely, the steps of the Phase 1 algorithm~\ref{alg:phase1} are as follows:
\begin{itemize}
    \item In each iteration $i$, the attacker generates a new set $S_i$ of attacker 3-tuples as candidate destinations. These destinations are distinct from those used in previous iterations.
    
    \item The browser performs three bursts of TCP connection attempts:
    \begin{itemize}
        \item \textbf{Wrapper (first burst):} connections are attempted to all 3-tuples in $S_i$.
        
        \item \textbf{Filling (second burst):} 
        \begin{itemize}
            \item In the first iteration, since no unique attacker 3-tuples have been found yet, this burst is empty. However, just because of that, it does not mean that all candidate attacker 3-tuples in $S_i$ necessarily become unique attacker 3-tuples. Candidate attacker 3-tuples can collide with each other if they map to the same cell in the perturbation table. Such collisions are detected through the source port differences observed between the two wrapper bursts.
            
            \item In later iterations, this burst consists of connections to the set $S'_{i-1}$, which contains all unique attacker 3-tuples found so far.
        \end{itemize}
        
        \item \textbf{Wrapper (third burst):} connections are attempted again to all 3-tuples in $S_i$.
    \end{itemize}
    
    \item The attacker compares the source ports assigned to the connections in the first and third bursts (the wrapper) for each 3-tuple in $S_i$. If the difference between the two source ports for a 3-tuple is exactly 1, it indicates that this attacker 3-tuple maps uniquely to a single cell in the perturbation table and does not share the cell with any other tested 3-tuple. Such 3-tuples are added to $S'_i$.
    
    \item The algorithm continues iterating until the number of unique attacker 3-tuples found, i.e. $\lvert S'_i \rvert$, equals $T$, where $T$ is the number of cells in the perturbation table. \textbf{The algorithm terminates when the condition $\lvert S'_i \rvert = T$ is met.}
\end{itemize}


\begin{center}
	% \begin{adjustbox}{scale=0.6}
	\begin{minipage}[t]{0.5\textwidth}
		\vspace{0cm}

		\input{./share/phase1.tex}
	\end{minipage}
	% \end{adjustbox}
\end{center}

% \section{Phase 1 old}
% \label{sec:phase 1 old}
%
% Phase 1 of the attack aims to identify a set of attacker 3-tuples such that each one maps uniquely to a different cell of the perturbation table used by the Double-Hash Port Selection (DHPS) algorithm in the Linux kernel. This set of attacker 3-tuples is essential for Phase 2, because collisions between loopback 3-tuples cannot be directly observed. Instead, these collisions must be inferred by detecting whether different loopback 3-tuples collide with the \emph{same} attacker 3-tuple.
%
% Phase 1 uses a \alert{sandwiching method} consisting of three bursts of TCP SYN packets:
%
% \begin{itemize}
% 	\item \alert{First Burst:} Sent to a set $S_i$ of new attacker 3-tuple candidates.
% 	\item \alert{Second Burst:} Sent to all attacker 3-tuples currently known to uniquely cover perturbation table cells (the set $S'_{i-1}$).
% 	\item \alert{Third Burst:} Sent again to the same set $S_i$ of new attacker 3-tuple candidates.
% \end{itemize}
%
% Thus, the \emph{new attacker 3-tuple candidates are outside the sandwich}, and the \emph{known attacker 3-tuples that cover cells of the perturbation table are inside the sandwich}.
%
% In the very first round of Phase 1, there are no known attacker 3-tuples to place inside the sandwich. Therefore, the second burst of the sandwich is effectively empty. Nevertheless, collisions can still be detected in this round because some attacker 3-tuple candidates in $S_i$ may collide with each other. If the source port difference for an attacker 3-tuple candidate between the first and third bursts is greater than $1$, this indicates that it shares a perturbation table cell with another candidate in $S_i$ and thus cannot be added to the set of unique attacker 3-tuples.
%
% An attacker 3-tuple candidate $x \in S_i$ is determined to map to a previously uncovered perturbation table cell if the following condition holds:
%
% \[
% 	P'(x) - P(x) = 1
% \]
%
% where $P(x)$ and $P'(x)$ denote the source ports assigned to $x$ in the first and third bursts, respectively. If this difference is exactly $1$, it means no collision occurred with any previously known attacker 3-tuple or with other candidates in $S_i$, and thus $x$ is the first 3-tuple to map to that perturbation table cell.
%
% Although it is impossible to directly determine to which specific index in the perturbation table an attacker 3-tuple is mapped, it is still possible to identify that a certain attacker 3-tuple is the \emph{first} to map to a cell, as no collisions were observed in the sandwich construction for that tuple. The attacker can relate observed source ports to attacker 3-tuples because the tracking server maintains a mapping:
%
% \[
% 	(\mathrm{IP_{Src}}, \mathrm{IP_{Dst}}, \mathrm{Port_{Dst}}) \;\rightarrow\; \mathrm{Port_{Src}}
% \]
%
% obtained from analyzing the TCP SYN packets sent during the bursts.
%
% Phase 1 ends when the attacker has found $T$ attacker 3-tuples, each corresponding to a unique cell of the perturbation table. This ensures that every cell in the table is covered by at least one known attacker 3-tuple.
%
% Having a complete set of attacker 3-tuples for all cells of the perturbation table is critical for Phase 2. This is because one cannot directly determine collisions between loopback 3-tuples due to the limited access available on the attacked device. Instead, the attack in Phase 2 relies on the principle that two loopback 3-tuples collide if and only if they both map to the same attacker 3-tuple, as observed by changes in the source port values of TCP SYN packets during the sandwiching method used in Phase 2.

\section{Phase 2}
\label{sec:phase 2}

Because code running in the browser has limited access, one cannot directly observe collisions among loopback 3-tuples. Specifically, it is not possible to see the source port values that the Double-Hash Port Selection (DHPS) algorithm calculates for connections between loopback 3-tuples. Instead, collisions among loopback 3-tuples must be detected indirectly, using the attacker 3-tuples determined in Phase 1, which cover all cells of the perturbation table. These attacker 3-tuples make collisions among loopback 3-tuples visible, because an attacker can observe how the source ports generated by the DHPS algorithm change in a predictable way—through increments in the perturbation table cell entry—if a loopback 3-tuple and an attacker 3-tuple fall into the same cell.

Phase 2 proceeds as follows:

\begin{itemize}
	\item The attacker iterates over a list $L$ of loopback 3-tuples.
	\item In each iteration:
	\begin{itemize}
		\item A burst of TCP SYN packets is sent to all $T$ attacker 3-tuples identified in Phase 1.
		\item Several TCP SYN packets are sent to one specific loopback 3-tuple $L_i$.
		\item Another burst of TCP SYN packets is sent to all $T$ attacker 3-tuples.
		\item The tracking server checks which attacker 3-tuple’s observed source port has advanced by more than $1$. This indicates that $L_i$ and the attacker 3-tuple share the same perturbation table cell.
		\item If a collision is found, the pair $(L_i, B_w)$ is stored, where $B_w$ is the first loopback 3-tuple found for this cell.
	\end{itemize}
	\item This is repeated until a sufficient number of independent collisions have been collected to build a device ID with the desired uniqueness probability.
\end{itemize}

Phase 2 uses a \alert{sandwiching method} to detect collisions between loopback 3-tuples. The procedure is as follows:

\begin{itemize}
	\item A single loopback 3-tuple is sent multiple times in the middle of two bursts of connections to the attacker 3-tuples that cover all perturbation table cells.
	\item These attacker 3-tuples “surrounding” the loopback connections serve as probes. By observing changes in their source port values after the sandwich, one can deduce if the loopback 3-tuple shares a cell with any attacker 3-tuple.
\end{itemize}

The attacker can determine which attacker 3-tuple shares a cell with the loopback 3-tuple $L_i$ if the observed source port for that attacker 3-tuple has increased by more than $1$ after the sandwich. However, one does not know directly with which other loopback 3-tuples $L_i$ collides, if any. Instead, the collisions are inferred indirectly:

\begin{itemize}
	\item Only one loopback 3-tuple is sent in the sandwich at a time, but it is sent multiple times.
	\item This avoids ambiguity because, if multiple different loopback 3-tuples were sent in the sandwich, it would be impossible to know which one caused the observed increment in the source port of the attacker 3-tuples.
	\item By sending only the same loopback 3-tuple several times, the attacker knows precisely which 3-tuple was responsible for any detected collision.
	\item If two loopback 3-tuples eventually map to the same attacker 3-tuple (same perturbation table cell), they are considered colliding.
\end{itemize}

The papers describe that the same loopback 3-tuple is sent multiple times inside the sandwich, but they do not explicitly state the reason. However, based on the attack description, a plausible reason is:

\begin{itemize}
	\item Sending the same loopback 3-tuple multiple times ensures that any increment in the shared counter of the perturbation table cell is large enough to be reliably detected by the attacker. For example, in Figure 2 of, the source port advanced by 4, reflecting multiple SYN packets sent to the same loopback 3-tuple.
	\item Additionally, sending it several times increases confidence that the increment observed is indeed caused by that specific loopback 3-tuple and not random noise or unrelated connections.
\end{itemize}

Thus, while the papers do not explicitly state the purpose, sending the same loopback 3-tuple multiple times appears to serve both signal amplification and clarity of attribution.

By repeatedly applying this sandwiching technique, the attacker collects pairs of colliding loopback 3-tuples. These pairs ultimately form the device ID, unique to the secret key $K_2$ used by the DHPS algorithm. The process terminates once enough independent collisions are found to achieve a desired confidence level in device uniqueness.

\begin{center}
	% \begin{adjustbox}{scale=0.6}
	\begin{minipage}[t]{0.5\textwidth}
		\vspace{0cm}

		\input{./share/phase2.tex}
	\end{minipage}
	% \end{adjustbox}
\end{center}

\vspace{0.5cm}
\chapter{Countermeasures}
\label{sec:countermeasures}

The \alert{root cause} of the attack described in the paper is that the Double-Hash Port Selection algorithm (DHPS) generates TCP source ports deterministically, allowing attackers to detect hash collisions in shared perturbation table entries and derive stable device-specific patterns.

An \alert{ideal solution} would be to create a private perturbation table for each network namespace and interface, preventing attackers from observing stable collisions. However, this is impractical due to high memory consumption when many containers or interfaces exist.

In \alert{general}, \alert{countermeasures} to prevent this attack focus on making hash collisions less frequent or making it much more difficult for attackers to detect them. The paper proposes several modifications to DHPS, and these were incorporated into the Linux kernel through a security patch. The main countermeasures are:

\begin{itemize}
	\item \aalert{Increase table size $T$:}
	A larger perturbation table reduces hash collisions and increases attack cost.
	\textit{The concrete change made in the Linux kernel was to increase the table size to $T = 64K$.}

	\item \aalert{Periodic re-keying:}
	Changing DHPS’s secret key periodically invalidates previously discovered collisions, though it risks reusing ports for the same 3-tuple too soon.
	\textit{The concrete change made in the Linux kernel was to perform re-keying every 10 seconds.}

	\item \aalert{Introduce more noise:}
	Adding randomness to perturbation table increments makes collisions harder to detect.
	\textit{The concrete change made in the Linux kernel was to randomize increments uniformly between 1 and 8.}
\end{itemize}

These countermeasures were integrated into Linux versions 5.18 and 5.19, making the attack significantly harder or infeasible.

\vspace{0.5cm}
\chapter{Appendix}
\label{sec:appendix}
\pagenumbering{Alph}

\section{Terminology and Conventions}
\label{sec:terminology and conventions}

Throughout this report, the following terminology and conventions are used:
\begin{itemize}
	\item Clickable hyperlinks look like \hyperref[sec:terminology and conventions]{this}, and normal highlighted text looks like \alert{this}.
  \item All sorts of captions like titles of captions or headwords are written like this \aalert{Caption} and all sorts of just highlighted words that are neither of what has just been mentioned are written like \alert{this}.
	\ditem{unique}{Unique attacker 3-tuples} An attacker 3-tuples where each uniquely covers one cell of the perturbation table.
	\ditem{collision}{Collision of 3-tuples} Actually means collision of (attacker / loopback) 3-tuples in the same perturbation table cell but the last part is omitted for brevity.
	\ditem{candidate}{Candidate attacker 3-tuples} Possible candidates that could become unique attacker 3-tuples if they do not collide with any of the already found unique attacker 3-tuples.
	\ditem{increment}{Increment source port by x} When it is stated that an attacker 3-tuple had a source port incremented by x, it means the difference between the source ports generated by DHCP for the same attacker 3-tuple (as read from the TCP SYN packet) when establishing a TCP connection at the beginning and end of the sandwich method.
	\ditem{sanwdich}{Sawndwich method} 
	\ditem{sanwdiching}{Sawndwiching} Technique used in phase 1 and phase 2 
	\ditem{wrapper}{Wrapper} 
	\ditem{filling}{Filling} 
\end{itemize}

\section{Related Work}
\label{sec:related work}

\vspace{0.5cm}
\chapter{Bibliography}
\label{sec:bibliography}

\printbibliography[heading=none]

\end{document}
