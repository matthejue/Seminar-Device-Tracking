\documentclass[twocolumn]{report}

\input{./content/packages}
\input{./content/declarations}
\input{./content/desgin}

\newtoggle{longversion}
\toggletrue{longversion}

% \togglefalse{longversion} % creates short version if not commented out

\begin{document}

\fontsize{7pt}{8pt}\selectfont
\newgeometry{margin=1cm, bottom=2cm, top=1cm}

\input{./content/titlepage}

\clearpage
\pagenumbering{gobble}
\tableofcontents
\clearpage
\clearpage

\pagenumbering{arabic}
\pagestyle{plain}
\clearpage

\section{Introduction}
\label{sec:introduction}

In 2018, the \alert{Meltdown} and \alert{Spectre} attacks caused widespread concern by revealing how modern CPUs’ performance features could be exploited to read sensitive data from memory that should have remained inaccessible to user processes.

These attacks demonstrated a broader principle: that subtle side effects in complex systems can leak internal information not intended to be observable.

In a similar spirit, researchers Moshe Kol, Amit Klein, and Yossi Gilad from the Hebrew University of Jerusalem discovered an attack that exploits Linux’s \alert{TCP source port selection algorithm} to track devices.

Like Meltdown, this attack targets \alert{security} and compromises confidentiality, but not by directly revealing secret data, but by exploiting side effects of \alert{hash collisions} that manifest as observable patterns in how \alert{TCP source ports} are incremented across connections. These patterns allow an attacker to infer a fingerprint uniquely tied to a \alert{secret device-specific key}.

\subsection{About this report}
\label{sec:goal_of_this_report}

The goal of this report is to provide insight into a specific browser-based device tracking technique described in the paper\cite{kol2022devicetrackinglinuxsnew}.

This report mainly aims to \alert{summarize} the original paper in a \alert{shorter}, \alert{easier-to-understand}, and \alert{more intuitively structured way}, since the original paper requires additional technical knowledge to be fully understood, has the key information most readers are interested in scattered across various sections, and does not clearly lay out some of the underlying connections and reasons for certain aspects of the attack.

Readers are encouraged to first consult Section~\ref{sec:terminology and conventions} for an \alert{overview of terminology and conventions} used throughout this report.\iftoggle{longversion}{ This document is the \alert{extended version} of a report created for a Seminar, which required the final submission to be limited to \alert{four pages}. This longer version is available at \url{https://github.com/matthejue/Seminar-Device-Tracking/releases/latest/download/report.pdf}.}{ Due to the Seminar's requirement that the report may not exceed \alert{four pages}, a more comprehensive version of this report is available at \url{https://github.com/matthejue/Seminar-Device-Tracking/releases/latest/download/report.pdf}.}

\alert{It should be emphasized that this is purely a report explaining and summarizing the result of other researchers' work, without presenting original research or claiming the findings as the author's own.}

\newcommand{\devicetrackig}{
	\subsection{Browser-based Device tracking}
	\label{sec:Online browser-based device tracking}

	\alert{Browser-based device tracking} is a widespread practice in which websites or advertisers use information collected through the user’s web browser to identify devices across sessions and different websites.

	Traditionally, cross-site tracking relied on \alert{third-party cookies}, but growing privacy concerns and technical defenses like privacy modes and cookie blocking have pushed trackers to seek new methods that work across browsers and networks.

	A major \alert{privacy risk} of device tracking is linking a user’s identities across different contexts like networks, browsers, or privacy modes without their awareness or consent.

	Device tracking techniques, particularly browser-based tracking, face challenges in reliably identifying devices under changing conditions such as switching browsers, networks, or privacy modes. One important problem is the \alert{golden image challenge}, where many identical devices with the same hardware and software configuration need to be distinguished from each other.

	Device tracking techniques can be broadly categorized into the following two groups:

	\begin{itemize}
		\item \aalert{Tagging techniques:} These techniques insert an ID directly into the device, usually at the browser level. Examples include caching resources in the browser or storing data in mechanisms like cookies. However, tagging techniques are often ineffective when users switch to privacy modes or clear stored data.
		\item \aalert{Fingerprinting techniques:} These techniques measure characteristics of the system or browser to distinguish devices. Examples include differences in fonts, hardware details, or system language. However, fingerprinting techniques often struggle to solve the golden image challenge, as identical devices may produce identical fingerprints.
	\end{itemize}

	The attack described in the paper is a \alert{fingerprinting technique}, as it derives a device-specific identifier from the behavior of the operating system’s TCP source port selection rather than storing data in the browser. Unlike typical fingerprinting methods, it can successfully solve the \alert{golden image challenge}, because the identifier it produces depends on a per-device secret key generated at system boot. This allows it to distinguish between devices even when they share identical hardware and software configurations, and it remains effective across different browsers, privacy modes, networks, persisting until the device restarts.
}
\iftoggle{longversion}{
	\devicetrackig
}{}

\subsection{Source Port Selection}
\label{sec:source port selection}


\iftoggle{longversion}{
  Source port selection is a mechanism used by the TCP/IP stack of operating systems to choose a TCP source port number for outbound TCP connections. It is required because a TCP connection between two endpoints is uniquely identified by a \alert{4-tuple}, consisting of: 
  \begin{itemize}
    \item the \alert{source IP} address, 
    \item the \alert{source port}, 
    \item the \alert{destination IP} address, and 
    \item the \alert{destination port}.
  \end{itemize}

	\alert{Ports} exist so that multiple simultaneous network connections can operate on the same device, even to the same destination IP address and destination port. For example, a single machine might want to establish several independent TCP connections to the same remote server, and different source ports allow the operating system to distinguish these connections.
}{
Source port selection is a mechanism used by the TCP/IP stack of operating systems to choose a TCP source port number for outbound TCP connections. It is required because a TCP connection between two endpoints is uniquely identified by a \alert{4-tuple}, consisting of the \alert{source IP} address, the \alert{source port}, the \alert{destination IP} address, and the \alert{destination port}.
}

A \alert{straightforward way} to select source ports would be simply to choose the next available free port in sequence. But this approach is problematic because it fails to achieve two important goals that are also described in the paper:

\begin{itemize}
	\item \aalert{Security:} Predictable source port numbers make it easier for attackers to perform off-path attacks, such as blind reset or data injection attacks, as for these attacks they have to guess key connection details like the TCP 4-tuple (source and destination IP addresses and ports) and sequence numbers.
	\item \aalert{Functionality:} Quickly reusing the same source port can cause failures because earlier connections might still be active or in the \texttt{TIME\_WAIT} state on the server side. Reusing the same 4-tuple too soon can lead to errors or dropped connections.
\end{itemize}

\subsubsection{Double-Hash Port Selection Algorithm (DHPS)}
\label{sec:double-hash port selection algorithm}

To address these goals, several algorithms for TCP source port selection have been defined, including the \alert{Double-Hash Port Selection (DHPS)} algorithm, described in RFC 6056\cite{larsenRecommendationsTransportProtocolPort2011}.

\iftoggle{longversion}{
	TCP source ports are divided into different ranges, each serving distinct purposes:
	\begin{itemize}
		\item \aalert{Well-known ports} (typically ports 0–1023) are reserved for specific services such as HTTP (port 80) or HTTPS (port 443).
		\item \aalert{Registered ports} (typically ports 1024–49151) are assigned to user applications or services but are not ephemeral.
		\item \aalert{Ephemeral ports} (typically in the higher range, e.g. 32768–60999 in Linux) are \alert{dynamically} allocated by the operating system for \alert{short-lived} client-side connections.
	\end{itemize}

	For the DHPS algorithm, the \alert{ephemeral port} range is particularly relevant because it represents the pool from which source ports are selected for outbound connections.

	DHPS selects a TCP \alert{source port} for outbound TCP connections from the ephemeral range based on a given \alert{3-tuple}, consisting of:
	\begin{itemize}
		\item the \alert{source IP} address,
		\item the \alert{destination IP} address, and
		\item the \alert{destination port}
	\end{itemize}
	and by this completes the connection’s \alert{4-tuple}. To perform this selection, it uses two \alert{cryptographic keyed-hash functions} with separate, independent keys:
	\begin{itemize}
		\item \( F_{K_1} \), which maps its inputs to a large range of integers, using the key \( K_1 \),
		\item \( G_{K_2} \), which maps its inputs to a range corresponding to the size of the \alert{perturbation table} \texttt{table}, using the key \( K_2 \).
	\end{itemize}

	The \alert{perturbation table} in the DHPS algorithm is a fixed-size array of integer counters used to add randomness and unpredictability to TCP source port selection. In Linux, it consists of $T = 256$ entries, all initially set to zero. Each time a connection uses a specific table entry, the counter at that index is incremented, so the table evolves over time as more connections are made. This mechanism ensures that successive connections to the same destination do not repeatedly use the same source port, thus improving security and preventing collisions of TCP 4-tuples.
}{
	TCP source ports are divided into different ranges, each serving distinct purposes. For the DHPS algorithm, the ephemeral port range is particularly relevant because it represents the pool from which source ports are selected for outbound connections. \alert{Ephemeral ports} (typically in the higher range, e.g. 32768–60999 in Linux) are dynamically allocated by the operating system for short-lived client-side connections.

	DHPS selects a TCP \alert{source port} for outbound TCP connections from the ephemeral range based on a given \alert{3-tuple}, consisting of the \alert{source IP} address, the \alert{destination IP} address, and the \alert{destination port} and by this completes the connection’s \alert{4-tuple}. To perform this selection, it uses two \alert{cryptographic keyed-hash functions} with separate, independent keys:
	\begin{itemize}
		\item \( F_{K_1} \), which maps its inputs to a large range of integers, using the key \( K_1 \),
		\item \( G_{K_2} \), which maps its inputs to a range corresponding to the size of the \alert{perturbation table} \texttt{table}, using the key \( K_2 \).
	\end{itemize}
	The \alert{perturbation table} in the DHPS algorithm is a fixed-size array of integer counters used to add randomness and unpredictability to TCP source port selection. In Linux, it consists of $T = 256$ entries, all initially set to zero. Each time a connection uses a specific table entry, the counter at that index is incremented, so the table evolves over time as more connections are made. This mechanism ensures that successive connections to the same destination do not repeatedly use the same source port, thus improving security and preventing collisions of TCP 4-tuples.
}

% The algorithm operates as described in Algorithm~\hyperref[1]{alg:dhps_port_selection}:
% \begin{itemize}
% 	\item It calculates an \texttt{offset} by applying the keyed hash function \( F_{K_1} \) to the 3-tuple.
% 	\item It calculates an \texttt{index} into the perturbation table by applying the keyed hash function \( G_{K_2} \) to the 3-tuple.
% 	\item It computes a candidate port number using:
%
% 	\begin{minipage}{\columnwidth}
% 		\begin{equation*}
% 			\begin{split}
% 				\texttt{candidate\_port}
% 				 & = \texttt{min\_ephemeral}      \\
% 				 & \quad + \bigl((\texttt{offset}
% 				+ \text{table[{\texttt{index}}]})
% 				\bmod \texttt{num\_ephemeral}\bigr)
% 			\end{split}
% 		\end{equation*}
% 	\end{minipage}
%
% 	where \texttt{min\_ephemeral} and \texttt{num\_ephemeral} define the allowed range of ephemeral ports.
% 	\item It checks whether the candidate port is suitable. If the port is already in use or otherwise unsuitable, the algorithm increments the entry in the perturbation \texttt{table} at the calculated \texttt{index}. As a consequence, the next time this same table entry is used, the computed port number is also \alert{incremented by 1}, unless the port is already at the end of the ephemeral range, in which case it wraps around to the beginning of the range.
% 	\item This process \alert{repeats until} a free port is found or no ports remain. This loop is controlled by the variable \texttt{count}, which is decremented on each attempt and terminates the algorithm when it reaches zero.
% \end{itemize}
The algorithm operates as described in Algorithm~\hyperref[alg:dhps_port_selection]{1}. It calculates an \texttt{offset} by applying the keyed hash function \( F_{K_1} \) to the 3-tuple. It also calculates an \texttt{index} into the perturbation table by applying the keyed hash function \( G_{K_2} \) to the 3-tuple.

Next, it computes a \alert{candidate port number} using the following calculations:

\vspace{-0.4cm}
\begin{minipage}{\columnwidth}
	\begin{equation*}
		\begin{split}
			\texttt{candidate\_port}
			 & = \texttt{min\_ephemeral}      \\
			 & \quad + \bigl((\texttt{offset}
			+ \text{table[{\texttt{index}}]})
			\bmod \texttt{num\_ephemeral}\bigr)
		\end{split}
	\end{equation*}
\end{minipage}

where \texttt{min\_ephemeral} and \texttt{num\_ephemeral} define the allowed range of ephemeral ports.

It checks whether the candidate port is suitable. If the port is already in use or otherwise unsuitable, the algorithm increments the entry in the perturbation \texttt{table} at the calculated \texttt{index}. As a consequence, the next time this same table entry is used, the computed port number is also \alert{incremented by 1}, unless the port is already at the end of the ephemeral range, in which case it wraps around to the beginning of the range.

This process \alert{repeats until} a free port is found or no ports remain. This loop is controlled by the variable \texttt{count}, which is decremented on each attempt and terminates the algorithm with an error when it reaches zero.

% \vspace{0.2cm}
\input{./share/dhps_algorithm.tex}

\section{Attack}
\label{sec:attack}

In the attack, two main parties are involved:

\begin{itemize}
	\item \aalert{Tracking server}: This server is controlled by the \alert{attacker} and receives the TCP connection attempts initiated from the client device. It analyzes the observed TCP source ports in order to calculate a device ID and track the client device.%across networks and browsing sessions.

	\item \aalert{Client device}: This is the \alert{victim’s} (Linux-based) device, which runs a browser that renders a web page containing a \alert{tracking snippet}, a small piece of HTML and JavaScript code that operates within the browser’s JavaScript sandbox. When the browser renders the tracking snippet and executes the JavaScript code, the code causes the browser to initiate a series of TCP connection attempts to the \alert{tracking server}, interleaved with TCP connection attempts to a \alert{loopback address}.
\end{itemize}

Two \alert{types of 3-tuples} are distinguished in the attack:

\begin{itemize}
	\item \aalert{Attacker 3-tuples:} These have the form
	\begin{equation*}
		(\mathrm{IP_{Src}}_{\text{Internet-facing}}, \mathrm{IP_{Dst}}_{\text{tracking server}}, \mathrm{Port_{Dst}})
	\end{equation*}
	where the source IP address is the Internet-facing address of the device, and the destination IP address belongs to the tracking server.

	\item \aalert{Loopback 3-tuples:} These have the form
	\begin{equation*}
		(\mathrm{IP_{Src}} = 127.0.0.1, \mathrm{IP_{Dst}} = 127.1.2.3, \mathrm{Port_{Dst}})
	\end{equation*}
	where both source and destination IP addresses are loopback addresses on the device. \alert{Loopback addresses} refer to the local machine itself and are used for internal communication within the device. Only the \alert{destination port} varies among loopback 3-tuples.
\end{itemize}

We will see later why distinguishing these two types of 3-tuples is important.

The fingerprint mentioned in the introduction Section~\ref{sec:introduction} of this report is the \alert{device ID} that is built by indirectly observing the structure formed by \alert{collisions of loopback 3-tuples} inside the perturbation table. Such a collision occurs if two loopback 3-tuples differing only in their destination port numbers $x$ and $y$ satisfy
\begin{equation*}
	\begin{split}
		G_{K_{2}}\bigl(
		\mathrm{IP}_{\mathrm{Src}} = 127.0.0.1,\;
		\mathrm{IP}_{\mathrm{Dst}} = 127.1.2.3,\;
		\mathrm{Port}_{\mathrm{Dst}} = x
		\bigr)
		= \\
		G_{K_{2}}\bigl(
		\mathrm{IP}_{\mathrm{Src}} = 127.0.0.1,\;
		\mathrm{IP}_{\mathrm{Dst}} = 127.1.2.3,\;
		\mathrm{Port}_{\mathrm{Dst}} = y
		\bigr)
	\end{split}
\end{equation*}
\vspace{-0.5cm}

meaning that both tuples hash to the same cell in the perturbation table under the function $\mathrm{G_{K_2}}$. These collisions depend solely on the kernel’s \alert{secret key} $K_2$, which is the same secret key mentioned in the introduction Section~\ref{sec:introduction}. This key is randomly generated each time the \alert{system starts} and remains constant as long as the device stays powered on. Consequently, the device ID is directly tied to $K_2$ and persists across browser sessions, private browsing modes, and network changes.

The device ID consists of the set of all such colliding pairs:

\vspace{-0.2cm}
\begin{minipage}{\columnwidth}
	\[
		\left\{ \bigl(x_i, y_i\bigr) \;\middle|\; i = 1, \ldots, n \right\}
	\]
\end{minipage}

where each pair $(x_i, y_i)$ represents \alert{two destination ports} whose corresponding loopback 3-tuples collide into the same perturbation table cell. These pairs are chosen to be \alert{\hypertarget{independant}{independant}}, meaning that each one captures a distinct piece of evidence about how the secret key $K_2$ maps destination ports into perturbation table cells. Specifically, if $k$ loopback 3-tuples fall into the same cell, there are $\binom{k}{2}$ possible pairs, but only $k-1$ of these are independent. The independent pairs are chosen as:

\vspace{-0.2cm}
\begin{minipage}{\columnwidth}
	\[
		(x_1, x_2),\; \ldots,\; (x_1, x_k),
	\]
\end{minipage}

where $x_1, x_2, \ldots, x_k$ are the destination ports of the colliding loopback 3-tuples. This means that for each group of colliding loopback tuples, the first discovered tuple's destination port $x_1$ is paired with every other tuple's destination port in that group, as further detailed in phase 2 (Section~\ref{sec:phase 2}) of the attack. Pairs beyond these $k-1$ would be \alert{dependent} because their collisions are fully implied by the existing pairs\footnote{\tiny For example, knowing that both $(x_1, x_2)$ and $(x_1, x_3)$ collide makes it redundant to additionally record $(x_2, x_3)$.}. This is crucial for the probability analysis in the paper, where the probability that a random device produces the same set of collisions depends solely on the number of independent pairs observed.

A device ID based on collisions of \alert{attacker 3-tuples} would not remain consistent across networks, because the source IP address visible to external servers typically changes whenever the device connects to a different network. In contrast, \alert{loopback 3-tuples} with loopback addresses such as $127.x.x.x$ are internal to the device and remain stable across networks, making them suitable for deriving a consistent device ID.

The nature of the attack resembles the principle of a \alert{particle accelerator}, where tiny particles cannot be observed directly and must instead be studied through the side effects they produce. Similarly, because there is no direct access to kernel internals such as the perturbation table, collisions of loopback 3-tuples (used to build the device ID) within the perturbation table \alert{cannot be observed directly}. Instead, such collisions must be inferred indirectly by analyzing the side effects that appear as observable patterns in how TCP source ports are incremented across connections by DHPS.

These observable patterns arise because, in the DHPS algorithm, each cell in the perturbation table maintains a counter that is incremented by 1 in a predictable manner every time it is used to generate a candidate source port, as shown in Algorithm~\hyperref[alg:dhps_port_selection]{1}, line~9:

\begin{minipage}{\columnwidth}
	\[
		\texttt{table[index]} \leftarrow \texttt{table[index]} + 1.
	\]
\end{minipage}

A technique that exploits these predictable TCP source port increments to detect collisions of 3-tuples (attacker or loopback) is known as \alert{sandwiching}. The general principle of sandwiching is that there is a \alert{wrapper} and a \alert{filling}, as visualized in the following schema:

\begin{center}
	\begin{adjustbox}{max width=0.95\columnwidth}
		\begin{tblr}{
			colspec={|c|Q[l]|},
			row{1}={bg=PrimaryColor,fg=white,font=\bfseries},
			row{2}={bg=PrimaryColorDimmed},
			row{3}={bg=SecondaryColorDimmed},
			row{4}={bg=PrimaryColorDimmed},
			hlines
			}
			\textbf{Step} & \textbf{Calculation} \\

			Wrapper       &
			\(
			\begin{aligned}
				 & i = G_{K_2}(\text{IP}_{\text{Src},X}, \text{IP}_{\text{Dst},X}, \text{Port}_{\text{Dst},X})                                   \\
				 & \text{offset}_X = F_{K_1}(\text{IP}_{\text{Src},X}, \text{IP}_{\text{Dst},X}, \text{Port}_{\text{Dst},X})                     \\
				 & \text{Port}_{\text{Src},1} = \text{min\_ephemeral} + \bigl(\text{offset}_X + \text{table}[i]\bigr)\bmod \text{num\_ephemeral} \\
				 & \text{table}[i] = \text{table}[i] + 1
			\end{aligned}
			\)                                   \\

			Filling       &
			\(
			\begin{aligned}
				 & j = G_{K_2}(\text{IP}_{\text{Src},Y}, \text{IP}_{\text{Dst},Y}, \text{Port}_{\text{Dst},Y})                                   \\
				 & \text{offset}_Y = F_{K_1}(\text{IP}_{\text{Src},Y}, \text{IP}_{\text{Dst},Y}, \text{Port}_{\text{Dst},Y})                     \\
				 & \text{Port}_{\text{Src},2} = \text{min\_ephemeral} + \bigl(\text{offset}_Y + \text{table}[j]\bigr)\bmod \text{num\_ephemeral} \\
				 & \text{table}[j] = \text{table}[j] + 1
			\end{aligned}
			\)                                   \\

			Wrapper       &
			\(
			\begin{aligned}
				 & i = G_{K_2}(\text{IP}_{\text{Src},X}, \text{IP}_{\text{Dst},X}, \text{Port}_{\text{Dst},X})                                             \\
				 & \text{offset}_X = F_{K_1}(\text{IP}_{\text{Src},X}, \text{IP}_{\text{Dst},X}, \text{Port}_{\text{Dst},X})                               \\
				 & \text{Port}_{\text{Src},3} = \text{min\_ephemeral} + \bigl(\text{offset}_X + \text{table}[i] + \delta \bigr)\bmod \text{num\_ephemeral} \\
				 & \text{table}[i] = \text{table}[i] + 1
			\end{aligned}
			\)                                   \\
		\end{tblr}
	\end{adjustbox}
\end{center}
where
\vspace{-1cm}
\begin{center}
	\begin{adjustbox}{max width=\columnwidth}
		\begin{minipage}[t]{0.4\textwidth}
			\[
				\delta =
				\begin{cases}
					1, & \text{if } i \neq j,\ \text{meaning perturbation table cell } i \text{ was not used,}\footnote{\tiny Used or not used in the filling step.} \\
					2, & \text{if } i = j,\ \text{meaning perturbation table cell } i \text{ was used}
				\end{cases}
			\]
		\end{minipage}
	\end{adjustbox}
\end{center}
\begin{itemize}
	\item In the \aalert{first wrapper step}, DHPS calculates \(\text{Port}_{\text{Src},1}\) for the 3-tuple \( X \), based on the current value in cell \( i \) of the perturbation table. Afterwards, \(\text{table}[i]\) is incremented by 1.
	\item In the \aalert{filling step}, a different 3-tuple \( Y \) is used, producing \(\text{Port}_{\text{Src},2}\) based on cell \( j \). If \( j = i \), then \(\text{table}[i]\) is incremented again.
	\item In the \aalert{second wrapper step}, DHPS calculates \(\text{Port}_{\text{Src},3}\) for the same 3-tuple \( X \). If \( j \neq i \), then \(\text{Port}_{\text{Src},3} = \text{Port}_{\text{Src},1} + 1\). Otherwise, if \( j = i \), then \(\text{Port}_{\text{Src},3} = \text{Port}_{\text{Src},1} + 2\). \textit{A collision between 3-tuples \( X \) and \( Y \) is detected precisely when \(\text{Port}_{\text{Src},3}\) is greater than \(\text{Port}_{\text{Src},1} + 1\), indicating that both 3-tuples map to the same perturbation table cell \( i \)}.
\end{itemize}

% \begin{sidenote}
The second increment of \(\text{table}[i]\) in the second wrapper step does \alert{not provide any further relevant information} about the 3-tuple \( X \) or about any tuples \( Y \) colliding with it in the filling step, because \(\text{Port}_{\text{Src},3}\) has already been calculated by then. Instead, this increment is only relevant for any other 3-tuple in the last wrapper step that might later map to the same perturbation table cell \( i \).
% \end{sidenote}

The explanation above illustrates only the \alert{core idea of sandwiching} in a simplified example. In practice, several additional factors must be taken into account:

\begin{itemize}
	\item \aalert{Background noise:} In real-world scenarios, there is also \alert{noise} caused by other TCP connection attempts from unrelated processes on the client device. These connections occur alongside the TCP connection attempts of the tracking snippet and can also increment the perturbation table cell \( i \).
	\item \aalert{Multiple connection attempts:} Typically, multiple \alert{bursts of TCP connection attempts} (TCP SYN packets) are established both in the wrapper and the filling steps, each using several different 3-tuples. After applying the sandwiching technique, one knows which 3-tuples produced which source port values at specific points in time, because the \alert{TCP SYN packet headers} include the full attacker 4-tuple. This information can be easily transformed into a mapping from each attacker 3-tuple to its corresponding source port:

	\vspace{0.2cm}
	\begin{minipage}{\columnwidth}
		\[
			(\mathrm{IP_{Src}}, \mathrm{IP_{Dst}}, \mathrm{Port_{Dst}}) \;\mapsto\; \mathrm{Port_{Src}}
		\]
	\end{minipage}
	\vspace{0cm}
  allowing to track source port increments.

	\ditem{limitations}{Limitations for loopback 3-tuples} Unfortunately, the attack does not work with arbitrary 3-tuples. The tracking snippet cannot directly access the TCP source ports that DHPS generates for 3-tuples, because these ports are read from TCP SYN packet headers, and JavaScript in the \alert{browser’s sandbox} operates at a higher level than the TCP layer. Consequently, there is no way to access TCP SYN packets for \alert{loopback 3-tuples} on the client device, since their destination IP address is the machine itself and these connections remain internal. In contrast, \alert{attacker 3-tuples} target the tracking server’s IP address, allowing the \alert{tracking server} to observe their TCP SYN packets and read the source ports. Therefore, attacker 3-tuples are used as the wrapper in the sandwiching technique to make collisions with loopback 3-tuples observable.
\end{itemize}

The consequence of what is explained in \hyperlink{limitations}{Limitations for loopback 3-tuples} is that, in order to detect which loopback 3-tuples collide with each other, one must observe \alert{collisions between loopback 3-tuples and attacker 3-tuples} using the sandwiching method. By transitivity, if two loopback 3-tuples each collide with the same attacker 3-tuple, then they also collide with each other:
\vspace{-0.6cm}
\begin{center}
	\begin{adjustbox}{max width=\columnwidth}
		\begin{minipage}{0.85\textwidth}
			\[
				\begin{aligned}
					 &
					\begin{aligned}
						 & \begin{array}{c}
							   G_{K_2}\bigl(\text{IP}_{\text{Src}} = 127.0.0.1,\ \text{IP}_{\text{Dst}} = 127.1.2.3,\ \text{Port}_{\text{Dest}} = x_1 \bigr) \\[0.3em]
							   =                                                                                                                             \\[0.3em]
							   G_{K_2}\bigl(\text{IP}_{\text{Src}} = D,\ \text{IP}_{\text{Dst}} = A,\ \text{Port}_{\text{Dest}} = y \bigr)
						   \end{array}
						\\[1em]
						 & \begin{array}{c}
							   G_{K_2}\bigl(\text{IP}_{\text{Src}} = 127.0.0.1,\ \text{IP}_{\text{Dst}} = 127.1.2.3,\ \text{Port}_{\text{Dest}} = x_2 \bigr) \\[0.3em]
							   =                                                                                                                             \\[0.3em]
							   G_{K_2}\bigl(\text{IP}_{\text{Src}} = D,\ \text{IP}_{\text{Dst}} = A,\ \text{Port}_{\text{Dest}} = y \bigr)
						   \end{array}
					\end{aligned}
					\quad \Longrightarrow \quad
					\begin{aligned}
						 & \begin{array}{c}
							   G_{K_2}\bigl(\text{IP}_{\text{Src}} = 127.0.0.1,\ \text{IP}_{\text{Dst}} = 127.1.2.3,\ \text{Port}_{\text{Dest}} = x_1 \bigr) \\[0.3em]
							   =                                                                                                                             \\[0.3em]
							   G_{K_2}\bigl(\text{IP}_{\text{Src}} = 127.0.0.1,\ \text{IP}_{\text{Dst}} = 127.1.2.3,\ \text{Port}_{\text{Dest}} = x_2 \bigr)
						   \end{array}
					\end{aligned}
				\end{aligned}
			\]
		\end{minipage}
	\end{adjustbox}
\end{center}

In phase 2 (Section~\ref{sec:phase 2}) of the attack, the sandwiching method is used to detect collisions between loopback 3-tuples indirectly, by checking whether they collide with the same attacker 3-tuples. To enable this, it is necessary to have a set of attacker 3-tuples that collectively cover all cells of the perturbation table, ensuring that every cell can be tested for potential collisions. These so-called \alert{unique attacker 3-tuples} have to be first determined in phase 1 (Section~\ref{sec:phase 1}), also via the sandwiching method.

\subsection{Phase 1}
\label{sec:phase 1}

The phase 1 algorithm is depicted in algorithm~\hyperref[alg:phase1]{2}. In each iteration $i$, the attacker generates a new set $S$ of \alert{candidate attacker 3-tuples}. These candidate attacker 3-tuples are distinct from those used in previous iterations.

The algorithm utilizes the \alert{sandwiching technique}, introduced earlier in Section~\ref{sec:attack}. In every iteration, the browser performs two bursts of TCP connection attempts in the wrapper and one burst in the filling, as follows:
\begin{itemize}
	\item The \alert{filling} consists of all \alert{unique attacker 3-tuples} discovered so far, all of which are included in the second burst of TCP connection attempts.
	\begin{itemize}
    \item In the first iteration, since no unique attacker 3-tuples have been found yet, the set $S'$ is \alert{empty}. However, just because of that, it does not mean that all candidate attacker 3-tuples in $S_i$ necessarily become unique attacker 3-tuples. Candidate attacker 3-tuples \alert{can} also \alert{collide with each other} if they map to the same cell in the perturbation table via $G_{K_2}$ and thus cannot be unique attacker 3-tuples.
		\item In later iterations, this burst consists of TCP connection attempts to the set $S'$, which contains \alert{all unique attacker 3-tuples discovered so far}.
	\end{itemize}
	\item The two \alert{wrapper} steps comprise new candidate attacker 3-tuples that might be unique and are in each wrapper step probed in a burst of TCP connection attempts. In each wrapper step connections are attempted to all 3-tuples in $S$.
\end{itemize}

After performing the sandwiching technique, a \alert{candidate attacker 3-tuple} \( x \) in $S$ is determined to be \alert{unique} if it fulfills the following \alert{condition}:

\vspace{-0.2cm}
\begin{minipage}{\columnwidth}
	\begin{equation*}
		P'(x) - P(x) = 1
		\quad \text{when sandwiching } S' \text{ as filling.}
	\end{equation*}
\end{minipage}

where \(P(x)\) and \(P'(x)\) are partial functions that map \alert{candidate attacker 3-tuples \( x \) to} the observed \alert{TCP source port} numbers assigned during the first and third bursts of TCP connection attempts probing the wrapper, respectively. These functions are defined only for the set of attacker 3-tuples probed in the corresponding bursts.

This \alert{condition implies} that those candidate attacker 3-tuples in the wrapper, whose source port has incremented by exactly $1$, are the first to map to a perturbation table cell that none of the unique attacker 3-tuples discovered so far in the filling has already been mapped to. Consequently, they do not collide with any of the previously discovered unique attacker 3-tuples and are thereby confirmed as new \alert{unique attacker 3-tuples}, which form the \alert{output} of phase~1 of the attack algorithm.

\alert{Noise} occurring between the first and second TCP connection attempts for one candidate attacker 3-tuple can increase the value of \texttt{table[i]}, where $i$ is the index of the perturbation table cell associated with that candidate attacker 3-tuple. This \alert{can hide} hide this candidate attacker 3-tuple from being discovered to be unique by making it's observed increment larger than $1$. However, this isn’t a problem, because noise can hide a unique mapping, but it \alert{can’t fabricate} one. The only problem is that phase 1 may require more iterations to find unique attacker 3-tuples for all perturbation table cells, but it does not compromise the correctness of the mapping once established.

The algorithm continues iterating until a unique attacker 3-tuple has been found for every cell of the perturbation table. Formally, it \alert{terminates} as soon as the number of unique attacker 3-tuples found, i.e.\ $\lvert S'_i \rvert$, equals $T$, where $T$ is the number of cells in the perturbation table.

\vspace{0.2cm}
\input{./share/phase1.tex}

\subsection{Phase 2}
\label{sec:phase 2}

The phase 2 algorithm is depicted in Algorithm~\hyperref[alg:phase2]{3}. It begins by initializing an empty set $C$ to store \alert{independent pairs of loopback 3-tuples} that collide in the same perturbation table cell via $G_{K_2}$, a counter $n \leftarrow 0$ for the \alert{number of independent pairs found}, and an \alert{iteration counter} $i \leftarrow 0$.

In each iteration, the iteration counter is incremented, \(i \leftarrow i+1\). Let \(w\) denote the unique attacker 3-tuple identified as colliding with the current loopback 3-tuple \(L_i\) (there's always an unique 3-tuple \(w\) with which the loopback 3-tuple $L_i$ collides, because every perturbation table cell is covered by one unique attacker 3-tuple). A mapping data structure \(B\), implemented as a \alert{dictionary} with unique attacker 3-tuples as keys, is used to record the first loopback 3-tuple observed for each unique attacker 3-tuple \(w\). \alert{If a collision is found} and there is already a loopback 3-tuple \(B[w]\) previously mapped to cell \(w\), the pair \((L_i, B[w])\) is added to the set \(C\) as an independent pair, and the counter is incremented, \(n \leftarrow n+1\). \alert{Otherwise}, \(B[w]\) is set to \(L_i\) to remember the first loopback 3-tuple associated with the unique attacker 3-tuple \(w\).

This algorithm utilizes the \alert{sandwiching technique} introduced earlier in Section~\ref{sec:attack}. In every iteration, this technique operates as follows:
\begin{itemize}
	\item The \aalert{filling} consists of a burst of several TCP connection attempts to the current loopback 3-tuple $L_i$. Only one loopback 3-tuple is tested at a time because testing multiple loopback 3-tuples simultaneously, without additional design, would prevent determining which loopback 3-tuple caused an increment in which unique attacker 3-tuple.
	\item The two \aalert{wrapper} steps each consist of a burst of TCP connection attempts to all unique attacker 3-tuples from phase 1 (Section~\ref{sec:phase 1}), and recording their assigned source ports in $P(x)$ and $P'(x)$.
\end{itemize}

After performing the sandwiching technique, an \alert{unique attacker 2-tuple \(w\)} in $S'$ (returned by phase 1 algorithm~\hyperref[alg:phase1]{2}) is said to collide with a \alert{loopback 3-tuple \(L_i\)} if the following \alert{condition} holds:

\begin{minipage}{\columnwidth}
	\begin{equation*}
		P'(w) - P(w) > \varepsilon
		\quad \text{when sandwiching } L_i \text{ as filling.}
	\end{equation*}
\end{minipage}

Here, \(P(w)\) and \(P'(w)\) denote the observed \alert{source ports assigned to} the \alert{unique attacker 2-tuple \(w\)} during the two wrapper steps, respectively, when the loopback 3-tuple \(L_i\) is inserted into the filling. The collision condition described above is formulated in the phase~2 algorithm~\hyperref[alg:phase2]{3} using the symbol \(\iota x\), which is the \alert{Definite Description Operator} and denotes \enquote{the unique \(x\)} satisfying a certain condition.

% The condition above means that the unique attacker 3-tuple \(w\) shares the same perturbation table cell as the loopback 3-tuple \(L_i\) via $G_{K_2}$. 
Since \alert{only one} loopback 3-tuple \(L_i\) repeatedly establishes \(\varepsilon\)-many TCP connections during the filling step, only one unique attacker 3-tuple \(w\) exhibits a \alert{significant increment} greater than \(\varepsilon\), while all other unique attacker 3-tuples do not. Because each unique attacker 3-tuple \(w\) covers a distinct perturbation table cell (even if the exact cell is unknown), it becomes possible to identify which loopback 3-tuples \(L_i\) collide with the same perturbation table cells represented by unique attacker 3-tuples (by knowing the unique attacker 3-tuple \(w\) for which a loopback 3-tuple \(L_i\) causes a significant increment).

Thus, it is possible to determine a structure of colliding loopback 3-tuples and use it as a device ID by collecting independent pairs of colliding loopback 3-tuples as the \alert{output} of the algorithm. In practice, the device ID is represented as \alert{pairs of destination ports}, corresponding to those pairs of independent loopback 3-tuples. Each $L_i$ in the algorithm is a loopback 3-tuple, but since the source and destination IP addresses in the 3-tuple are always the same, only the destination port is practically stored.

A significant increment greater than \(\varepsilon\) in the condition and \(\varepsilon\)-many connection attempts with the same loopback 3-tuple \(L_i\) are required to reliably detect collisions despite \alert{noise}. Connection attempts to the same loopback 3-tuple \(L_i\) are repeated \alert{multiple times} to produce a detectable increment in its perturbation table cell, ensuring that any increments caused by unrelated TCP connections on the device (noise) are outweighed.

The algorithm \alert{terminates} as soon as the following condition is satisfied:

\vspace{-0.2cm}
\begin{minipage}{\columnwidth}
	\[
		n \ge n^*[i],
	\]
\end{minipage}

% where \( n^*[i] \) denotes the required \alert{number of independent pairs} after \( i \) \alert{iterations} to ensure that the \alert{probability} \( P^l_D(n) \) of a random device yielding the same device ID as the device \(D\) remains below the \alert{threshold acceptance probability} \( p^* \).
where \( n^*[i] \) denotes the required \alert{number of independent pairs} after \( i \) \alert{iterations} to ensure that the \alert{probability} \( P^l_D(n) \) of a random device yielding the same device ID as the device \( D \) remains below the \alert{threshold acceptance probability} \( p^* \), and where \( n \) is the \alert{number of independent loopback-loopback collision pairs} observed during the attack for device \( D \).
% where \( n^*[i] \) denotes the required \alert{number of independent pairs} after \( i \) \alert{iterations} to keep the \alert{probability} \( P^l_D(n) \) below the \alert{threshold} \( p^* \), with \( n \) the \alert{number of independent collision pairs} found for device \( D \), and \( l \) the \alert{number of iterations} needed to find them.
% where \( n^*[i] \) denotes the required \alert{number of independent pairs} after \( i \) \alert{iterations} to keep the \alert{probability} \( P^l_D(n) \), defined as the \alert{probability that a random device gets the same ID as device \( D \) after \( l \) iterations with \( n \) independent pairs}, below the \alert{threshold} \( p^* \), with \( n \) the \alert{collision count}.

% This condition guarantees:
% \vspace{-0.8cm}
% \begin{center}
% 	\begin{adjustbox}{max width=\columnwidth}
% 		\begin{minipage}[t]{0.6\textwidth}
% 			\[
% 				\underbrace{
% 				P_D^l(n)
% 				=
% 				\frac{1}{T^n}
% 				\cdot
% 				\prod_{i=0}^{l - n - 1}
% 				\left(1 - \frac{i}{T}\right)
% 				}_{\text{probability that a random device yields same device ID}}
% 				\;<\;
% 				\underbrace{\frac{1}{N_D} = p^*}_{\text{threshold acceptance probability}},
% 			\]
% 		\end{minipage}
% 	\end{adjustbox}
% \end{center}
% % where \( T \) is the \alert{size of the perturbation table}, \( N_D \) is the \alert{total number of devices} under consideration, and \( p_{\text{dev}} \) is the \alert{acceptable probability} that any device collides with the target device ID.
% where \( T \) is the \alert{size of the perturbation table}, \( N_D \) is the \alert{total number of devices} under consideration, and \( p^* \) is the \alert{maximum acceptable probability} that a single random device produces the same device ID as the target device. Setting \( p^* = \frac{1}{N_D^2} \) ensures that the expected number of device ID collisions in the entire population is at most one.

This condition guarantees:
\vspace{-1cm}
\begin{center}
    \begin{adjustbox}{max width=\columnwidth}
        \begin{minipage}[t]{0.5\textwidth}
            \[
                \underbrace{
                P_D^l(n)
                =
                \frac{1}{T^n}
                \cdot
                \prod_{i=0}^{l - n - 1}
                \left(1 - \frac{i}{T}\right)
                }_{\text{probability that a random device yields same device ID}}
                \;<\;
                \underbrace{
                p^* = \frac{1}{\binom{N}{2}}
                }_{\text{threshold acceptance probability}},
            \]
        \end{minipage}
    \end{adjustbox}
\end{center}

where \( T \) is the \alert{size of the perturbation table}, \( N \) is the \alert{total number of devices} under consideration, and \( p^* \) is the \alert{maximum acceptable probability} that any \alert{pair} of devices produces the same device ID. Setting \( p^* = \frac{1}{\binom{N}{2}} \) ensures that the expected number of device ID collisions among all pairs in the entire population is \alert{at most one}.

The required value \( n^*[i] \) is determined as:

\begin{minipage}{\columnwidth}
  \[
n^*[i]
=
\min
\left\{
n
\;\middle|\;
P_D^l(n)
<
p^*
\right\}.
\]
\end{minipage}

Values of \( n^*[i] \) are \alert{precomputed} and stored in a table to avoid repeated evaluation of \( P^l_D(n) \) during the attack. The termination condition is possible to expressed in terms of \( n \) rather than inserted directly into the probability function because \( P^l_D(n) \) depends only on \( n \) and \alert{not on the specific collision structure}. By checking \( n \ge n^*[i] \), the attacker ensures that the probability of a device ID collision with another device remains below \( p^* \) \alert{without recomputing probabilities} each time.

\vspace{0.2cm}
\input{./share/phase2.tex}

\section{Countermeasures}
\label{sec:countermeasures}

The \alert{root cause} of the attack is the ability to detect device-specific hash collisions in $G_{K2}$ through a shared perturbation table between TCP connection attempts, which is incremented in a predictable way.

An \alert{ideal solution} would be to use a separate perturbation table for each network context, but this is impractical due to the high memory cost.% cost on systems running many isolated applications.
% An \alert{ideal solution} would be to create a private perturbation table for each network namespace and interface, preventing attackers from observing stable collisions. However, this is impractical due to high memory consumption when many containers or interfaces exist.

In \alert{general}, \alert{countermeasures} to prevent this attack focus on making hash collisions less frequent or making it much more difficult for attackers to detect them. The paper proposes several modifications to DHPS, and these were incorporated into the Linux kernel through a security patch. The main countermeasures are:
\begin{itemize}
	\item \aalert{Increase table size $T$:}
	A larger perturbation table reduces hash collisions and increases attack cost.
	\textit{The concrete change made in the Linux kernel was to increase the table size to $T = 64K$.}

	\item \aalert{Periodic re-keying:}
	Changing DHPS’s secret key periodically invalidates previously discovered collisions, though it risks reusing ports for the same 3-tuple too soon.
	\textit{The concrete change made in the Linux kernel was to perform re-keying every 10 seconds.}

	\item \aalert{Introduce more noise:}
	Adding randomness to perturbation table increments makes collisions harder to detect.
	\textit{The concrete change made in the Linux kernel was to randomize increments uniformly between 1 and 8.}
\end{itemize}

% \iftoggle{longversion}{
% 	These countermeasures were integrated into Linux versions 5.18 and 5.19, making the attack significantly harder or infeasible.
% }{}

\section{Appendix}
\label{sec:appendix}
\pagenumbering{Alph}

\subsection{Terminology and Conventions}
\label{sec:terminology and conventions}

Throughout this report, the following terminology and conventions are used:
\begin{itemize}
	\item Clickable hyperlinks look like \hyperref[sec:terminology and conventions]{this}, and normal highlighted text looks like \alert{this}.
	\item All sorts of captions like titles of captions or headwords are written like this \aalert{Caption} and all sorts of just highlighted words that are neither of what has just been mentioned are written like \alert{this}.
    \ditem{collision}{Collision of 3-tuples} Actually means collision of (attacker / loopback) 3-tuples in the same perturbation table cell via $G_{K_2}$ but the last part is omitted for brevity.
	\ditem{increment}{Increment source port by x} When it is stated that an attacker 3-tuple had a source port incremented by x, it is the difference between the source ports generated by DHCP for the same attacker 3-tuple (as read from the TCP SYN packet) when establishing a TCP connection in the two wrappers steps of the sandwiching method.
	\ditem{unique}{Unique attacker 3-tuples} Attacker 3-tuples where each uniquely covers one cell of the perturbation table.
	\ditem{candidate}{Candidate attacker 3-tuples} Possible candidates that could become unique attacker 3-tuples if they do not collide with any of the already found unique attacker 3-tuples.
\end{itemize}

\iftoggle{longversion}{}{
	\devicetrackig
}

\section{Bibliography}
\label{sec:bibliography}

\printbibliography[heading=none]

\end{document}
